/* tslint:disable */
/* eslint-disable */
/**
 * TFX API - V1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export enum AccessValues {
    All = 'All',
    Client = 'Client',
    Partner = 'Partner'
}

/**
 * 
 * @export
 * @interface ActivateRequest
 */
export interface ActivateRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateRequest
     */
    serial: string;
}
/**
 * 
 * @export
 * @interface AddBankAccountRequest
 */
export interface AddBankAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    accountName: string;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    swiftbsb?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    wallet?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddBankAccountRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AddBankAccountRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof AddBankAccountRequest
     */
    monthLimit?: number;
}
/**
 * 
 * @export
 * @interface AddCardRequest
 */
export interface AddCardRequest {
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    nameOnCard: string;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    expiry: string;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    cvv: string;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    wallet?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddCardRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AddCardRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof AddCardRequest
     */
    monthLimit?: number;
}
/**
 * 
 * @export
 * @interface AddContactRequest
 */
export interface AddContactRequest {
    /**
     * 
     * @type {string}
     * @memberof AddContactRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AddContactRequest
     */
    nickName?: string | null;
}
/**
 * 
 * @export
 * @interface AddCustodianCryptoRequest
 */
export interface AddCustodianCryptoRequest {
    /**
     * 
     * @type {string}
     * @memberof AddCustodianCryptoRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof AddCustodianCryptoRequest
     */
    wallet?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddCustodianCryptoRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddCustodianCryptoRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AddCustodianCryptoRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof AddCustodianCryptoRequest
     */
    monthLimit?: number;
}
/**
 * 
 * @export
 * @interface AddDeviceRequest
 */
export interface AddDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    uuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    deviceToken: string;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    deviceType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    system?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    systemVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    brand?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddDeviceRequest
     */
    model?: string | null;
}
/**
 * 
 * @export
 * @interface AddDeviceResultDto
 */
export interface AddDeviceResultDto {
    /**
     * 
     * @type {string}
     * @memberof AddDeviceResultDto
     */
    deviceId: string;
}
/**
 * 
 * @export
 * @interface AddMerchantRequest
 */
export interface AddMerchantRequest {
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    nickName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    companyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddMerchantRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface AddMerchantResultDto
 */
export interface AddMerchantResultDto {
    /**
     * 
     * @type {string}
     * @memberof AddMerchantResultDto
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface AddPrepaidAccountRequest
 */
export interface AddPrepaidAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AddPrepaidAccountRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof AddPrepaidAccountRequest
     */
    wallet?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddPrepaidAccountRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddPrepaidAccountRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AddPrepaidAccountRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof AddPrepaidAccountRequest
     */
    monthLimit?: number;
}
/**
 * 
 * @export
 * @interface AddVenueRequest
 */
export interface AddVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    country: string;
    /**
     * 
     * @type {number}
     * @memberof AddVenueRequest
     */
    latitude: number;
    /**
     * 
     * @type {number}
     * @memberof AddVenueRequest
     */
    longitude: number;
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddVenueRequest
     */
    merchantId?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddVenueRequest
     */
    images?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface AddVenueResultDto
 */
export interface AddVenueResultDto {
    /**
     * 
     * @type {string}
     * @memberof AddVenueResultDto
     */
    venueId: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    houseNumberAddition?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipcode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    country?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    longitude?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    isFloatBankAddress?: boolean;
    /**
     * 
     * @type {Venue}
     * @memberof Address
     */
    venue?: Venue;
    /**
     * 
     * @type {Array<PaymentMethodInstance>}
     * @memberof Address
     */
    bankPaymentMethodInstances?: Array<PaymentMethodInstance> | null;
    /**
     * 
     * @type {Array<PaymentMethodInstance>}
     * @memberof Address
     */
    beneficiaryPaymentMethodInstances?: Array<PaymentMethodInstance> | null;
}
/**
 * 
 * @export
 * @interface AddressDto
 */
export interface AddressDto {
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    street2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    houseNumberAddition?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    postcode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressDto
     */
    country: string;
    /**
     * 
     * @type {number}
     * @memberof AddressDto
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof AddressDto
     */
    longitude?: number;
}
/**
 * 
 * @export
 * @interface AllConversions
 */
export interface AllConversions {
    /**
     * 
     * @type {string}
     * @memberof AllConversions
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AllConversions
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof AllConversions
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof AllConversions
     */
    baseCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof AllConversions
     */
    baseCurrency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof AllConversions
     */
    targetCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof AllConversions
     */
    targetCurrency?: Currency;
    /**
     * 
     * @type {number}
     * @memberof AllConversions
     */
    rate?: number;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKey
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {StatusValues}
     * @memberof ApiKey
     */
    status?: StatusValues;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    limit?: number;
    /**
     * 
     * @type {LimitTypeValues}
     * @memberof ApiKey
     */
    limitType?: LimitTypeValues;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    key?: string | null;
    /**
     * 
     * @type {AccessValues}
     * @memberof ApiKey
     */
    access?: AccessValues;
    /**
     * 
     * @type {RoleValues}
     * @memberof ApiKey
     */
    role?: RoleValues;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    applicationInstanceId?: string;
    /**
     * 
     * @type {ApplicationInstance}
     * @memberof ApiKey
     */
    application?: ApplicationInstance;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum AppTypeValues {
    Wallet = 'Wallet',
    Tipsee = 'Tipsee'
}

/**
 * 
 * @export
 * @interface ApplicationInstance
 */
export interface ApplicationInstance {
    /**
     * 
     * @type {string}
     * @memberof ApplicationInstance
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInstance
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInstance
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationInstance
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInstance
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInstance
     */
    description?: string | null;
    /**
     * 
     * @type {AppTypeValues}
     * @memberof ApplicationInstance
     */
    type?: AppTypeValues;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ApplicationInstance
     */
    apiKeys?: Array<ApiKey> | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof ApplicationInstance
     */
    users?: Array<User> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum AuditType {
    Create = 'Create',
    Update = 'Update',
    Delete = 'Delete',
    Read = 'Read'
}

/**
 * 
 * @export
 * @interface AuthorizeBodyRequest
 */
export interface AuthorizeBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthorizeBodyRequest
     */
    _interface?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorizeBodyRequest
     */
    uuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthorizeBodyRequest
     */
    scope?: string | null;
    /**
     * 
     * @type {PayInfoRequestDto}
     * @memberof AuthorizeBodyRequest
     */
    payinfo?: PayInfoRequestDto;
    /**
     * 
     * @type {RecurringRequestDto}
     * @memberof AuthorizeBodyRequest
     */
    recurring?: RecurringRequestDto;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum BankPaymentTypeValues {
    Sepa = 'Sepa',
    Swift = 'Swift'
}

/**
 * 
 * @export
 * @interface BaseSuccessResponse
 */
export interface BaseSuccessResponse {
    /**
     * 
     * @type {number}
     * @memberof BaseSuccessResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof BaseSuccessResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof BaseSuccessResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof BaseSuccessResponse
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface CanLoginResultDto
 */
export interface CanLoginResultDto {
    /**
     * 
     * @type {boolean}
     * @memberof CanLoginResultDto
     */
    canLogin: boolean;
}
/**
 * 
 * @export
 * @interface CancelPreAuthPhysicalWalletRequest
 */
export interface CancelPreAuthPhysicalWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CancelPreAuthPhysicalWalletRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof CancelPreAuthPhysicalWalletRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface ChargeCardRequest
 */
export interface ChargeCardRequest {
    /**
     * 
     * @type {string}
     * @memberof ChargeCardRequest
     */
    cardId: string;
    /**
     * 
     * @type {number}
     * @memberof ChargeCardRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ChargeCardRequest
     */
    rateId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChargeCardRequest
     */
    otp?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ChatMessageTypeValues {
    Normal = 'Normal',
    RequestFund = 'RequestFund',
    RequestFundPaid = 'RequestFundPaid',
    RequestFundDeclined = 'RequestFundDeclined',
    SendToUser = 'SendToUser'
}

/**
 * 
 * @export
 * @interface CheckSessionActiveResultDto
 */
export interface CheckSessionActiveResultDto {
    /**
     * 
     * @type {boolean}
     * @memberof CheckSessionActiveResultDto
     */
    isSessionActive: boolean;
}
/**
 * 
 * @export
 * @interface ClaimPendingTipsRequest
 */
export interface ClaimPendingTipsRequest {
    /**
     * 
     * @type {number}
     * @memberof ClaimPendingTipsRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ClaimPendingTipsRequest
     */
    rateId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClaimPendingTipsRequest
     */
    otp?: string | null;
}
/**
 * 
 * @export
 * @interface ClearPhysicalWalletPaymentMethodRequest
 */
export interface ClearPhysicalWalletPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof ClearPhysicalWalletPaymentMethodRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof ClearPhysicalWalletPaymentMethodRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface ConfigurePreAuthRequest
 */
export interface ConfigurePreAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigurePreAuthRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigurePreAuthRequest
     */
    functionNumber: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigurePreAuthRequest
     */
    startedOn: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigurePreAuthRequest
     */
    duration: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigurePreAuthRequest
     */
    maximumAmount: number;
    /**
     * 
     * @type {Array<PhysicalWalletPaymentType>}
     * @memberof ConfigurePreAuthRequest
     */
    paymentTypes: Array<PhysicalWalletPaymentType>;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurePreAuthRequest
     */
    multiUse: boolean;
}
/**
 * 
 * @export
 * @interface ConfigurePreAuthResultDto
 */
export interface ConfigurePreAuthResultDto {
    /**
     * 
     * @type {string}
     * @memberof ConfigurePreAuthResultDto
     */
    physicalWalletPreAuthId: string;
}
/**
 * 
 * @export
 * @interface ContentResult
 */
export interface ContentResult {
    /**
     * 
     * @type {string}
     * @memberof ContentResult
     */
    content?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentResult
     */
    contentType?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ContentResult
     */
    statusCode?: number | null;
}
/**
 * 
 * @export
 * @interface CountryDto
 */
export interface CountryDto {
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    isoName: string;
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    fullName: string;
}
/**
 * 
 * @export
 * @interface CreateCurrencyRequest
 */
export interface CreateCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCurrencyRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCurrencyRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCurrencyRequest
     */
    description?: string | null;
    /**
     * 
     * @type {CurrencyTypeValues}
     * @memberof CreateCurrencyRequest
     */
    type: CurrencyTypeValues;
    /**
     * 
     * @type {number}
     * @memberof CreateCurrencyRequest
     */
    precision: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCurrencyRequest
     */
    format: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCurrencyRequest
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface CreateCurrencyResultDto
 */
export interface CreateCurrencyResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCurrencyResultDto
     */
    currencyId: string;
}
/**
 * 
 * @export
 * @interface CreateFeeDefinitionDto
 */
export interface CreateFeeDefinitionDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionDto
     */
    fromCurrencyId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionDto
     */
    toCurrencyId: string;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof CreateFeeDefinitionDto
     */
    fromPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof CreateFeeDefinitionDto
     */
    toPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof CreateFeeDefinitionDto
     */
    transactionType: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof CreateFeeDefinitionDto
     */
    paymentType: PaymentTypeValues;
    /**
     * 
     * @type {Array<CreateFeeDefinitionValueDto>}
     * @memberof CreateFeeDefinitionDto
     */
    values?: Array<CreateFeeDefinitionValueDto> | null;
}
/**
 * 
 * @export
 * @interface CreateFeeDefinitionRequest
 */
export interface CreateFeeDefinitionRequest {
    /**
     * 
     * @type {CreateFeeDefinitionDto}
     * @memberof CreateFeeDefinitionRequest
     */
    feeDefinition: CreateFeeDefinitionDto;
}
/**
 * 
 * @export
 * @interface CreateFeeDefinitionResultDto
 */
export interface CreateFeeDefinitionResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionResultDto
     */
    feeDefinitionId: string;
}
/**
 * 
 * @export
 * @interface CreateFeeDefinitionValueCountryDto
 */
export interface CreateFeeDefinitionValueCountryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionValueCountryDto
     */
    fromCountryIso?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionValueCountryDto
     */
    toCountryIso?: string | null;
}
/**
 * 
 * @export
 * @interface CreateFeeDefinitionValueDto
 */
export interface CreateFeeDefinitionValueDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionValueDto
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof CreateFeeDefinitionValueDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof CreateFeeDefinitionValueDto
     */
    currencyId: string;
    /**
     * 
     * @type {FeeTypeValues}
     * @memberof CreateFeeDefinitionValueDto
     */
    type: FeeTypeValues;
    /**
     * 
     * @type {FeeUnitValues}
     * @memberof CreateFeeDefinitionValueDto
     */
    unit: FeeUnitValues;
    /**
     * 
     * @type {FeePaidByValues}
     * @memberof CreateFeeDefinitionValueDto
     */
    paidBy: FeePaidByValues;
    /**
     * 
     * @type {boolean}
     * @memberof CreateFeeDefinitionValueDto
     */
    isChoice: boolean;
    /**
     * 
     * @type {Array<CreateFeeDefinitionValueCountryDto>}
     * @memberof CreateFeeDefinitionValueDto
     */
    countries?: Array<CreateFeeDefinitionValueCountryDto> | null;
}
/**
 * 
 * @export
 * @interface CreatePayeeRequestDto
 */
export interface CreatePayeeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    location_type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    payee_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    account_no?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    sort_code?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    account_type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    iban?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    currencyType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    recipientAccountType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    recipientBicSwift?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePayeeRequestDto
     */
    recipientBankName?: string | null;
    /**
     * 
     * @type {RecipientBankAddressDto}
     * @memberof CreatePayeeRequestDto
     */
    recipientBankAddress?: RecipientBankAddressDto;
    /**
     * 
     * @type {RecipientAddress}
     * @memberof CreatePayeeRequestDto
     */
    recipientAddress?: RecipientAddress;
}
/**
 * 
 * @export
 * @interface CreatePaymentMethodRequest
 */
export interface CreatePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    description?: string | null;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof CreatePaymentMethodRequest
     */
    baseType?: PaymentMethodTypeValues;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    currencyId: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    canSend?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    canReceive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    canExchange?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    hasBalance?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    canBank?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    canLock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentMethodRequest
     */
    minimalTransferOutAmount: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentMethodRequest
     */
    minimalExchangeAmount: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    subCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodRequest
     */
    subCurrencySymbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentMethodRequest
     */
    subCurrencyValue?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePaymentMethodRequest
     */
    regionIds?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePaymentMethodRequest
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePaymentMethodResultDto
 */
export interface CreatePaymentMethodResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentMethodResultDto
     */
    paymentMethodId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletPlanRequest
 */
export interface CreatePhysicalWalletPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    currencyId: string;
    /**
     * 
     * @type {PhysicalWalletPlanPeriodValues}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    period: PhysicalWalletPlanPeriodValues;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletPlanRequest
     */
    physicalWalletTierId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletPlanResultDto
 */
export interface CreatePhysicalWalletPlanResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletPlanResultDto
     */
    physicalWalletPlanId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletRequest
 */
export interface CreatePhysicalWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    firstname: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    middlename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    lastname: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    postCode: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    physicalWalletTypeId: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletRequest
     */
    physicalWalletPlanId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletResultDto
 */
export interface CreatePhysicalWalletResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletResultDto
     */
    physicalWalletId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletTierRequest
 */
export interface CreatePhysicalWalletTierRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletTierRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletTierRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreatePhysicalWalletTierRequest
     */
    ordering?: number;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletTierResultDto
 */
export interface CreatePhysicalWalletTierResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletTierResultDto
     */
    physicalWalletTierId: string;
}
/**
 * 
 * @export
 * @interface CreatePhysicalWalletTypeResultDto
 */
export interface CreatePhysicalWalletTypeResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePhysicalWalletTypeResultDto
     */
    physicalWalletTypeId: string;
}
/**
 * 
 * @export
 * @interface CreateRegionRequest
 */
export interface CreateRegionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRegionRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegionRequest
     */
    isoName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegionRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateRegionRequest
     */
    primaryCurrencyId: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRegionRequest
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface CreateRegionResultDto
 */
export interface CreateRegionResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRegionResultDto
     */
    regionId: string;
}
/**
 * 
 * @export
 * @interface CreateRequestUserFundResultDto
 */
export interface CreateRequestUserFundResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRequestUserFundResultDto
     */
    requestUserFundId: string;
}
/**
 * 
 * @export
 * @interface CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequest
     */
    apiKey: string;
}
/**
 * 
 * @export
 * @interface CreateSessionResultDto
 */
export interface CreateSessionResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionResultDto
     */
    token: string;
}
/**
 * 
 * @export
 * @interface CreateWalletTypeRequest
 */
export interface CreateWalletTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWalletTypeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWalletTypeRequest
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface CreateWalletTypeResultDto
 */
export interface CreateWalletTypeResultDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWalletTypeResultDto
     */
    walletTypeId: string;
}
/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Currency
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    symbol?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    description?: string | null;
    /**
     * 
     * @type {CurrencyTypeValues}
     * @memberof Currency
     */
    type?: CurrencyTypeValues;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    precision?: number;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    format?: string | null;
    /**
     * 
     * @type {Array<AllConversions>}
     * @memberof Currency
     */
    baseAllConVersions?: Array<AllConversions> | null;
    /**
     * 
     * @type {Array<AllConversions>}
     * @memberof Currency
     */
    targetAllConVersions?: Array<AllConversions> | null;
    /**
     * 
     * @type {Array<FeeDefinition>}
     * @memberof Currency
     */
    fromFeeDefinitions?: Array<FeeDefinition> | null;
    /**
     * 
     * @type {Array<FeeDefinition>}
     * @memberof Currency
     */
    toFeeDefinitions?: Array<FeeDefinition> | null;
    /**
     * 
     * @type {Array<PaymentMethodCurrency>}
     * @memberof Currency
     */
    paymentMethods?: Array<PaymentMethodCurrency> | null;
    /**
     * 
     * @type {Array<CurrencyExternalServiceSetting>}
     * @memberof Currency
     */
    externalServiceSettings?: Array<CurrencyExternalServiceSetting> | null;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof Currency
     */
    fromTransactionLines?: Array<TransactionLine> | null;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof Currency
     */
    toTransactionLines?: Array<TransactionLine> | null;
    /**
     * 
     * @type {Array<PhysicalWalletPlan>}
     * @memberof Currency
     */
    physicalWalletPlans?: Array<PhysicalWalletPlan> | null;
    /**
     * 
     * @type {Array<Region>}
     * @memberof Currency
     */
    regions?: Array<Region> | null;
    /**
     * 
     * @type {Array<PhysicalWalletType>}
     * @memberof Currency
     */
    physicalWalletTypes?: Array<PhysicalWalletType> | null;
    /**
     * 
     * @type {Array<FeeDefinitionValue>}
     * @memberof Currency
     */
    feeDefinitionValues?: Array<FeeDefinitionValue> | null;
    /**
     * 
     * @type {Array<RequestUserFund>}
     * @memberof Currency
     */
    requestUserFunds?: Array<RequestUserFund> | null;
    /**
     * 
     * @type {Array<RequestAnonymousFund>}
     * @memberof Currency
     */
    requestAnonymousFunds?: Array<RequestAnonymousFund> | null;
    /**
     * 
     * @type {SystemSettings}
     * @memberof Currency
     */
    systemSettings?: SystemSettings;
}
/**
 * 
 * @export
 * @interface CurrencyDto
 */
export interface CurrencyDto {
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    description?: string | null;
    /**
     * 
     * @type {CurrencyTypeValues}
     * @memberof CurrencyDto
     */
    type: CurrencyTypeValues;
    /**
     * 
     * @type {number}
     * @memberof CurrencyDto
     */
    precision: number;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    format: string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyDto
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface CurrencyExternalServiceSetting
 */
export interface CurrencyExternalServiceSetting {
    /**
     * 
     * @type {string}
     * @memberof CurrencyExternalServiceSetting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyExternalServiceSetting
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyExternalServiceSetting
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyExternalServiceSetting
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CurrencyExternalServiceSetting
     */
    currency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof CurrencyExternalServiceSetting
     */
    externalServiceSettingId?: string;
    /**
     * 
     * @type {ExternalServiceSetting}
     * @memberof CurrencyExternalServiceSetting
     */
    externalServiceSetting?: ExternalServiceSetting;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CurrencyTypeValues {
    Fiat = 'Fiat',
    Crypto = 'Crypto',
    Loyalty = 'Loyalty',
    Stocks = 'Stocks'
}

/**
 * 
 * @export
 * @interface DashboardInfoDto
 */
export interface DashboardInfoDto {
    /**
     * 
     * @type {Array<PaymentMethodInstanceDto>}
     * @memberof DashboardInfoDto
     */
    paymentMethods?: Array<PaymentMethodInstanceDto> | null;
    /**
     * 
     * @type {string}
     * @memberof DashboardInfoDto
     */
    selectedMethod?: string | null;
    /**
     * 
     * @type {Array<GetTransactionDto>}
     * @memberof DashboardInfoDto
     */
    firstPaymentMethodTransactions?: Array<GetTransactionDto> | null;
    /**
     * 
     * @type {Array<ExchangeRateDto>}
     * @memberof DashboardInfoDto
     */
    rates?: Array<ExchangeRateDto> | null;
}
/**
 * 
 * @export
 * @interface DeclineUserFundRequest
 */
export interface DeclineUserFundRequest {
    /**
     * 
     * @type {string}
     * @memberof DeclineUserFundRequest
     */
    requestUserFundId: string;
    /**
     * 
     * @type {string}
     * @memberof DeclineUserFundRequest
     */
    reason?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof DeclineUserFundRequest
     */
    stickerPacket?: StickerTransactionPacket;
}
/**
 * 
 * @export
 * @interface DeepKycDto
 */
export interface DeepKycDto {
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    updated?: string;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof DeepKycDto
     */
    level: KycLevelValues;
    /**
     * 
     * @type {KycDocumentTypeValues}
     * @memberof DeepKycDto
     */
    documentType: KycDocumentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    frontSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    backSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    frontFaceImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    proofOfAddressImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    proofOfIncomeImageUrl?: string | null;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof DeepKycDto
     */
    status: KycStatusValues;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    userFullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    checkByUserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepKycDto
     */
    checkByUserFullName?: string | null;
    /**
     * 
     * @type {Array<KycHistoryDto>}
     * @memberof DeepKycDto
     */
    histories?: Array<KycHistoryDto> | null;
}
/**
 * 
 * @export
 * @interface DeepPaymentMethodDto
 */
export interface DeepPaymentMethodDto {
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    description?: string | null;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof DeepPaymentMethodDto
     */
    baseType: PaymentMethodTypeValues;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    canSend: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    canReceive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    canExchange: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    hasBalance: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    canBank: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    canLock: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPaymentMethodDto
     */
    riskFactor?: number;
    /**
     * 
     * @type {number}
     * @memberof DeepPaymentMethodDto
     */
    minimalTransferOutAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof DeepPaymentMethodDto
     */
    minimalExchangeAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    subCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPaymentMethodDto
     */
    subCurrencySymbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeepPaymentMethodDto
     */
    subCurrencyValue?: number;
    /**
     * 
     * @type {Array<CurrencyDto>}
     * @memberof DeepPaymentMethodDto
     */
    currencies?: Array<CurrencyDto> | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPaymentMethodDto
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {Array<RegionDto>}
     * @memberof DeepPaymentMethodDto
     */
    regions?: Array<RegionDto> | null;
}
/**
 * 
 * @export
 * @interface DeepPhysicalWalletDto
 */
export interface DeepPhysicalWalletDto {
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    updated?: string;
    /**
     * 
     * @type {PhysicalWalletStatus}
     * @memberof DeepPhysicalWalletDto
     */
    status: PhysicalWalletStatus;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    firstname: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    middlename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    lastname: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    material?: string | null;
    /**
     * 
     * @type {PhysicalWalletSchemeValues}
     * @memberof DeepPhysicalWalletDto
     */
    scheme?: PhysicalWalletSchemeValues;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletDto
     */
    finish?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    dynamicPinEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    onlinePayment: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    contactlessUsage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    magstripeUsage: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletDto
     */
    onlinePaymentLimit: number;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletDto
     */
    contactlessUsageLimit: number;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletDto
     */
    magstripeUsageLimit: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    preAuthEnabled: boolean;
    /**
     * 
     * @type {PhysicalWalletTypeDto}
     * @memberof DeepPhysicalWalletDto
     */
    type?: PhysicalWalletTypeDto;
    /**
     * 
     * @type {PhysicalWalletPlanDto}
     * @memberof DeepPhysicalWalletDto
     */
    plan?: PhysicalWalletPlanDto;
    /**
     * 
     * @type {Array<PhysicalWalletPaymentMethodDto>}
     * @memberof DeepPhysicalWalletDto
     */
    paymentMethods?: Array<PhysicalWalletPaymentMethodDto> | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletDto
     */
    preAuthPresentMandatory?: boolean;
}
/**
 * 
 * @export
 * @interface DeepPhysicalWalletPlanDto
 */
export interface DeepPhysicalWalletPlanDto {
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletPlanDto
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletPlanDto
     */
    currencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof DeepPhysicalWalletPlanDto
     */
    currency: CurrencyDto;
    /**
     * 
     * @type {PhysicalWalletPlanPeriodValues}
     * @memberof DeepPhysicalWalletPlanDto
     */
    period: PhysicalWalletPlanPeriodValues;
    /**
     * 
     * @type {PhysicalWalletTierDto}
     * @memberof DeepPhysicalWalletPlanDto
     */
    tier?: PhysicalWalletTierDto;
}
/**
 * 
 * @export
 * @interface DeepPhysicalWalletTierDto
 */
export interface DeepPhysicalWalletTierDto {
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTierDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTierDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTierDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTierDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTierDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTierDto
     */
    ordering: number;
    /**
     * 
     * @type {Array<PhysicalWalletTypeDto>}
     * @memberof DeepPhysicalWalletTierDto
     */
    physicalWalletTypes?: Array<PhysicalWalletTypeDto> | null;
    /**
     * 
     * @type {Array<PhysicalWalletPlanDto>}
     * @memberof DeepPhysicalWalletTierDto
     */
    plans?: Array<PhysicalWalletPlanDto> | null;
}
/**
 * 
 * @export
 * @interface DeepPhysicalWalletTypeDto
 */
export interface DeepPhysicalWalletTypeDto {
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    imageLink?: string | null;
    /**
     * 
     * @type {WalletTypeDto}
     * @memberof DeepPhysicalWalletTypeDto
     */
    walletType?: WalletTypeDto;
    /**
     * 
     * @type {PhysicalWalletSchemeValues}
     * @memberof DeepPhysicalWalletTypeDto
     */
    scheme?: PhysicalWalletSchemeValues;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasKeyboard: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasCvvDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasPinDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasPanDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasDynamicCvv: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasDynamicPan: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasDynamicPin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    hasDynamicExpiry: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    physicalAuth: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    material?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    appColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    finish?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTypeDto
     */
    cost?: number;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    costCurrencyId?: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof DeepPhysicalWalletTypeDto
     */
    costCurrency?: CurrencyDto;
    /**
     * 
     * @type {string}
     * @memberof DeepPhysicalWalletTypeDto
     */
    issuerName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthAllEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthMultiUseAllAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthAllMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthMagstripeEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthMagstripeMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthMagstripeMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthContactlessEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthContactlessMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthContactlessMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndSigEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndSigMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndSigMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndPinEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndPinMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeepPhysicalWalletTypeDto
     */
    preAuthChipAndPinMinAmount?: number;
    /**
     * 
     * @type {PhysicalWalletTierDto}
     * @memberof DeepPhysicalWalletTypeDto
     */
    tier?: PhysicalWalletTierDto;
}
/**
 * 
 * @export
 * @interface DeleteMerchantRequest
 */
export interface DeleteMerchantRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteMerchantRequest
     */
    login: string;
}
/**
 * 
 * @export
 * @interface DeletePaymentMethodRequest
 */
export interface DeletePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof DeletePaymentMethodRequest
     */
    paymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof DeletePaymentMethodRequest
     */
    walletName?: string | null;
}
/**
 * 
 * @export
 * @interface DeleteUserByAdminRequest
 */
export interface DeleteUserByAdminRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteUserByAdminRequest
     */
    login: string;
}
/**
 * 
 * @export
 * @interface DeleteVenueRequest
 */
export interface DeleteVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteVenueRequest
     */
    venueId: string;
}
/**
 * 
 * @export
 * @interface DeleteWalletsRequest
 */
export interface DeleteWalletsRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteWalletsRequest
     */
    login: string;
}
/**
 * 
 * @export
 * @interface DestroyPhysicalWalletRequest
 */
export interface DestroyPhysicalWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof DestroyPhysicalWalletRequest
     */
    physicalWalletId: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    uuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    system?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    systemVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    brand?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface DeviceDto
 */
export interface DeviceDto {
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    uuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    system?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    systemVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    brand?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceDto
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface EditContactRequest
 */
export interface EditContactRequest {
    /**
     * 
     * @type {string}
     * @memberof EditContactRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof EditContactRequest
     */
    nickName?: string | null;
}
/**
 * 
 * @export
 * @interface EditPaymentMethodRequest
 */
export interface EditPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof EditPaymentMethodRequest
     */
    paymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentMethodRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditPaymentMethodRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EditPaymentMethodRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof EditPaymentMethodRequest
     */
    monthLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EditPaymentMethodRequest
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditPaymentMethodRequest
     */
    receiveEmail?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditPaymentMethodRequest
     */
    receiveSMS?: boolean;
}
/**
 * 
 * @export
 * @interface EditVenueRequest
 */
export interface EditVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof EditVenueRequest
     */
    venueId: string;
    /**
     * 
     * @type {string}
     * @memberof EditVenueRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EditVenueRequest
     */
    description?: string | null;
    /**
     * 
     * @type {Array<UploadedFile>}
     * @memberof EditVenueRequest
     */
    images?: Array<UploadedFile> | null;
}
/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseDto
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseDto
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseDto
     */
    statusCode?: number;
}
/**
 * 
 * @export
 * @interface ExchangePaymentRequest
 */
export interface ExchangePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    fromPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof ExchangePaymentRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    toPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    rateId?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof ExchangePaymentRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {string}
     * @memberof ExchangePaymentRequest
     */
    transactionRequestId?: string | null;
}
/**
 * 
 * @export
 * @interface ExchangeRateDto
 */
export interface ExchangeRateDto {
    /**
     * 
     * @type {string}
     * @memberof ExchangeRateDto
     */
    rateId: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeRateDto
     */
    pair: string;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRateDto
     */
    rate: number;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRateDto
     */
    fee: number;
    /**
     * 
     * @type {string}
     * @memberof ExchangeRateDto
     */
    feeType?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRateDto
     */
    rateWithFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRateDto
     */
    convertedAmount: number;
}
/**
 * 
 * @export
 * @interface ExcutePaymentRequest
 */
export interface ExcutePaymentRequest {
    /**
     * 
     * @type {string}
     * @memberof ExcutePaymentRequest
     */
    userId: string;
    /**
     * 
     * @type {PhysicalWalletPOSTypes}
     * @memberof ExcutePaymentRequest
     */
    posType?: PhysicalWalletPOSTypes;
    /**
     * 
     * @type {string}
     * @memberof ExcutePaymentRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof ExcutePaymentRequest
     */
    functionNumber: number;
    /**
     * 
     * @type {number}
     * @memberof ExcutePaymentRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ExcutePaymentRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof ExcutePaymentRequest
     */
    fee: number;
    /**
     * 
     * @type {string}
     * @memberof ExcutePaymentRequest
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof ExcutePaymentRequest
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface ExternalServiceSetting
 */
export interface ExternalServiceSetting {
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    updated?: string;
    /**
     * 
     * @type {ExternalServiceType}
     * @memberof ExternalServiceSetting
     */
    type?: ExternalServiceType;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    classId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    config?: string | null;
    /**
     * 
     * @type {Array<RegionExternalServiceSetting>}
     * @memberof ExternalServiceSetting
     */
    regions?: Array<RegionExternalServiceSetting> | null;
    /**
     * 
     * @type {Array<CurrencyExternalServiceSetting>}
     * @memberof ExternalServiceSetting
     */
    currencies?: Array<CurrencyExternalServiceSetting> | null;
    /**
     * 
     * @type {SystemSettings}
     * @memberof ExternalServiceSetting
     */
    systemSettings?: SystemSettings;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSetting
     */
    systemSettingsId?: string;
}
/**
 * 
 * @export
 * @interface ExternalServiceSettingDto
 */
export interface ExternalServiceSettingDto {
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    classId: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    description?: string | null;
    /**
     * 
     * @type {ExternalServiceType}
     * @memberof ExternalServiceSettingDto
     */
    type: ExternalServiceType;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceSettingDto
     */
    config?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExternalServiceSettingDto
     */
    regions?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExternalServiceSettingDto
     */
    currencies?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ExternalServiceType {
    Processor = 'Processor',
    Issuer = 'Issuer',
    Acquirer = 'Acquirer',
    MoneyHolder = 'MoneyHolder',
    User = 'User',
    Exchange = 'Exchange',
    Notification = 'Notification'
}

/**
 * 
 * @export
 * @interface FeeDefinition
 */
export interface FeeDefinition {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinition
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinition
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinition
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinition
     */
    fromCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof FeeDefinition
     */
    fromCurrency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinition
     */
    toCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof FeeDefinition
     */
    toCurrency?: Currency;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof FeeDefinition
     */
    fromPaymentMethodType?: PaymentMethodTypeValues;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof FeeDefinition
     */
    toPaymentMethodType?: PaymentMethodTypeValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof FeeDefinition
     */
    transactionType?: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof FeeDefinition
     */
    paymentType?: PaymentTypeValues;
    /**
     * 
     * @type {Array<FeeDefinitionValue>}
     * @memberof FeeDefinition
     */
    values?: Array<FeeDefinitionValue> | null;
}
/**
 * 
 * @export
 * @interface FeeDefinitionDto
 */
export interface FeeDefinitionDto {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionDto
     */
    fromCurrencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof FeeDefinitionDto
     */
    fromCurrency?: CurrencyDto;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionDto
     */
    toCurrencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof FeeDefinitionDto
     */
    toCurrency?: CurrencyDto;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof FeeDefinitionDto
     */
    fromPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof FeeDefinitionDto
     */
    toPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof FeeDefinitionDto
     */
    transactionType: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof FeeDefinitionDto
     */
    paymentType: PaymentTypeValues;
    /**
     * 
     * @type {Array<FeeDefinitionValueDto>}
     * @memberof FeeDefinitionDto
     */
    values?: Array<FeeDefinitionValueDto> | null;
}
/**
 * 
 * @export
 * @interface FeeDefinitionValue
 */
export interface FeeDefinitionValue {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    feeDefinitionId?: string;
    /**
     * 
     * @type {FeeDefinition}
     * @memberof FeeDefinitionValue
     */
    feeDefinition?: FeeDefinition;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FeeDefinitionValue
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValue
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof FeeDefinitionValue
     */
    currency?: Currency;
    /**
     * 
     * @type {FeeTypeValues}
     * @memberof FeeDefinitionValue
     */
    type?: FeeTypeValues;
    /**
     * 
     * @type {FeeUnitValues}
     * @memberof FeeDefinitionValue
     */
    unit?: FeeUnitValues;
    /**
     * 
     * @type {FeePaidByValues}
     * @memberof FeeDefinitionValue
     */
    paidBy?: FeePaidByValues;
    /**
     * 
     * @type {boolean}
     * @memberof FeeDefinitionValue
     */
    isChoice?: boolean;
    /**
     * 
     * @type {Array<FeeDefinitionValueCountry>}
     * @memberof FeeDefinitionValue
     */
    countries?: Array<FeeDefinitionValueCountry> | null;
}
/**
 * 
 * @export
 * @interface FeeDefinitionValueCountry
 */
export interface FeeDefinitionValueCountry {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    feeDefinitionValueId?: string;
    /**
     * 
     * @type {FeeDefinitionValue}
     * @memberof FeeDefinitionValueCountry
     */
    feeDefinitionValue?: FeeDefinitionValue;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    fromCountryIso?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountry
     */
    toCountryIso?: string | null;
}
/**
 * 
 * @export
 * @interface FeeDefinitionValueCountryDto
 */
export interface FeeDefinitionValueCountryDto {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    feeDefinitionValueId: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    fromCountryIso: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueCountryDto
     */
    toCountryIso: string;
}
/**
 * 
 * @export
 * @interface FeeDefinitionValueDto
 */
export interface FeeDefinitionValueDto {
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    feeDefinitionId: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FeeDefinitionValueDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof FeeDefinitionValueDto
     */
    currencyId?: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof FeeDefinitionValueDto
     */
    currency?: CurrencyDto;
    /**
     * 
     * @type {FeeTypeValues}
     * @memberof FeeDefinitionValueDto
     */
    type: FeeTypeValues;
    /**
     * 
     * @type {FeeUnitValues}
     * @memberof FeeDefinitionValueDto
     */
    unit: FeeUnitValues;
    /**
     * 
     * @type {FeePaidByValues}
     * @memberof FeeDefinitionValueDto
     */
    paidBy: FeePaidByValues;
    /**
     * 
     * @type {boolean}
     * @memberof FeeDefinitionValueDto
     */
    isChoice: boolean;
    /**
     * 
     * @type {Array<FeeDefinitionValueCountryDto>}
     * @memberof FeeDefinitionValueDto
     */
    countries?: Array<FeeDefinitionValueCountryDto> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum FeePaidByValues {
    Sender = 'Sender',
    Receiver = 'Receiver',
    Both = 'Both',
    Tfx = 'Tfx'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum FeePeriodUnitValues {
    Date = 'Date',
    Month = 'Month',
    Quarter = 'Quarter',
    Year = 'Year'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum FeeTypeValues {
    Internal = 'Internal',
    External = 'External'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum FeeUnitValues {
    Fixed = 'Fixed',
    Percentage = 'Percentage'
}

/**
 * 
 * @export
 * @interface FindUserByMobileEmailRequest
 */
export interface FindUserByMobileEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof FindUserByMobileEmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface FindUserByMobileEmailResultDto
 */
export interface FindUserByMobileEmailResultDto {
    /**
     * 
     * @type {string}
     * @memberof FindUserByMobileEmailResultDto
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface FindUserByMobileNumberRequest
 */
export interface FindUserByMobileNumberRequest {
    /**
     * 
     * @type {string}
     * @memberof FindUserByMobileNumberRequest
     */
    mobileNumber: string;
}
/**
 * 
 * @export
 * @interface FindUserByMobileNumberResultDto
 */
export interface FindUserByMobileNumberResultDto {
    /**
     * 
     * @type {string}
     * @memberof FindUserByMobileNumberResultDto
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface FinishSetupPhysicalWalletRequest
 */
export interface FinishSetupPhysicalWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof FinishSetupPhysicalWalletRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof FinishSetupPhysicalWalletRequest
     */
    physicalWalletReference: string;
    /**
     * 
     * @type {string}
     * @memberof FinishSetupPhysicalWalletRequest
     */
    otp: string;
}
/**
 * 
 * @export
 * @interface ForgotPinRequest
 */
export interface ForgotPinRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPinRequest
     */
    loginPin: string;
    /**
     * 
     * @type {string}
     * @memberof ForgotPinRequest
     */
    mobileNumber: string;
}
/**
 * 
 * @export
 * @interface GeneratePersoBatchRequest
 */
export interface GeneratePersoBatchRequest {
    /**
     * 
     * @type {number}
     * @memberof GeneratePersoBatchRequest
     */
    numberOfRecords: number;
    /**
     * 
     * @type {string}
     * @memberof GeneratePersoBatchRequest
     */
    physicalWalletTypeId: string;
}
/**
 * 
 * @export
 * @interface GetActivatedStickerDto
 */
export interface GetActivatedStickerDto {
    /**
     * 
     * @type {string}
     * @memberof GetActivatedStickerDto
     */
    serial: string;
    /**
     * 
     * @type {string}
     * @memberof GetActivatedStickerDto
     */
    message?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetActivatedStickerDto
     */
    macAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetActivatedStickerDto
     */
    signature?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetActivatedStickerDto
     */
    signedP?: string | null;
}
/**
 * 
 * @export
 * @interface GetAllIssuersResultDto
 */
export interface GetAllIssuersResultDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAllIssuersResultDto
     */
    issuers: Array<string>;
}
/**
 * 
 * @export
 * @interface GetAllStickersDto
 */
export interface GetAllStickersDto {
    /**
     * 
     * @type {string}
     * @memberof GetAllStickersDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllStickersDto
     */
    serial: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllStickersDto
     */
    macAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllStickersDto
     */
    status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllStickersDto
     */
    userName?: string | null;
}
/**
 * 
 * @export
 * @interface GetAllTransactionsDto
 */
export interface GetAllTransactionsDto {
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof GetAllTransactionsDto
     */
    amountFrom: number;
    /**
     * 
     * @type {number}
     * @memberof GetAllTransactionsDto
     */
    amountTo: number;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    currencyFromId: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    currencyFrom: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    currencyToId: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    currencyTo: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    userIdFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    fromUserFirstName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    fromUserMiddleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    fromUserLastName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    userNameFrom?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    userIdTo?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    toUserFirstName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    toUserMiddleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    toUserLastName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    userNameTo?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    fromBaseType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    toBaseType?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAllTransactionsDto
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof GetAllTransactionsDto
     */
    type: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof GetAllTransactionsDto
     */
    paymentType: PaymentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof GetAllTransactionsDto
     */
    transactionTime?: string;
}
/**
 * 
 * @export
 * @interface GetAllUsersDto
 */
export interface GetAllUsersDto {
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {RoleValues}
     * @memberof GetAllUsersDto
     */
    role: RoleValues;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof GetAllUsersDto
     */
    applicationInstanceId: string;
    /**
     * 
     * @type {UserStatusValues}
     * @memberof GetAllUsersDto
     */
    status: UserStatusValues;
}
/**
 * 
 * @export
 * @interface GetAvailableRegionsSuccessDto
 */
export interface GetAvailableRegionsSuccessDto {
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRegionsSuccessDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRegionsSuccessDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRegionsSuccessDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRegionsSuccessDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<RegionDto>}
     * @memberof GetAvailableRegionsSuccessDto
     */
    result?: Array<RegionDto> | null;
}
/**
 * 
 * @export
 * @interface GetBalanceDto
 */
export interface GetBalanceDto {
    /**
     * 
     * @type {string}
     * @memberof GetBalanceDto
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceDto
     */
    totalBalance: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceDto
     */
    spentThisMonth: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceDto
     */
    locked: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceDto
     */
    spendable: number;
}
/**
 * 
 * @export
 * @interface GetContactDto
 */
export interface GetContactDto {
    /**
     * 
     * @type {string}
     * @memberof GetContactDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetContactDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof GetContactDto
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof GetContactDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetContactDto
     */
    nickName: string;
}
/**
 * 
 * @export
 * @interface GetEmailOtpResultDto
 */
export interface GetEmailOtpResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetEmailOtpResultDto
     */
    otp: string;
}
/**
 * 
 * @export
 * @interface GetLockStatusDto
 */
export interface GetLockStatusDto {
    /**
     * 
     * @type {boolean}
     * @memberof GetLockStatusDto
     */
    locked: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetLockStatusDto
     */
    hoursLeft: number;
    /**
     * 
     * @type {number}
     * @memberof GetLockStatusDto
     */
    minutesLeft: number;
    /**
     * 
     * @type {string}
     * @memberof GetLockStatusDto
     */
    endTime: string;
}
/**
 * 
 * @export
 * @interface GetMerchantsDto
 */
export interface GetMerchantsDto {
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    nickName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof GetMerchantsDto
     */
    email: string;
    /**
     * 
     * @type {UserStatusValues}
     * @memberof GetMerchantsDto
     */
    status: UserStatusValues;
    /**
     * 
     * @type {RoleValues}
     * @memberof GetMerchantsDto
     */
    role: RoleValues;
}
/**
 * 
 * @export
 * @interface GetPaymentMethodInstanceBalanceAmountsDto
 */
export interface GetPaymentMethodInstanceBalanceAmountsDto {
    /**
     * 
     * @type {CurrencyDto}
     * @memberof GetPaymentMethodInstanceBalanceAmountsDto
     */
    currency: CurrencyDto;
    /**
     * 
     * @type {number}
     * @memberof GetPaymentMethodInstanceBalanceAmountsDto
     */
    value: number;
}
/**
 * 
 * @export
 * @interface GetPaymentMethodInstanceSettingResultDto
 */
export interface GetPaymentMethodInstanceSettingResultDto {
    /**
     * 
     * @type {number}
     * @memberof GetPaymentMethodInstanceSettingResultDto
     */
    spendPerDayLimit: number;
    /**
     * 
     * @type {number}
     * @memberof GetPaymentMethodInstanceSettingResultDto
     */
    spendPerMonthLimit: number;
}
/**
 * 
 * @export
 * @interface GetPendingTipsDto
 */
export interface GetPendingTipsDto {
    /**
     * 
     * @type {number}
     * @memberof GetPendingTipsDto
     */
    pendingTips: number;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletCVCResultDto
 */
export interface GetPhysicalWalletCVCResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletCVCResultDto
     */
    cvc: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletDynamicCVCResultDto
 */
export interface GetPhysicalWalletDynamicCVCResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletDynamicCVCResultDto
     */
    cvc: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletDynamicExpiryResultDto
 */
export interface GetPhysicalWalletDynamicExpiryResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletDynamicExpiryResultDto
     */
    expiryDate: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletDynamicPanResultDto
 */
export interface GetPhysicalWalletDynamicPanResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletDynamicPanResultDto
     */
    pan: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletDynamicPinResultDto
 */
export interface GetPhysicalWalletDynamicPinResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletDynamicPinResultDto
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletExpiryResultDto
 */
export interface GetPhysicalWalletExpiryResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletExpiryResultDto
     */
    expiryDate: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletPanResultDto
 */
export interface GetPhysicalWalletPanResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPanResultDto
     */
    pan: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletPinResultDto
 */
export interface GetPhysicalWalletPinResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPinResultDto
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface GetPhysicalWalletPreAuthResultDto
 */
export interface GetPhysicalWalletPreAuthResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    functionNumber: number;
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    startedOn: string;
    /**
     * 
     * @type {string}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    expiresOn: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    multiUse: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    maximumAmount: number;
    /**
     * 
     * @type {Array<PhysicalWalletPaymentType>}
     * @memberof GetPhysicalWalletPreAuthResultDto
     */
    paymentTypes: Array<PhysicalWalletPaymentType>;
}
/**
 * 
 * @export
 * @interface GetPolicyDto
 */
export interface GetPolicyDto {
    /**
     * 
     * @type {string}
     * @memberof GetPolicyDto
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPolicyDto
     */
    policyActive: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPolicyDto
     */
    minimumPercentage: number;
    /**
     * 
     * @type {number}
     * @memberof GetPolicyDto
     */
    distributedPercentage: number;
}
/**
 * 
 * @export
 * @interface GetRequestFundsViaLinkDto
 */
export interface GetRequestFundsViaLinkDto {
    /**
     * 
     * @type {string}
     * @memberof GetRequestFundsViaLinkDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestFundsViaLinkDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestFundsViaLinkDto
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof GetRequestFundsViaLinkDto
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof GetRequestFundsViaLinkDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GetRequestFundsViaLinkDto
     */
    message?: string | null;
}
/**
 * 
 * @export
 * @interface GetRoamingUsersRequest
 */
export interface GetRoamingUsersRequest {
    /**
     * 
     * @type {number}
     * @memberof GetRoamingUsersRequest
     */
    distanceKm?: number;
}
/**
 * 
 * @export
 * @interface GetSMSOtpResultDto
 */
export interface GetSMSOtpResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetSMSOtpResultDto
     */
    otp: string;
}
/**
 * 
 * @export
 * @interface GetServiceClassIdResultDto
 */
export interface GetServiceClassIdResultDto {
    /**
     * 
     * @type {ExternalServiceType}
     * @memberof GetServiceClassIdResultDto
     */
    type: ExternalServiceType;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetServiceClassIdResultDto
     */
    classIds?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface GetStickerActivateResultDto
 */
export interface GetStickerActivateResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetStickerActivateResultDto
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof GetStickerActivateResultDto
     */
    sig?: string | null;
}
/**
 * 
 * @export
 * @interface GetStickerKeysDto
 */
export interface GetStickerKeysDto {
    /**
     * 
     * @type {string}
     * @memberof GetStickerKeysDto
     */
    serverPubKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetStickerKeysDto
     */
    publicKey?: string | null;
}
/**
 * 
 * @export
 * @interface GetStickerPinCodeResultDto
 */
export interface GetStickerPinCodeResultDto {
    /**
     * 
     * @type {string}
     * @memberof GetStickerPinCodeResultDto
     */
    pinCode: string;
}
/**
 * 
 * @export
 * @interface GetSummaryTransactionFeeAmountDto
 */
export interface GetSummaryTransactionFeeAmountDto {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetSummaryTransactionFeeAmountDto
     */
    day?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetSummaryTransactionFeeAmountDto
     */
    week?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetSummaryTransactionFeeAmountDto
     */
    month?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetSummaryTransactionFeeAmountDto
     */
    threeMonth?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetSummaryTransactionFeeAmountDto
     */
    year?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface GetTipeeWorkingDto
 */
export interface GetTipeeWorkingDto {
    /**
     * 
     * @type {string}
     * @memberof GetTipeeWorkingDto
     */
    venueName: string;
    /**
     * 
     * @type {string}
     * @memberof GetTipeeWorkingDto
     */
    venueId: string;
    /**
     * 
     * @type {number}
     * @memberof GetTipeeWorkingDto
     */
    workHours: number;
    /**
     * 
     * @type {number}
     * @memberof GetTipeeWorkingDto
     */
    workMinutes: number;
    /**
     * 
     * @type {string}
     * @memberof GetTipeeWorkingDto
     */
    startTime: string;
    /**
     * 
     * @type {number}
     * @memberof GetTipeeWorkingDto
     */
    hoursToGo: number;
    /**
     * 
     * @type {number}
     * @memberof GetTipeeWorkingDto
     */
    minutesToGo: number;
    /**
     * 
     * @type {string}
     * @memberof GetTipeeWorkingDto
     */
    endTime?: string;
}
/**
 * 
 * @export
 * @interface GetTipeesByVenueIdDto
 */
export interface GetTipeesByVenueIdDto {
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    id: string;
    /**
     * 
     * @type {TipseeRoleValues}
     * @memberof GetTipeesByVenueIdDto
     */
    role: TipseeRoleValues;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    activeStatus?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    validateStatus?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    workingStatus?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetTipeesByVenueIdDto
     */
    hours?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTipeesByVenueIdDto
     */
    minutes?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    workingSince?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    userName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetTipeesByVenueIdDto
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionAmountByPeriodDto
 */
export interface GetTransactionAmountByPeriodDto {
    /**
     * 
     * @type {number}
     * @memberof GetTransactionAmountByPeriodDto
     */
    transactionAmount: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionAmountByPeriodDto
     */
    dateTime: string;
}
/**
 * 
 * @export
 * @interface GetTransactionAmountRequest
 */
export interface GetTransactionAmountRequest {
    /**
     * 
     * @type {TransactionPeriodUnitValues}
     * @memberof GetTransactionAmountRequest
     */
    periodUnit: TransactionPeriodUnitValues;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionAmountRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionAmountRequest
     */
    beginDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionAmountRequest
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface GetTransactionDto
 */
export interface GetTransactionDto {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    transactionId: string;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof GetTransactionDto
     */
    type: TransactionTypeValues;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    currencySymbol: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    transactionTime: string;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionDto
     */
    conversionRatio?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    moneyCameFromDescription?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionDto
     */
    convertedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionDto
     */
    convertedCurrency?: string | null;
}
/**
 * 
 * @export
 * @interface GetTransactionFeeAmountByBaseCurrencyDto
 */
export interface GetTransactionFeeAmountByBaseCurrencyDto {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeeAmountByBaseCurrencyDto
     */
    baseCurrencyId: string;
    /**
     * 
     * @type {Array<GetTransactionFeeAmountByPeriodDto>}
     * @memberof GetTransactionFeeAmountByBaseCurrencyDto
     */
    fees?: Array<GetTransactionFeeAmountByPeriodDto> | null;
}
/**
 * 
 * @export
 * @interface GetTransactionFeeAmountByPeriodDto
 */
export interface GetTransactionFeeAmountByPeriodDto {
    /**
     * 
     * @type {number}
     * @memberof GetTransactionFeeAmountByPeriodDto
     */
    fee: number;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeeAmountByPeriodDto
     */
    dateTime: string;
}
/**
 * 
 * @export
 * @interface GetTransactionFeesByBaseCurrencyRequest
 */
export interface GetTransactionFeesByBaseCurrencyRequest {
    /**
     * 
     * @type {FeePeriodUnitValues}
     * @memberof GetTransactionFeesByBaseCurrencyRequest
     */
    periodUnit: FeePeriodUnitValues;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeesByBaseCurrencyRequest
     */
    beginDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeesByBaseCurrencyRequest
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface GetTransactionFeesRequest
 */
export interface GetTransactionFeesRequest {
    /**
     * 
     * @type {FeePeriodUnitValues}
     * @memberof GetTransactionFeesRequest
     */
    periodUnit: FeePeriodUnitValues;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeesRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeesRequest
     */
    beginDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionFeesRequest
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface GetTransactionNumberDto
 */
export interface GetTransactionNumberDto {
    /**
     * 
     * @type {number}
     * @memberof GetTransactionNumberDto
     */
    week: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionNumberDto
     */
    month: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionNumberDto
     */
    threeMonth: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactionNumberDto
     */
    year: number;
}
/**
 * 
 * @export
 * @interface GetTransactionsAmountsDto
 */
export interface GetTransactionsAmountsDto {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetTransactionsAmountsDto
     */
    week?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetTransactionsAmountsDto
     */
    month?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetTransactionsAmountsDto
     */
    threeMonth?: { [key: string]: number; } | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetTransactionsAmountsDto
     */
    year?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface GetUserProfileByAdminDto
 */
export interface GetUserProfileByAdminDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    fullName: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    surName: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    joiningDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    nationality: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserProfileByAdminDto
     */
    registerMethod: string;
}
/**
 * 
 * @export
 * @interface GetUserRequestFundDto
 */
export interface GetUserRequestFundDto {
    /**
     * 
     * @type {string}
     * @memberof GetUserRequestFundDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRequestFundDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRequestFundDto
     */
    userName: string;
    /**
     * 
     * @type {number}
     * @memberof GetUserRequestFundDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GetUserRequestFundDto
     */
    currencyId: string;
    /**
     * 
     * @type {RequestFundStatusValues}
     * @memberof GetUserRequestFundDto
     */
    status: RequestFundStatusValues;
    /**
     * 
     * @type {string}
     * @memberof GetUserRequestFundDto
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface GetVenuesByMerchantIdDto
 */
export interface GetVenuesByMerchantIdDto {
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetVenuesByMerchantIdDto
     */
    latitude: number;
    /**
     * 
     * @type {number}
     * @memberof GetVenuesByMerchantIdDto
     */
    longitude: number;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    addressId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    activeStatus?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetVenuesByMerchantIdDto
     */
    validateStatus?: string | null;
}
/**
 * 
 * @export
 * @interface GetVersionDto
 */
export interface GetVersionDto {
    /**
     * 
     * @type {number}
     * @memberof GetVersionDto
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface JoinVenueRequest
 */
export interface JoinVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof JoinVenueRequest
     */
    venueId: string;
}
/**
 * 
 * @export
 * @interface Kyc
 */
export interface Kyc {
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Kyc
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof Kyc
     */
    level?: KycLevelValues;
    /**
     * 
     * @type {KycDocumentTypeValues}
     * @memberof Kyc
     */
    documentType?: KycDocumentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    frontSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    backSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    frontFaceImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    proofOfAddressImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    proofOfIncomeImageUrl?: string | null;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof Kyc
     */
    status?: KycStatusValues;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Kyc
     */
    checkByUserId?: string | null;
    /**
     * 
     * @type {User}
     * @memberof Kyc
     */
    checkBy?: User;
    /**
     * 
     * @type {Array<KycHistory>}
     * @memberof Kyc
     */
    kycHistories?: Array<KycHistory> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum KycDocumentTypeValues {
    None = 'None',
    NationalId = 'NationalId',
    DrivingId = 'DrivingId',
    Passport = 'Passport'
}

/**
 * 
 * @export
 * @interface KycDto
 */
export interface KycDto {
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    updated?: string;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof KycDto
     */
    level: KycLevelValues;
    /**
     * 
     * @type {KycDocumentTypeValues}
     * @memberof KycDto
     */
    documentType: KycDocumentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    frontSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    backSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    frontFaceImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    proofOfAddressImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    proofOfIncomeImageUrl?: string | null;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof KycDto
     */
    status: KycStatusValues;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    userFullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    checkByUserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycDto
     */
    checkByUserFullName?: string | null;
}
/**
 * 
 * @export
 * @interface KycHistory
 */
export interface KycHistory {
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KycHistory
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    kycId?: string;
    /**
     * 
     * @type {Kyc}
     * @memberof KycHistory
     */
    kyc?: Kyc;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof KycHistory
     */
    level?: KycLevelValues;
    /**
     * 
     * @type {KycDocumentTypeValues}
     * @memberof KycHistory
     */
    documentType?: KycDocumentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    frontSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    backSideImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    frontFaceImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    proofOfAddressImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    proofOfIncomeImageUrl?: string | null;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof KycHistory
     */
    status?: KycStatusValues;
    /**
     * 
     * @type {AuditType}
     * @memberof KycHistory
     */
    auditType?: AuditType;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistory
     */
    checkByUserId?: string | null;
    /**
     * 
     * @type {User}
     * @memberof KycHistory
     */
    checkBy?: User;
}
/**
 * 
 * @export
 * @interface KycHistoryDto
 */
export interface KycHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    kycId: string;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof KycHistoryDto
     */
    level: KycLevelValues;
    /**
     * 
     * @type {KycDocumentTypeValues}
     * @memberof KycHistoryDto
     */
    documentType: KycDocumentTypeValues;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof KycHistoryDto
     */
    status: KycStatusValues;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    userFullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    checkByUserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KycHistoryDto
     */
    checkByUserFullName?: string | null;
    /**
     * 
     * @type {AuditType}
     * @memberof KycHistoryDto
     */
    auditType: AuditType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum KycLevelValues {
    NoKyc = 'NoKyc',
    AddressInfo = 'AddressInfo',
    IdOrPassport = 'IdOrPassport',
    ProofOfAddress = 'ProofOfAddress',
    ProofOfIncome = 'ProofOfIncome'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum KycStatusValues {
    Pending = 'Pending',
    Approved = 'Approved',
    Rejected = 'Rejected'
}

/**
 * 
 * @export
 * @interface LeaveVenueRequest
 */
export interface LeaveVenueRequest {
    /**
     * 
     * @type {string}
     * @memberof LeaveVenueRequest
     */
    venueId: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum LimitTypeValues {
    Hour = 'Hour',
    Day = 'Day',
    Week = 'Week',
    Month = 'Month',
    Year = 'Year'
}

/**
 * 
 * @export
 * @interface LockActivityRequest
 */
export interface LockActivityRequest {
    /**
     * 
     * @type {string}
     * @memberof LockActivityRequest
     */
    venueId: string;
    /**
     * 
     * @type {number}
     * @memberof LockActivityRequest
     */
    hours?: number | null;
    /**
     * 
     * @type {number}
     * @memberof LockActivityRequest
     */
    minutes?: number | null;
}
/**
 * 
 * @export
 * @interface LockPaymentMethodRequest
 */
export interface LockPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof LockPaymentMethodRequest
     */
    paymentMethodId: string;
}
/**
 * 
 * @export
 * @interface LoginBiometricsRequest
 */
export interface LoginBiometricsRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginBiometricsRequest
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof LoginBiometricsRequest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof LoginBiometricsRequest
     */
    signature: string;
}
/**
 * 
 * @export
 * @interface LoginPINRequest
 */
export interface LoginPINRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginPINRequest
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof LoginPINRequest
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface LoginPasswordRequest
 */
export interface LoginPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginPasswordRequest
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof LoginPasswordRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface PayInfoRequestDto
 */
export interface PayInfoRequestDto {
    /**
     * 
     * @type {string}
     * @memberof PayInfoRequestDto
     */
    amount?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayInfoRequestDto
     */
    reference?: string | null;
    /**
     * 
     * @type {PayeeInfoRequestDto}
     * @memberof PayInfoRequestDto
     */
    payeeinfo?: PayeeInfoRequestDto;
}
/**
 * 
 * @export
 * @interface PayRequestFundViaLinkRequest
 */
export interface PayRequestFundViaLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    requestFundId: string;
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    fromPaymentMethodInstanceId: string;
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    description?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof PayRequestFundViaLinkRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    transactionRequestId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayRequestFundViaLinkRequest
     */
    rateId?: string | null;
}
/**
 * 
 * @export
 * @interface PayUserFundRequest
 */
export interface PayUserFundRequest {
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    requestUserFundId: string;
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    fromPaymentMethodInstanceId: string;
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    description?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof PayUserFundRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    transactionRequestId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayUserFundRequest
     */
    rateId?: string | null;
}
/**
 * 
 * @export
 * @interface PayeeInfoRequestDto
 */
export interface PayeeInfoRequestDto {
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    account_no?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    sortcode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    iban?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    swiftbic?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    bank_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayeeInfoRequestDto
     */
    bank_address?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    description?: string | null;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof PaymentMethod
     */
    baseType?: PaymentMethodTypeValues;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    canSend?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    canReceive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    canExchange?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    hasBalance?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    canBank?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    canLock?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    autoCreatePmi?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    riskFactor?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    minimalTransferOutAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    minimalExchangeAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    subCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    subCurrencySymbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    subCurrencyValue?: number;
    /**
     * 
     * @type {Array<PaymentMethodInstance>}
     * @memberof PaymentMethod
     */
    paymentMethodInstances?: Array<PaymentMethodInstance> | null;
    /**
     * 
     * @type {Array<PaymentMethodRegion>}
     * @memberof PaymentMethod
     */
    paymentMethodRegions?: Array<PaymentMethodRegion> | null;
    /**
     * 
     * @type {Array<PaymentMethodCurrency>}
     * @memberof PaymentMethod
     */
    paymentMethodCurrencies?: Array<PaymentMethodCurrency> | null;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof PaymentMethod
     */
    currencies?: Array<Currency> | null;
    /**
     * 
     * @type {Array<Region>}
     * @memberof PaymentMethod
     */
    regions?: Array<Region> | null;
}
/**
 * 
 * @export
 * @interface PaymentMethodCurrency
 */
export interface PaymentMethodCurrency {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCurrency
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCurrency
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCurrency
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodCurrency
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCurrency
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentMethodCurrency
     */
    paymentMethod?: PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCurrency
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof PaymentMethodCurrency
     */
    currency?: Currency;
}
/**
 * 
 * @export
 * @interface PaymentMethodDto
 */
export interface PaymentMethodDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    description?: string | null;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof PaymentMethodDto
     */
    baseType: PaymentMethodTypeValues;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    canSend: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    canReceive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    canExchange: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    hasBalance: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    canBank: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    canLock: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodDto
     */
    riskFactor?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodDto
     */
    minimalTransferOutAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodDto
     */
    minimalExchangeAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    subCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodDto
     */
    subCurrencySymbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodDto
     */
    subCurrencyValue?: number;
    /**
     * 
     * @type {Array<CurrencyDto>}
     * @memberof PaymentMethodDto
     */
    currencies?: Array<CurrencyDto> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodDto
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentMethodInstance
 */
export interface PaymentMethodInstance {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    alias?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentMethodInstance
     */
    paymentMethod?: PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    color?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    monthLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    autogenerated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    autoGenerateHash?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    receiveEmail?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    receiveSMS?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    acquirerTokenId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    accountName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    accountNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    swiftBSB?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    bankAddressId?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof PaymentMethodInstance
     */
    bankAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    beneficiaryAddressId?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof PaymentMethodInstance
     */
    beneficiaryAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    expiry?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    cvv?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    spent?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    spentDay?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    spentMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    balance?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    locked?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstance
     */
    spendable?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstance
     */
    frozen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstance
     */
    walletId?: string;
    /**
     * 
     * @type {Wallet}
     * @memberof PaymentMethodInstance
     */
    wallet?: Wallet;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof PaymentMethodInstance
     */
    fromTransactionLines?: Array<TransactionLine> | null;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof PaymentMethodInstance
     */
    toTransactionLines?: Array<TransactionLine> | null;
    /**
     * 
     * @type {Array<PhysicalWalletFundingPaymentMethod>}
     * @memberof PaymentMethodInstance
     */
    physicalWallets?: Array<PhysicalWalletFundingPaymentMethod> | null;
}
/**
 * 
 * @export
 * @interface PaymentMethodInstanceDto
 */
export interface PaymentMethodInstanceDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    scheme?: string | null;
    /**
     * 
     * @type {PaymentMethodDto}
     * @memberof PaymentMethodInstanceDto
     */
    paymentMethod?: PaymentMethodDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    color?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    monthLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    autogenerated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    receiveNotifications: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    receiveEmail: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    receiveSMS: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    acquirerTokenId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    accountName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    accountNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    swiftBSB?: string | null;
    /**
     * 
     * @type {AddressDto}
     * @memberof PaymentMethodInstanceDto
     */
    bankAddress?: AddressDto;
    /**
     * 
     * @type {AddressDto}
     * @memberof PaymentMethodInstanceDto
     */
    beneficiaryAddress?: AddressDto;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    expiry?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    spent?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    spentDay?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    spentMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    balance: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    locked?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    spendable: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    frozen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    bankAddressId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    beneficiaryAddressId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    walletId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    canExchange: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    canBank: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    canSend: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    canReceive: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    currencySymbol: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceDto
     */
    name?: string | null;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof PaymentMethodInstanceDto
     */
    type: PaymentMethodTypeValues;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceDto
     */
    hasBalance: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    dailySpent?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    weeklySpent?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    monthlySpent?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    minimalTransferOutAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceDto
     */
    minimalExchangeAmount?: number;
}
/**
 * 
 * @export
 * @interface PaymentMethodInstanceSetting
 */
export interface PaymentMethodInstanceSetting {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceSetting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceSetting
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceSetting
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodInstanceSetting
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceSetting
     */
    spendPerDayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodInstanceSetting
     */
    spendPerMonthLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodInstanceSetting
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodRegion
 */
export interface PaymentMethodRegion {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRegion
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRegion
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRegion
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRegion
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentMethodRegion
     */
    paymentMethod?: PaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodRegion
     */
    regionId?: string;
    /**
     * 
     * @type {Region}
     * @memberof PaymentMethodRegion
     */
    region?: Region;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PaymentMethodTypeValues {
    Card = 'Card',
    Bank = 'Bank',
    CustCrypto = 'CustCrypto',
    Prepaid = 'Prepaid',
    LocalCrypto = 'LocalCrypto',
    Crypto = 'Crypto',
    ThirdPartyLoyalty = 'ThirdPartyLoyalty',
    InternalLoyalty = 'InternalLoyalty',
    Ativos = 'Ativos'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum PaymentTypeValues {
    Internal = 'Internal',
    Sepa = 'Sepa',
    Card = 'Card',
    Swift = 'Swift',
    Chaps = 'Chaps',
    Bacs = 'Bacs',
    Fast = 'Fast',
    Ach = 'Ach',
    FasterPayments = 'FasterPayments',
    Fx = 'Fx',
    Wire = 'Wire',
    InternalBlockchain = 'InternalBlockchain',
    ExternalBlockchain = 'ExternalBlockchain'
}

/**
 * 
 * @export
 * @interface PhysicalWallet
 */
export interface PhysicalWallet {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    physicalWalletTypeId?: string;
    /**
     * 
     * @type {PhysicalWalletType}
     * @memberof PhysicalWallet
     */
    type?: PhysicalWalletType;
    /**
     * 
     * @type {PhysicalWalletStatus}
     * @memberof PhysicalWallet
     */
    status?: PhysicalWalletStatus;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    firstname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    middlename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    lastname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    zipCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    email?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    dynamicPinEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    onlinePayment?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    contactlessUsage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    magstripeUsage?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWallet
     */
    onlinePaymentLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWallet
     */
    contactlessUsageLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWallet
     */
    magstripeUsageLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    preAuthEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    preAuthMagStripeEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    preAuthContactlessEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    preAuthPinAndSigEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWallet
     */
    preAuthChipAndPinEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    externalPhysicalWalletId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWallet
     */
    physicalWalletPlanId?: string;
    /**
     * 
     * @type {PhysicalWalletPlan}
     * @memberof PhysicalWallet
     */
    plan?: PhysicalWalletPlan;
    /**
     * 
     * @type {Array<PhysicalWalletPreAuth>}
     * @memberof PhysicalWallet
     */
    preAuths?: Array<PhysicalWalletPreAuth> | null;
    /**
     * 
     * @type {Array<PhysicalWalletFundingPaymentMethod>}
     * @memberof PhysicalWallet
     */
    paymentMethods?: Array<PhysicalWalletFundingPaymentMethod> | null;
}
/**
 * 
 * @export
 * @interface PhysicalWalletDto
 */
export interface PhysicalWalletDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    updated?: string;
    /**
     * 
     * @type {PhysicalWalletStatus}
     * @memberof PhysicalWalletDto
     */
    status: PhysicalWalletStatus;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    firstname: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    middlename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    lastname: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    material?: string | null;
    /**
     * 
     * @type {PhysicalWalletSchemeValues}
     * @memberof PhysicalWalletDto
     */
    scheme?: PhysicalWalletSchemeValues;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletDto
     */
    finish?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletDto
     */
    dynamicPinEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletDto
     */
    onlinePayment: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletDto
     */
    contactlessUsage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletDto
     */
    magstripeUsage: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletDto
     */
    onlinePaymentLimit: number;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletDto
     */
    contactlessUsageLimit: number;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletDto
     */
    magstripeUsageLimit: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletDto
     */
    preAuthEnabled: boolean;
    /**
     * 
     * @type {PhysicalWalletTypeDto}
     * @memberof PhysicalWalletDto
     */
    type?: PhysicalWalletTypeDto;
    /**
     * 
     * @type {PhysicalWalletPlanDto}
     * @memberof PhysicalWalletDto
     */
    plan?: PhysicalWalletPlanDto;
}
/**
 * 
 * @export
 * @interface PhysicalWalletFundingPaymentMethod
 */
export interface PhysicalWalletFundingPaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    functionNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    physicalWalletId?: string;
    /**
     * 
     * @type {PhysicalWallet}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    physicalWallet?: PhysicalWallet;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    paymentMethodInstanceId?: string;
    /**
     * 
     * @type {PaymentMethodInstance}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    paymentMethodInstance?: PaymentMethodInstance;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletFundingPaymentMethod
     */
    isDefault?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletPOSTypes {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4,
    NUMBER_5 = 5
}

/**
 * 
 * @export
 * @interface PhysicalWalletPaymentMethodDto
 */
export interface PhysicalWalletPaymentMethodDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPaymentMethodDto
     */
    paymentMethodInstanceId?: string;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletPaymentMethodDto
     */
    functionNumber?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletPaymentType {
    Contactless = 1,
    Magstripe = 2
}

/**
 * 
 * @export
 * @interface PhysicalWalletPersoDto
 */
export interface PhysicalWalletPersoDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPersoDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPersoDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPersoDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPersoDto
     */
    physicalWalletReference: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPersoDto
     */
    physicalWalletXml: string;
}
/**
 * 
 * @export
 * @interface PhysicalWalletPlan
 */
export interface PhysicalWalletPlan {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletPlan
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletPlan
     */
    price?: number;
    /**
     * 
     * @type {PhysicalWalletPlanPeriodValues}
     * @memberof PhysicalWalletPlan
     */
    period?: PhysicalWalletPlanPeriodValues;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    physicalWalletTierId?: string;
    /**
     * 
     * @type {PhysicalWalletTier}
     * @memberof PhysicalWalletPlan
     */
    tier?: PhysicalWalletTier;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlan
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof PhysicalWalletPlan
     */
    currency?: Currency;
    /**
     * 
     * @type {Array<PhysicalWallet>}
     * @memberof PhysicalWalletPlan
     */
    physicalWallets?: Array<PhysicalWallet> | null;
}
/**
 * 
 * @export
 * @interface PhysicalWalletPlanDto
 */
export interface PhysicalWalletPlanDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletPlanDto
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPlanDto
     */
    currencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof PhysicalWalletPlanDto
     */
    currency: CurrencyDto;
    /**
     * 
     * @type {PhysicalWalletPlanPeriodValues}
     * @memberof PhysicalWalletPlanDto
     */
    period: PhysicalWalletPlanPeriodValues;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletPlanPeriodValues {
    Month = 'Month',
    Quarter = 'Quarter',
    Year = 'Year'
}

/**
 * 
 * @export
 * @interface PhysicalWalletPreAuth
 */
export interface PhysicalWalletPreAuth {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletPreAuth
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    physicalWalletId?: string;
    /**
     * 
     * @type {PhysicalWallet}
     * @memberof PhysicalWalletPreAuth
     */
    physicalWallet?: PhysicalWallet;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletPreAuth
     */
    functionNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    startedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletPreAuth
     */
    expiresOn?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletPreAuth
     */
    multiUse?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletPreAuth
     */
    maximumAmount?: number;
    /**
     * 
     * @type {PhysicalWalletPaymentType}
     * @memberof PhysicalWalletPreAuth
     */
    paymentType?: PhysicalWalletPaymentType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletSchemeValues {
    Visa = 'Visa',
    MasterCard = 'MasterCard',
    Cup = 'Cup',
    ClosedLoop = 'ClosedLoop'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletStatus {
    Active = 'Active',
    InActive = 'InActive',
    Blocked = 'Blocked',
    Frozen = 'Frozen',
    Stolen = 'Stolen'
}

/**
 * 
 * @export
 * @interface PhysicalWalletTier
 */
export interface PhysicalWalletTier {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTier
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTier
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTier
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTier
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTier
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTier
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTier
     */
    ordering?: number;
    /**
     * 
     * @type {Array<PhysicalWalletPlan>}
     * @memberof PhysicalWalletTier
     */
    plans?: Array<PhysicalWalletPlan> | null;
    /**
     * 
     * @type {Array<PhysicalWalletType>}
     * @memberof PhysicalWalletTier
     */
    physicalWalletTypes?: Array<PhysicalWalletType> | null;
}
/**
 * 
 * @export
 * @interface PhysicalWalletTierDto
 */
export interface PhysicalWalletTierDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTierDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTierDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTierDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTierDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTierDto
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTierDto
     */
    ordering: number;
}
/**
 * 
 * @export
 * @interface PhysicalWalletType
 */
export interface PhysicalWalletType {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    imageLink?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    walletTypeId?: string;
    /**
     * 
     * @type {WalletType}
     * @memberof PhysicalWalletType
     */
    walletType?: WalletType;
    /**
     * 
     * @type {PhysicalWalletSchemeValues}
     * @memberof PhysicalWalletType
     */
    scheme?: PhysicalWalletSchemeValues;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasKeyboard?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasCvvDisplay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasPinDisplay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasPanDisplay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasDynamicCvv?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasDynamicPan?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasDynamicPin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    hasDynamicExpiry?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    physicalAuth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthAllEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthMultiUseAllAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthAllMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthMagstripeEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletType
     */
    preAuthMagstripeMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthMagstripeMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthContactlessEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthContactlessMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletType
     */
    preAuthContactlessMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndSigEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndSigMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndSigMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndPinEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndPinMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletType
     */
    preAuthChipAndPinMinAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    material?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    appColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    finish?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletType
     */
    cost?: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    costCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof PhysicalWalletType
     */
    costCurrency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    issuerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletType
     */
    physicalWalletTierId?: string;
    /**
     * 
     * @type {PhysicalWalletTier}
     * @memberof PhysicalWalletType
     */
    tier?: PhysicalWalletTier;
    /**
     * 
     * @type {Array<PhysicalWallet>}
     * @memberof PhysicalWalletType
     */
    physicalWallets?: Array<PhysicalWallet> | null;
}
/**
 * 
 * @export
 * @interface PhysicalWalletTypeDto
 */
export interface PhysicalWalletTypeDto {
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    imageLink?: string | null;
    /**
     * 
     * @type {PhysicalWalletTierDto}
     * @memberof PhysicalWalletTypeDto
     */
    tier?: PhysicalWalletTierDto;
    /**
     * 
     * @type {WalletTypeDto}
     * @memberof PhysicalWalletTypeDto
     */
    walletType?: WalletTypeDto;
    /**
     * 
     * @type {PhysicalWalletSchemeValues}
     * @memberof PhysicalWalletTypeDto
     */
    scheme?: PhysicalWalletSchemeValues;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasKeyboard: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasCvvDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasPinDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasPanDisplay: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasDynamicCvv: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasDynamicPan: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasDynamicPin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    hasDynamicExpiry: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    physicalAuth: boolean;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    material?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    appColor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    finish?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTypeDto
     */
    cost?: number;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    costCurrencyId?: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof PhysicalWalletTypeDto
     */
    costCurrency?: CurrencyDto;
    /**
     * 
     * @type {string}
     * @memberof PhysicalWalletTypeDto
     */
    issuerName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthAllEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthMultiUseAllAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthAllMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthMagstripeEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthMagstripeMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthMagstripeMandatory?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthContactlessEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthContactlessMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthContactlessMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndSigEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndSigMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndSigMinAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndPinEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndPinMandatory?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PhysicalWalletTypeDto
     */
    preAuthChipAndPinMinAmount?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PhysicalWalletValidateStatus {
    Approved = 'Approved',
    Declined = 'Declined'
}

/**
 * 
 * @export
 * @interface ReadMessageRequest
 */
export interface ReadMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ReadMessageRequest
     */
    messageId: string;
    /**
     * 
     * @type {string}
     * @memberof ReadMessageRequest
     */
    userReadId: string;
}
/**
 * 
 * @export
 * @interface RecipientAddress
 */
export interface RecipientAddress {
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    addressLine1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    addressLine2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    county?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientAddress
     */
    city?: string | null;
}
/**
 * 
 * @export
 * @interface RecipientBankAddressDto
 */
export interface RecipientBankAddressDto {
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    addressLine1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    addressLine2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    county?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipientBankAddressDto
     */
    city?: string | null;
}
/**
 * 
 * @export
 * @interface RecurringRequestDto
 */
export interface RecurringRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RecurringRequestDto
     */
    regularity?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecurringRequestDto
     */
    ondate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecurringRequestDto
     */
    startdate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecurringRequestDto
     */
    enddate?: string | null;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Region
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    ISOName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    primaryCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Region
     */
    primaryCurrency?: Currency;
    /**
     * 
     * @type {Array<PaymentMethodRegion>}
     * @memberof Region
     */
    paymentMethods?: Array<PaymentMethodRegion> | null;
    /**
     * 
     * @type {Array<RegionExternalServiceSetting>}
     * @memberof Region
     */
    externalServiceSettings?: Array<RegionExternalServiceSetting> | null;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof Region
     */
    currencies?: Array<Currency> | null;
}
/**
 * 
 * @export
 * @interface RegionDto
 */
export interface RegionDto {
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    ISOName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegionDto
     */
    primaryCurrencyId: string;
    /**
     * 
     * @type {boolean}
     * @memberof RegionDto
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface RegionExternalServiceSetting
 */
export interface RegionExternalServiceSetting {
    /**
     * 
     * @type {string}
     * @memberof RegionExternalServiceSetting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionExternalServiceSetting
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionExternalServiceSetting
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionExternalServiceSetting
     */
    regionId?: string;
    /**
     * 
     * @type {Region}
     * @memberof RegionExternalServiceSetting
     */
    region?: Region;
    /**
     * 
     * @type {string}
     * @memberof RegionExternalServiceSetting
     */
    externalServiceSettingId?: string;
    /**
     * 
     * @type {ExternalServiceSetting}
     * @memberof RegionExternalServiceSetting
     */
    externalServiceSetting?: ExternalServiceSetting;
}
/**
 * 
 * @export
 * @interface RemoveContactRequest
 */
export interface RemoveContactRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoveContactRequest
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface RemoveUserRequest
 */
export interface RemoveUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoveUserRequest
     */
    venueId: string;
    /**
     * 
     * @type {string}
     * @memberof RemoveUserRequest
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface RequestAnonymousFund
 */
export interface RequestAnonymousFund {
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestAnonymousFund
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    originalUserId?: string;
    /**
     * 
     * @type {User}
     * @memberof RequestAnonymousFund
     */
    originalUser?: User;
    /**
     * 
     * @type {number}
     * @memberof RequestAnonymousFund
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof RequestAnonymousFund
     */
    currency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFund
     */
    message?: string | null;
    /**
     * 
     * @type {Array<RequestAnonymousFundTransaction>}
     * @memberof RequestAnonymousFund
     */
    transactions?: Array<RequestAnonymousFundTransaction> | null;
}
/**
 * 
 * @export
 * @interface RequestAnonymousFundTransaction
 */
export interface RequestAnonymousFundTransaction {
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFundTransaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFundTransaction
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFundTransaction
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFundTransaction
     */
    requestAnonymousFundId?: string;
    /**
     * 
     * @type {RequestAnonymousFund}
     * @memberof RequestAnonymousFundTransaction
     */
    requestAnonymousFund?: RequestAnonymousFund;
    /**
     * 
     * @type {string}
     * @memberof RequestAnonymousFundTransaction
     */
    transactionId?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof RequestAnonymousFundTransaction
     */
    transaction?: Transaction;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum RequestFundStatusValues {
    Requested = 'Requested',
    Paid = 'Paid',
    Denied = 'Denied'
}

/**
 * 
 * @export
 * @interface RequestFundToUserRequest
 */
export interface RequestFundToUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RequestFundToUserRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof RequestFundToUserRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof RequestFundToUserRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestFundToUserRequest
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface RequestFundsViaLinkRequest
 */
export interface RequestFundsViaLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof RequestFundsViaLinkRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof RequestFundsViaLinkRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof RequestFundsViaLinkRequest
     */
    message?: string | null;
}
/**
 * 
 * @export
 * @interface RequestFundsViaLinkResultDto
 */
export interface RequestFundsViaLinkResultDto {
    /**
     * 
     * @type {string}
     * @memberof RequestFundsViaLinkResultDto
     */
    requestFundLink: string;
}
/**
 * 
 * @export
 * @interface RequestUserFund
 */
export interface RequestUserFund {
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestUserFund
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    originalUserId?: string;
    /**
     * 
     * @type {User}
     * @memberof RequestUserFund
     */
    originalUser?: User;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    userId?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestUserFund
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    currencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof RequestUserFund
     */
    currency?: Currency;
    /**
     * 
     * @type {RequestFundStatusValues}
     * @memberof RequestUserFund
     */
    status?: RequestFundStatusValues;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequestUserFund
     */
    transactionId?: string | null;
    /**
     * 
     * @type {Transaction}
     * @memberof RequestUserFund
     */
    transaction?: Transaction;
}
/**
 * 
 * @export
 * @interface ResendEmailRequest
 */
export interface ResendEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof ResendEmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface ResendSMSRequest
 */
export interface ResendSMSRequest {
    /**
     * 
     * @type {string}
     * @memberof ResendSMSRequest
     */
    mobileNumber: string;
}
/**
 * 
 * @export
 * @interface ReservePersoRequest
 */
export interface ReservePersoRequest {
    /**
     * 
     * @type {string}
     * @memberof ReservePersoRequest
     */
    serial?: string | null;
}
/**
 * 
 * @export
 * @interface ReservePersoResultDto
 */
export interface ReservePersoResultDto {
    /**
     * 
     * @type {string}
     * @memberof ReservePersoResultDto
     */
    persoFile: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ReturnCodes {
    Success = 0,
    Invalid_Api_Key = 100,
    Invalid_App = 101,
    Request_Invalid = 102,
    Number_Of_Records_Exceed_Limit = 103,
    File_Key_Required = 104,
    File_Not_Found = 105,
    Invalid_Session = 1000,
    Invalid_MobileNumber = 1001,
    Invalid_OTP = 1002,
    MobileNumber_Exists = 1003,
    Wait_To_Verify = 1004,
    Wrong_Flow = 1005,
    Invalid_PIN = 1006,
    Invalid_Email = 1007,
    EmailId_exists = 1008,
    Invalid_PublicKey = 1009,
    No_Biometric_Key_Set = 1010,
    Invalid_Biometric_Authentication = 1011,
    Invalid_Country = 1012,
    Invalid_User = 1013,
    TooMany_OTP_SMS_Sent = 1014,
    Cannot_Find_AnyUsers = 1015,
    Cannot_Search_Myself_As_Contact = 1016,
    User_Already_Contact = 1017,
    Contact_Not_Exist = 1018,
    User_Cannot_Search_For_Yourself = 1019,
    This_Not_Tipsee_User = 1020,
    Missing_MobileNumber = 1021,
    MobileNumber_Already_Exists = 1022,
    Email_Unverified = 1023,
    User_Not_Exist = 1024,
    Device_UUID_Or_TokenCode_Already_Exists = 1025,
    CanNot_SendMoney_To_User_NotBelong_Contacts = 1026,
    User_NotBelong_UserContacts = 1027,
    MobileNumber_NotVerified = 1028,
    User_NotSet_PIN_Yet = 1029,
    User_Try_To_Change_But_NotLoggedOn = 1030,
    User_NotVerified_Sms_Yet = 1031,
    Email_Already_Exists = 1032,
    Image_Not_Found = 1033,
    User_Not_Exist_To_Send_Message = 1034,
    Pin_Required = 1035,
    Public_Key_Required = 1036,
    UUID_Device_Required = 1037,
    Token_Device_Required = 1038,
    FirstName_Required = 1039,
    LastName_Required = 1040,
    Country_Required = 1041,
    Login_Required = 1042,
    Password_Required = 1043,
    MobileNumber_Required = 1044,
    City_Required = 1045,
    PostCode_Required = 1046,
    Email_Required = 1047,
    Address_Required = 1048,
    Otp_Required = 1049,
    Message_Required = 1050,
    Kyc_FrontSide_Image_Required = 1051,
    Kyc_FrontSide_Image_Type_Invalid = 1052,
    Kyc_FrontSide_Image_Size_Exceeds_Limit = 1053,
    Kyc_BackSide_Image_Required = 1054,
    Kyc_BackSide_Image_Type_Invalid = 1055,
    Kyc_BackSide_Image_Size_Exceeds_Limit = 1056,
    Kyc_Front_Face_Image_Required = 1057,
    Kyc_Front_Face_Image_Type_Invalid = 1058,
    Kyc_Front_Face_Image_Size_Exceeds_Limit = 1059,
    Kyc_Not_Found = 1060,
    Kyc_Level_Invalid = 1061,
    Kyc_Level_Already_Approved = 1062,
    Kyc_ProofOfAddress_Image_Required = 1063,
    Kyc_ProofOfAddress_Image_Type_Invalid = 1064,
    Kyc_ProofOfAddress_Image_Size_Exceeds_Limit = 1065,
    Kyc_ProofOfIncome_Image_Required = 1066,
    Kyc_ProofOfIncome_Image_Type_Invalid = 1067,
    Kyc_ProofOfIncome_Image_Size_Exceeds_Limit = 1068,
    Kyc_Verify_Not_Allowed = 1069,
    Kyc_Document_Type_Invalid = 1070,
    User_Profile_Image_Size_Exceeds_Limit = 1071,
    Country_Phone_Code_Invalid = 1072,
    User_Blocked = 1100,
    User_Unverified = 1101,
    User_Inactive = 1102,
    Permission_Denied = 1200,
    User_Not_Logged_On = 1300,
    User_NotBelong_Application = 1301,
    Invalid_Login_Combination = 1350,
    Missing_Fields = 1500,
    Insufficient_Permissions = 1501,
    Application_Invalid = 1502,
    NoCurrency_Provided_For_PaymentMethod = 2000,
    PaymentMethod_Cannot_Exchanged = 2001,
    PaymentMethod_Cannot_SentToBank_In_ThisRegion = 2002,
    RequestCurrency_NotMatch_PaymentMethod_Currency = 2003,
    Currency_NotSupported_Prepaid = 2004,
    PaymentMethod_NotSupport_Balance = 2005,
    Exchange_Between_Prepaids_Failed = 2006,
    Insufficient_Funds = 2007,
    Cannot_Find_Currency_Pair = 2008,
    Amount_Cannot_Equal_Zero = 2009,
    Cannot_Send_Funds_Same_Account = 2010,
    Cannot_Buy_Fractional_Ativos = 2011,
    From_PaymentMethod_Currency_And_Request_Currency_Must_Same = 2012,
    Card_Transaction_Declined = 2013,
    Invalid_PAN_Provided = 2014,
    Invalid_CVV_Code_Provided = 2015,
    Card_Already_Expired = 2016,
    Bank_Transaction_Declined = 2017,
    Access_Denied = 2018,
    Cannot_Exchanging_Same_Currency = 2019,
    Cannot_Exchange_Crypto = 2020,
    Cannot_Exchange_Less_Minimal_Amount_Limit = 2021,
    Cannot_Transfer_Less_Minimal_Amount_Limit = 2022,
    Bank_Account_Number_Invalid = 2023,
    Bank_Account_Name_Required = 2024,
    Name_On_Card_Required = 2025,
    PaymentMethod_CanNot_Send = 2026,
    Month_Invalid = 2027,
    Year_Invalid = 2028,
    Time_Range_Invalid = 2029,
    Year_Filter_Required = 2030,
    Month_Filter_Required = 2031,
    Quarter_Filter_Required = 2032,
    Date_Filter_Required = 2033,
    Base_Currency_Not_Configurated_Yet = 2034,
    Currency_Name_Required = 2035,
    Currency_Symbol_Required = 2036,
    Currency_Precision_Invalid = 2037,
    Currency_Format_Required = 2038,
    Currency_Name_Already_Exists = 2039,
    Currency_Name_Invalid = 2040,
    Currency_Not_Found = 2041,
    Crypto_Address_Required = 2042,
    Can_Not_Request_Fund_To_Himself = 2043,
    Region_Name_Required = 2044,
    Region_IsoName_Required = 2045,
    Region_Not_Found = 2046,
    Region_IsoName_Invalid = 2047,
    Region_IsoName_Already_Exists = 2048,
    Region_Name_Already_Exists = 2049,
    PaymentMethod_Name_Required = 2050,
    PaymentMethod_MinimalTransferOutAmount_Invalid = 2051,
    PaymentMethod_MinimalExchangeAmount_Invalid = 2052,
    PaymentMethod_SubCurrency_Value_Invalid = 2053,
    PaymentMethod_Not_Support_This_Currency = 2054,
    Regions_Not_Found = 2055,
    PaymentMethod_Name_Alreayd_Exists = 2056,
    PaymentMethod_With_This_Currency_Already_Exists = 2057,
    Exchange_Payment_Type_Pair_Invalid = 2058,
    FeeDefinition_Amount_Invalid = 2059,
    PaymentMethod_Type_Invalid = 2060,
    Transaction_Type_Invalid = 2061,
    Payment_Type_Invalid = 2062,
    FeeDefinition_Not_Found = 2063,
    FeeDefinition_Already_Exists = 2064,
    FeeDefinitionValue_Description_Required = 2065,
    FeeDefinitionValue_Amount_Invalid = 2066,
    FeeDefinitionValue_Type_Invalid = 2067,
    FeeDefinitionValue_Unit_Invalid = 2068,
    FeeDefinitionValue_PaidBy_Invalid = 2069,
    FeeDefinitionValue_Not_Found = 2070,
    FeeDefinitionValueCountry_Not_Found = 2071,
    FeeDefinitionValueCountry_Country_Pair_Already_Exists = 2072,
    FeeDefinitionValue_Currency_Not_Found = 2073,
    Exchange_Rate_Expiry = 2074,
    Exchange_Rate_Not_Belong_Currency_Pair = 2075,
    Rate_Id_Invalid = 2076,
    PaymentMethod_Not_Exist = 2100,
    Cannot_Receive_Payments_To_PaymenMethod = 2200,
    No_Crypto_Access = 2500,
    Selected_PaymentMethod_Not_Available_With_Request_Currency = 2501,
    Invalid_PaymentMethod_Color = 2502,
    Name_Already_Exists = 2503,
    NoPegging_Currency_For_Ativos = 2504,
    Cannot_Create_Wallet_With_SpecialName = 2505,
    Cannot_Create_PaymentMethod_With_SpecialName = 2506,
    Currency_Required = 2507,
    Currency_Not_Supported = 2508,
    Description_Required = 2509,
    Amount_Cannot_Less_Than_Or_Equal_Zero = 2510,
    RequestUserFund_Not_Exists = 2511,
    UserFundRequest_Already_Declined = 2512,
    UserFundRequest_Already_Paid = 2513,
    RequestUserFund_Not_Belong_User = 2514,
    UserContact_Belong_Region_Not_Supported_Payment = 2515,
    RequestFund_Via_Link_Not_Found = 2516,
    Current_user_cannot_send_money_to_himself = 2517,
    Wallet_Not_Exists = 2518,
    Sticker_Transaction_Package_Invalid = 2519,
    Sticker_Not_Activated_Yet = 2520,
    Verify_Sticker_Transaction_Message_Fail = 2521,
    Sticker_Serial_Not_Exists = 2522,
    Sticker_Serial_Invalid = 2523,
    Sticker_Serial_Length_Invalid = 2524,
    Sticker_Serial_Already_Activated = 2525,
    Sticker_Serial_NotBelong_User = 2526,
    Sticker_Serial_Not_Found = 2527,
    Verified_Sig_Invalid = 2528,
    Verify_Sig_Error = 2529,
    Invalid_Sig = 2530,
    Sticker_Crypt_File_Not_Exists = 2531,
    Invalid_Venue = 2602,
    Inactive_Venue = 2603,
    Venue_Already_In_List = 2604,
    Venue_Not_On_List = 2605,
    Not_Currently_Working_In_Venue = 2606,
    Not_In_Venue_Of_Tipee = 2607,
    Not_Close_Enough_To_Roaming_Tipee = 2608,
    Don_Not_have_bank_account = 2609,
    Work_Hours_Invalid = 2610,
    Work_Minutes_Invalid = 2611,
    Cannot_Find_Device = 2700,
    SystemSettings_Not_Found = 2701,
    External_Service_ClassId_Invalid = 2702,
    External_Service_Url_Required = 2703,
    External_Service_Url_Format_Invalid = 2704,
    External_Service_Type_Invalid = 2705,
    External_Service_Setting_Not_Found = 2706,
    External_Service_Notification_Config_Required = 2707,
    External_Service_Notification_Config_Invalid = 2708,
    External_Service_Sms_Notification_Provider_Invalid = 2709,
    External_Service_Email_Notification_Provider_Invalid = 2710,
    External_Service_PushNotification_Provider_Invalid = 2711,
    PhysicalWallet_Digits_Number_Config_Invalid = 3000,
    Perso_Generate_Number_Invalid = 3001,
    Do_Not_Have_PhysicalWallet_Perso = 3002,
    PhysicalWallet_Not_Exists = 3003,
    Issuer_PhysicalWalletId_Invalid = 3004,
    PhysicalWallet_Function_Number_Invalid = 3005,
    PhysicalWallet_PreAuth_Duration_Invalid = 3006,
    PhysicalWallet_PreAuth_MaximumAmount_Invalid = 3007,
    PhysicalWallet_Funding_PaymentMethod_Not_Exists = 3008,
    PhysicalWallet_Funding_PaymentMethod_Not_Belong_Current_User = 3009,
    PhysicalWallet_Pre_Auth_Not_Exists = 3010,
    PhysicalWallet_NotBelong_Current_User = 3011,
    PhysicalWallet_Can_Not_Be_Used = 3012,
    Wallet_Type_Name_Required = 3013,
    Wallet_Type_Name_Already_Exists = 3014,
    Wallet_Type_Not_Found = 3015,
    Physical_Wallet_Tier_Name_Required = 3016,
    Physical_Wallet_Tier_Name_Already_Exists = 3017,
    Physical_Wallet_Tier_Not_Found = 3018,
    Physical_Wallet_Plan_Name_Required = 3019,
    Physical_Wallet_Plan_Name_Already_Exists = 3020,
    Physical_Wallet_Plan_Price_Invalid = 3021,
    Physical_Wallet_Plan_Not_Found = 3022,
    Physical_Wallet_Type_Name_Required = 3023,
    Physical_Wallet_Type_Name_Already_Exists = 3024,
    Physical_Wallet_Type_Not_Found = 3025,
    Physical_Wallet_Type_And_Plan_Not_Same_Tier = 3026,
    Physical_Wallet_Type_Image_Invalid = 3027,
    Physical_Wallet_Already_Actived = 3028,
    Physical_Wallet_Otp_Invalid = 3029,
    Physical_Wallet_Validate_Otp_Fail = 3030,
    Physical_Wallet_Perso_KeyPackage_Error = 3031,
    Physical_Wallet_Button_Not_Exists = 3032,
    Physical_Wallet_Locked = 3033,
    Physical_Wallet_Pin_Invalid = 3034,
    Physical_Wallet_Drift_Can_Not_Found = 3035,
    Physical_Wallet_Can_Not_Access_This_Endpoint = 3036,
    Physical_Wallet_Can_Not_Used_For_Dynamic_Pin = 3037,
    Physical_Wallet_Can_Not_Used_For_Dynamic_Pan = 3038,
    Physical_Wallet_Can_Not_Used_For_Dynamic_Cvc = 3039,
    Physical_Wallet_Can_Not_Used_For_Dynamic_Expire = 3040,
    Physical_Wallet_Funding_PaymentMethod_Account_Number_Invalid = 3041,
    Physical_Wallet_Validate_Dynamic_Expiry_Fail = 3042,
    Card_Reference_Not_Belong_Physical_Wallet = 3043,
    Physical_Wallet_Type_Cost_Invalid = 3044,
    Physical_Wallet_Scheme_Invalid = 3045,
    Physical_Wallet_Issuer_Invalid = 3046,
    Physical_Wallet_Tier_Ordering_Invalid = 3047,
    Physical_Wallet_Plan_Period_Invalid = 3048,
    PhysicalWalletType_Image_Type_Invalid = 3049,
    PhysicalWalletType_Image_Size_Exceeds_Limit = 3050,
    PhysicalWallet_PreAuth_Not_Configured = 3051,
    PhysicalWallet_PreAuth_Expired = 3052,
    PhysicalWallet_PreAuth_Maximum_Amount_Too_Low = 3053,
    Transaction_Not_Found = 4000,
    Unknown_Error = 7000,
    Call_Api_Error = 7001,
    InternalServerError = 7002,
    Endpoint_Access_Denied = 7003
}

/**
 * 
 * @export
 * @interface ReturnCodesDto
 */
export interface ReturnCodesDto {
    /**
     * 
     * @type {number}
     * @memberof ReturnCodesDto
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnCodesDto
     */
    keyMessage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnCodesDto
     */
    message?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum RoleValues {
    User = 'User',
    Admin = 'Admin',
    FloatMoneyHolder = 'FloatMoneyHolder',
    Partner = 'Partner'
}

/**
 * 
 * @export
 * @interface SaveUserRequest
 */
export interface SaveUserRequest {
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    lastName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    street?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SaveUserRequest
     */
    nickName?: string | null;
}
/**
 * 
 * @export
 * @interface SaveUserResultDto
 */
export interface SaveUserResultDto {
    /**
     * 
     * @type {string}
     * @memberof SaveUserResultDto
     */
    userId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SecurityTypeValues {
    None = 'None',
    Sticker = 'Sticker'
}

/**
 * 
 * @export
 * @interface SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof SendMessageRequest
     */
    toUserId: string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRequest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface SendTipRequest
 */
export interface SendTipRequest {
    /**
     * 
     * @type {string}
     * @memberof SendTipRequest
     */
    fromPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof SendTipRequest
     */
    receiverId: string;
    /**
     * 
     * @type {number}
     * @memberof SendTipRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SendTipRequest
     */
    rateId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendTipRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof SendTipRequest
     */
    stickerPacket?: StickerTransactionPacket;
}
/**
 * 
 * @export
 * @interface SendToBankRequest
 */
export interface SendToBankRequest {
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    fromPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof SendToBankRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    accountName: string;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    swiftbsb?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    country?: string | null;
    /**
     * 
     * @type {BankPaymentTypeValues}
     * @memberof SendToBankRequest
     */
    paymentType?: BankPaymentTypeValues;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof SendToBankRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToBankRequest
     */
    rateId?: string | null;
}
/**
 * 
 * @export
 * @interface SendToCryptoRequest
 */
export interface SendToCryptoRequest {
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    fromPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof SendToCryptoRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    address: string;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof SendToCryptoRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToCryptoRequest
     */
    rateId?: string | null;
}
/**
 * 
 * @export
 * @interface SendToUserRequest
 */
export interface SendToUserRequest {
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    fromPaymentMethodId: string;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    currencyId: string;
    /**
     * 
     * @type {number}
     * @memberof SendToUserRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    walletName?: string | null;
    /**
     * 
     * @type {StickerTransactionPacket}
     * @memberof SendToUserRequest
     */
    stickerPacket?: StickerTransactionPacket;
    /**
     * 
     * @type {boolean}
     * @memberof SendToUserRequest
     */
    isEnableSendNotification?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    transactionRequestId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    otp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SendToUserRequest
     */
    rateId?: string | null;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {StatusValues}
     * @memberof Session
     */
    status?: StatusValues;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    token?: string;
    /**
     * 
     * @type {RoleValues}
     * @memberof Session
     */
    role?: RoleValues;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    applicationInstanceId?: string;
    /**
     * 
     * @type {ApplicationInstance}
     * @memberof Session
     */
    application?: ApplicationInstance;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    fakeSMS?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    fakeEmail?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    pin?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    lastSent?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    verifiedSMS?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    email?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    verifiedEmailCode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    userId?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    loggedOn?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    serverPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    serverPrivateKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    clientPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    biopublickey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    loginPin?: string | null;
}
/**
 * 
 * @export
 * @interface SetAuthRequest
 */
export interface SetAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof SetAuthRequest
     */
    pin: string;
    /**
     * 
     * @type {string}
     * @memberof SetAuthRequest
     */
    publicKey: string;
}
/**
 * 
 * @export
 * @interface SetAuthResultDto
 */
export interface SetAuthResultDto {
    /**
     * 
     * @type {string}
     * @memberof SetAuthResultDto
     */
    publicKey: string;
}
/**
 * 
 * @export
 * @interface SetBalanceRequest
 */
export interface SetBalanceRequest {
    /**
     * 
     * @type {string}
     * @memberof SetBalanceRequest
     */
    paymentMethodInstanceId: string;
    /**
     * 
     * @type {number}
     * @memberof SetBalanceRequest
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface SetBiometricsRequest
 */
export interface SetBiometricsRequest {
    /**
     * 
     * @type {string}
     * @memberof SetBiometricsRequest
     */
    publicKey: string;
}
/**
 * 
 * @export
 * @interface SetLocationRequest
 */
export interface SetLocationRequest {
    /**
     * 
     * @type {number}
     * @memberof SetLocationRequest
     */
    latitude: number;
    /**
     * 
     * @type {number}
     * @memberof SetLocationRequest
     */
    longitude: number;
}
/**
 * 
 * @export
 * @interface SetMainBankAccountRequest
 */
export interface SetMainBankAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    currencyId: string;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    accountName: string;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    swiftbsb?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    wallet?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    color?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetMainBankAccountRequest
     */
    alias?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SetMainBankAccountRequest
     */
    dayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof SetMainBankAccountRequest
     */
    monthLimit?: number;
}
/**
 * 
 * @export
 * @interface SetPINRequest
 */
export interface SetPINRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPINRequest
     */
    pin: string;
    /**
     * 
     * @type {string}
     * @memberof SetPINRequest
     */
    biometricsPublicKey?: string | null;
}
/**
 * 
 * @export
 * @interface SetPaymentMethodInstanceSettingResultDto
 */
export interface SetPaymentMethodInstanceSettingResultDto {
    /**
     * 
     * @type {string}
     * @memberof SetPaymentMethodInstanceSettingResultDto
     */
    paymentMethodInstanceSettingId?: string;
}
/**
 * 
 * @export
 * @interface SetPhysicalWalletPaymentMethodRequest
 */
export interface SetPhysicalWalletPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPhysicalWalletPaymentMethodRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {number}
     * @memberof SetPhysicalWalletPaymentMethodRequest
     */
    functionNumber: number;
    /**
     * 
     * @type {string}
     * @memberof SetPhysicalWalletPaymentMethodRequest
     */
    paymentMethodInstanceId: string;
}
/**
 * 
 * @export
 * @interface SetPhysicalWalletPaymentMethodResultDto
 */
export interface SetPhysicalWalletPaymentMethodResultDto {
    /**
     * 
     * @type {string}
     * @memberof SetPhysicalWalletPaymentMethodResultDto
     */
    activationCode: string;
    /**
     * 
     * @type {string}
     * @memberof SetPhysicalWalletPaymentMethodResultDto
     */
    accountNumberCode: string;
}
/**
 * 
 * @export
 * @interface SetPhysicalWalletStatusRequest
 */
export interface SetPhysicalWalletStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPhysicalWalletStatusRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {PhysicalWalletStatus}
     * @memberof SetPhysicalWalletStatusRequest
     */
    status: PhysicalWalletStatus;
}
/**
 * 
 * @export
 * @interface SetPolicyRequest
 */
export interface SetPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPolicyRequest
     */
    venueId: string;
    /**
     * 
     * @type {boolean}
     * @memberof SetPolicyRequest
     */
    policyActive: boolean;
    /**
     * 
     * @type {number}
     * @memberof SetPolicyRequest
     */
    minPercentage: number;
    /**
     * 
     * @type {number}
     * @memberof SetPolicyRequest
     */
    evenPercentage: number;
}
/**
 * 
 * @export
 * @interface SetPreferenceRequest
 */
export interface SetPreferenceRequest {
    /**
     * 
     * @type {number}
     * @memberof SetPreferenceRequest
     */
    spendPerDayLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof SetPreferenceRequest
     */
    spendPerMonthLimit?: number;
}
/**
 * 
 * @export
 * @interface SetSessionExpireRequest
 */
export interface SetSessionExpireRequest {
    /**
     * 
     * @type {string}
     * @memberof SetSessionExpireRequest
     */
    sessionToken?: string;
}
/**
 * 
 * @export
 * @interface SetUserInfoRequest
 */
export interface SetUserInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    street?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    postCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    regionId: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    nickName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetUserInfoRequest
     */
    appRole?: string | null;
}
/**
 * 
 * @export
 * @interface SetUserStatusRequest
 */
export interface SetUserStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof SetUserStatusRequest
     */
    venueId: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserStatusRequest
     */
    userId: string;
    /**
     * 
     * @type {boolean}
     * @memberof SetUserStatusRequest
     */
    active: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SetUserStatusRequest
     */
    validated: boolean;
}
/**
 * 
 * @export
 * @interface SetupPhysicalWalletRequest
 */
export interface SetupPhysicalWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof SetupPhysicalWalletRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof SetupPhysicalWalletRequest
     */
    physicalWalletReference: string;
    /**
     * 
     * @type {string}
     * @memberof SetupPhysicalWalletRequest
     */
    numberOfServerSyncing: string;
}
/**
 * 
 * @export
 * @interface SetupPhysicalWalletResultDto
 */
export interface SetupPhysicalWalletResultDto {
    /**
     * 
     * @type {string}
     * @memberof SetupPhysicalWalletResultDto
     */
    otp: string;
}
/**
 * 
 * @export
 * @interface SignedRequest
 */
export interface SignedRequest {
    /**
     * 
     * @type {string}
     * @memberof SignedRequest
     */
    serial: string;
    /**
     * 
     * @type {string}
     * @memberof SignedRequest
     */
    sig: string;
}
/**
 * 
 * @export
 * @interface StartWorkingRequest
 */
export interface StartWorkingRequest {
    /**
     * 
     * @type {number}
     * @memberof StartWorkingRequest
     */
    workHours: number;
    /**
     * 
     * @type {number}
     * @memberof StartWorkingRequest
     */
    workMinutes: number;
    /**
     * 
     * @type {string}
     * @memberof StartWorkingRequest
     */
    venueId?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StatusValues {
    Active = 'Active',
    InActive = 'InActive'
}

/**
 * 
 * @export
 * @interface StickerPerso
 */
export interface StickerPerso {
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StickerPerso
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    serial?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    persoFile?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof StickerPerso
     */
    hasBeenUsed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StickerPerso
     */
    hasBeenActivated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    publicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    p?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    signedP?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    macAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPerso
     */
    signature?: string | null;
}
/**
 * 
 * @export
 * @interface StickerPersoDto
 */
export interface StickerPersoDto {
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    serial: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    persoFile: string;
    /**
     * 
     * @type {boolean}
     * @memberof StickerPersoDto
     */
    hasBeenUsed: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StickerPersoDto
     */
    hasBeenActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    publicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    p?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    signedP?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    macAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerPersoDto
     */
    signature?: string | null;
}
/**
 * 
 * @export
 * @interface StickerTransactionPacket
 */
export interface StickerTransactionPacket {
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    transactionGUID?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StickerTransactionPacket
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    accountId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    senderId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    receiverId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StickerTransactionPacket
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof StickerTransactionPacket
     */
    message?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof StickerTransactionPacket
     */
    sigs?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface Stream
 */
export interface Stream {
    /**
     * 
     * @type {boolean}
     * @memberof Stream
     */
    canRead?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Stream
     */
    canSeek?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Stream
     */
    canTimeout?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Stream
     */
    canWrite?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    position?: number;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    readTimeout?: number;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    writeTimeout?: number;
}
/**
 * 
 * @export
 * @interface SuccessActivateDto
 */
export interface SuccessActivateDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessActivateDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessActivateDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessActivateDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessActivateDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetStickerActivateResultDto}
     * @memberof SuccessActivateDto
     */
    result?: GetStickerActivateResultDto;
}
/**
 * 
 * @export
 * @interface SuccessAddBankAccountDto
 */
export interface SuccessAddBankAccountDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddBankAccountDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddBankAccountDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddBankAccountDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddBankAccountDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessAddBankAccountDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessAddCardDto
 */
export interface SuccessAddCardDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCardDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddCardDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCardDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCardDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessAddCardDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessAddContactDto
 */
export interface SuccessAddContactDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddContactDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddContactDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddContactDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddContactDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetContactDto}
     * @memberof SuccessAddContactDto
     */
    result?: GetContactDto;
}
/**
 * 
 * @export
 * @interface SuccessAddCustodianCryptoDto
 */
export interface SuccessAddCustodianCryptoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCustodianCryptoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddCustodianCryptoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCustodianCryptoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddCustodianCryptoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessAddCustodianCryptoDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessAddDeviceDto
 */
export interface SuccessAddDeviceDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddDeviceDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddDeviceDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddDeviceDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddDeviceDto
     */
    resultCount?: number;
    /**
     * 
     * @type {AddDeviceResultDto}
     * @memberof SuccessAddDeviceDto
     */
    result?: AddDeviceResultDto;
}
/**
 * 
 * @export
 * @interface SuccessAddMerchantDto
 */
export interface SuccessAddMerchantDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddMerchantDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddMerchantDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddMerchantDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddMerchantDto
     */
    resultCount?: number;
    /**
     * 
     * @type {AddMerchantResultDto}
     * @memberof SuccessAddMerchantDto
     */
    result?: AddMerchantResultDto;
}
/**
 * 
 * @export
 * @interface SuccessAddPrepaidAccountDto
 */
export interface SuccessAddPrepaidAccountDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddPrepaidAccountDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddPrepaidAccountDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddPrepaidAccountDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddPrepaidAccountDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessAddPrepaidAccountDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessAddVenueDto
 */
export interface SuccessAddVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAddVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAddVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAddVenueDto
     */
    resultCount?: number;
    /**
     * 
     * @type {AddVenueResultDto}
     * @memberof SuccessAddVenueDto
     */
    result?: AddVenueResultDto;
}
/**
 * 
 * @export
 * @interface SuccessAdminDeleteUserDto
 */
export interface SuccessAdminDeleteUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessAdminDeleteUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessAdminDeleteUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessAdminDeleteUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessAdminDeleteUserDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessCanLoginDto
 */
export interface SuccessCanLoginDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessCanLoginDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCanLoginDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCanLoginDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCanLoginDto
     */
    resultCount?: number;
    /**
     * 
     * @type {CanLoginResultDto}
     * @memberof SuccessCanLoginDto
     */
    result?: CanLoginResultDto;
}
/**
 * 
 * @export
 * @interface SuccessChargeCardDto
 */
export interface SuccessChargeCardDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessChargeCardDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessChargeCardDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessChargeCardDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessChargeCardDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessChargeCardDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessClaimPendingTipsDto
 */
export interface SuccessClaimPendingTipsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessClaimPendingTipsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessClaimPendingTipsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessClaimPendingTipsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessClaimPendingTipsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessClaimPendingTipsDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessConfigPhysicalWalletPreAuthResponse
 */
export interface SuccessConfigPhysicalWalletPreAuthResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessConfigPhysicalWalletPreAuthResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessConfigPhysicalWalletPreAuthResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessConfigPhysicalWalletPreAuthResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessConfigPhysicalWalletPreAuthResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {ConfigurePreAuthResultDto}
     * @memberof SuccessConfigPhysicalWalletPreAuthResponse
     */
    result?: ConfigurePreAuthResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreateCurrencyResultDtoResponse
 */
export interface SuccessCreateCurrencyResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateCurrencyResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreateCurrencyResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateCurrencyResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateCurrencyResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateCurrencyResultDto}
     * @memberof SuccessCreateCurrencyResultDtoResponse
     */
    result?: CreateCurrencyResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreateFeeDefinitionResultDtoResponse
 */
export interface SuccessCreateFeeDefinitionResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateFeeDefinitionResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreateFeeDefinitionResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateFeeDefinitionResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateFeeDefinitionResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateFeeDefinitionResultDto}
     * @memberof SuccessCreateFeeDefinitionResultDtoResponse
     */
    result?: CreateFeeDefinitionResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreatePaymentMethodResultDtoResponse
 */
export interface SuccessCreatePaymentMethodResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePaymentMethodResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreatePaymentMethodResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePaymentMethodResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePaymentMethodResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreatePaymentMethodResultDto}
     * @memberof SuccessCreatePaymentMethodResultDtoResponse
     */
    result?: CreatePaymentMethodResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreatePhysicalWalletPlanResultDtoResponse
 */
export interface SuccessCreatePhysicalWalletPlanResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletPlanResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreatePhysicalWalletPlanResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletPlanResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletPlanResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreatePhysicalWalletPlanResultDto}
     * @memberof SuccessCreatePhysicalWalletPlanResultDtoResponse
     */
    result?: CreatePhysicalWalletPlanResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreatePhysicalWalletResponse
 */
export interface SuccessCreatePhysicalWalletResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreatePhysicalWalletResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreatePhysicalWalletResultDto}
     * @memberof SuccessCreatePhysicalWalletResponse
     */
    result?: CreatePhysicalWalletResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreatePhysicalWalletTierResultDtoResponse
 */
export interface SuccessCreatePhysicalWalletTierResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTierResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreatePhysicalWalletTierResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTierResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTierResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreatePhysicalWalletTierResultDto}
     * @memberof SuccessCreatePhysicalWalletTierResultDtoResponse
     */
    result?: CreatePhysicalWalletTierResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreatePhysicalWalletTypeResultDtoResponse
 */
export interface SuccessCreatePhysicalWalletTypeResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTypeResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreatePhysicalWalletTypeResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTypeResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreatePhysicalWalletTypeResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreatePhysicalWalletTypeResultDto}
     * @memberof SuccessCreatePhysicalWalletTypeResultDtoResponse
     */
    result?: CreatePhysicalWalletTypeResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreateRegionResultDtoResponse
 */
export interface SuccessCreateRegionResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateRegionResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreateRegionResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateRegionResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateRegionResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateRegionResultDto}
     * @memberof SuccessCreateRegionResultDtoResponse
     */
    result?: CreateRegionResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreateSessionDto
 */
export interface SuccessCreateSessionDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateSessionDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreateSessionDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateSessionDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateSessionDto
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateSessionResultDto}
     * @memberof SuccessCreateSessionDto
     */
    result?: CreateSessionResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCreateWalletTypeResultDtoResponse
 */
export interface SuccessCreateWalletTypeResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateWalletTypeResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCreateWalletTypeResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateWalletTypeResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCreateWalletTypeResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateWalletTypeResultDto}
     * @memberof SuccessCreateWalletTypeResultDtoResponse
     */
    result?: CreateWalletTypeResultDto;
}
/**
 * 
 * @export
 * @interface SuccessCurrencyDtoResponse
 */
export interface SuccessCurrencyDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCurrencyDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof SuccessCurrencyDtoResponse
     */
    result?: CurrencyDto;
}
/**
 * 
 * @export
 * @interface SuccessCurrencyTypeValuesDto
 */
export interface SuccessCurrencyTypeValuesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyTypeValuesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessCurrencyTypeValuesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyTypeValuesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessCurrencyTypeValuesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SuccessCurrencyTypeValuesDto
     */
    result?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SuccessDeclineUserFundRequestDto
 */
export interface SuccessDeclineUserFundRequestDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeclineUserFundRequestDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeclineUserFundRequestDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeclineUserFundRequestDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeclineUserFundRequestDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessDeepKycDtoResponse
 */
export interface SuccessDeepKycDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepKycDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeepKycDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepKycDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepKycDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {DeepKycDto}
     * @memberof SuccessDeepKycDtoResponse
     */
    result?: DeepKycDto;
}
/**
 * 
 * @export
 * @interface SuccessDeepPaymentMethodDtoResponse
 */
export interface SuccessDeepPaymentMethodDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPaymentMethodDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeepPaymentMethodDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPaymentMethodDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPaymentMethodDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {DeepPaymentMethodDto}
     * @memberof SuccessDeepPaymentMethodDtoResponse
     */
    result?: DeepPaymentMethodDto;
}
/**
 * 
 * @export
 * @interface SuccessDeepPhysicalWalletPlanDtoResponse
 */
export interface SuccessDeepPhysicalWalletPlanDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletPlanDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeepPhysicalWalletPlanDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletPlanDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletPlanDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {DeepPhysicalWalletPlanDto}
     * @memberof SuccessDeepPhysicalWalletPlanDtoResponse
     */
    result?: DeepPhysicalWalletPlanDto;
}
/**
 * 
 * @export
 * @interface SuccessDeepPhysicalWalletTierDtoResponse
 */
export interface SuccessDeepPhysicalWalletTierDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTierDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeepPhysicalWalletTierDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTierDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTierDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {DeepPhysicalWalletTierDto}
     * @memberof SuccessDeepPhysicalWalletTierDtoResponse
     */
    result?: DeepPhysicalWalletTierDto;
}
/**
 * 
 * @export
 * @interface SuccessDeepPhysicalWalletTypeDtoResponse
 */
export interface SuccessDeepPhysicalWalletTypeDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTypeDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeepPhysicalWalletTypeDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTypeDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeepPhysicalWalletTypeDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {DeepPhysicalWalletTypeDto}
     * @memberof SuccessDeepPhysicalWalletTypeDtoResponse
     */
    result?: DeepPhysicalWalletTypeDto;
}
/**
 * 
 * @export
 * @interface SuccessDeleteMerchantDto
 */
export interface SuccessDeleteMerchantDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteMerchantDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeleteMerchantDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteMerchantDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteMerchantDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessDeletePaymentMethodDto
 */
export interface SuccessDeletePaymentMethodDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeletePaymentMethodDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeletePaymentMethodDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeletePaymentMethodDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeletePaymentMethodDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessDeleteUserDto
 */
export interface SuccessDeleteUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeleteUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteUserDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessDeleteVenueDto
 */
export interface SuccessDeleteVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeleteVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteVenueDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessDeleteWalletsDto
 */
export interface SuccessDeleteWalletsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteWalletsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessDeleteWalletsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteWalletsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessDeleteWalletsDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessEditContactDto
 */
export interface SuccessEditContactDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessEditContactDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessEditContactDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditContactDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditContactDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetContactDto}
     * @memberof SuccessEditContactDto
     */
    result?: GetContactDto;
}
/**
 * 
 * @export
 * @interface SuccessEditPaymentMethodDto
 */
export interface SuccessEditPaymentMethodDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessEditPaymentMethodDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessEditPaymentMethodDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditPaymentMethodDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditPaymentMethodDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessEditPaymentMethodDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessEditVenueDto
 */
export interface SuccessEditVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessEditVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessEditVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessEditVenueDto
     */
    resultCount?: number;
    /**
     * 
     * @type {VenueDto}
     * @memberof SuccessEditVenueDto
     */
    result?: VenueDto;
}
/**
 * 
 * @export
 * @interface SuccessExchangePaymentDto
 */
export interface SuccessExchangePaymentDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessExchangePaymentDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessExchangePaymentDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessExchangePaymentDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessExchangePaymentDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessExchangePaymentDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessExecutePaymentPhysicalWalletResponse
 */
export interface SuccessExecutePaymentPhysicalWalletResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessExecutePaymentPhysicalWalletResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessExecutePaymentPhysicalWalletResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessExecutePaymentPhysicalWalletResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessExecutePaymentPhysicalWalletResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessExecutePaymentPhysicalWalletResponse
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessFeeDefinitionDtoResponse
 */
export interface SuccessFeeDefinitionDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessFeeDefinitionDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessFeeDefinitionDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessFeeDefinitionDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessFeeDefinitionDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {FeeDefinitionDto}
     * @memberof SuccessFeeDefinitionDtoResponse
     */
    result?: FeeDefinitionDto;
}
/**
 * 
 * @export
 * @interface SuccessFetchDevicesDto
 */
export interface SuccessFetchDevicesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessFetchDevicesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessFetchDevicesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessFetchDevicesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessFetchDevicesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeviceDto>}
     * @memberof SuccessFetchDevicesDto
     */
    result?: Array<DeviceDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessFindUserByMobileEmailDto
 */
export interface SuccessFindUserByMobileEmailDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileEmailDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessFindUserByMobileEmailDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileEmailDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileEmailDto
     */
    resultCount?: number;
    /**
     * 
     * @type {FindUserByMobileEmailResultDto}
     * @memberof SuccessFindUserByMobileEmailDto
     */
    result?: FindUserByMobileEmailResultDto;
}
/**
 * 
 * @export
 * @interface SuccessFindUserByMobileNumberDto
 */
export interface SuccessFindUserByMobileNumberDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileNumberDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessFindUserByMobileNumberDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileNumberDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessFindUserByMobileNumberDto
     */
    resultCount?: number;
    /**
     * 
     * @type {FindUserByMobileNumberResultDto}
     * @memberof SuccessFindUserByMobileNumberDto
     */
    result?: FindUserByMobileNumberResultDto;
}
/**
 * 
 * @export
 * @interface SuccessForgotPinDto
 */
export interface SuccessForgotPinDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessForgotPinDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessForgotPinDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessForgotPinDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessForgotPinDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessGetActivatedStickerDto
 */
export interface SuccessGetActivatedStickerDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetActivatedStickerDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetActivatedStickerDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetActivatedStickerDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetActivatedStickerDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetActivatedStickerDto}
     * @memberof SuccessGetActivatedStickerDto
     */
    result?: GetActivatedStickerDto;
}
/**
 * 
 * @export
 * @interface SuccessGetAllIssuersResultDtoResponse
 */
export interface SuccessGetAllIssuersResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllIssuersResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetAllIssuersResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllIssuersResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllIssuersResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetAllIssuersResultDto}
     * @memberof SuccessGetAllIssuersResultDtoResponse
     */
    result?: GetAllIssuersResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetAllStickersDto
 */
export interface SuccessGetAllStickersDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllStickersDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetAllStickersDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllStickersDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllStickersDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetAllStickersDto>}
     * @memberof SuccessGetAllStickersDto
     */
    result?: Array<GetAllStickersDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetAllTransactionsDto
 */
export interface SuccessGetAllTransactionsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllTransactionsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetAllTransactionsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllTransactionsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAllTransactionsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetAllTransactionsDto>}
     * @memberof SuccessGetAllTransactionsDto
     */
    result?: Array<GetAllTransactionsDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetAvailableCryptoDto
 */
export interface SuccessGetAvailableCryptoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailableCryptoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetAvailableCryptoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailableCryptoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailableCryptoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<PaymentMethodDto>}
     * @memberof SuccessGetAvailableCryptoDto
     */
    result?: Array<PaymentMethodDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetAvailablePaymentMethodsDto
 */
export interface SuccessGetAvailablePaymentMethodsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailablePaymentMethodsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetAvailablePaymentMethodsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailablePaymentMethodsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetAvailablePaymentMethodsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<PaymentMethodDto>}
     * @memberof SuccessGetAvailablePaymentMethodsDto
     */
    result?: Array<PaymentMethodDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetBalanceDto
 */
export interface SuccessGetBalanceDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetBalanceDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetBalanceDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetBalanceDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetBalanceDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetBalanceDto}
     * @memberof SuccessGetBalanceDto
     */
    result?: GetBalanceDto;
}
/**
 * 
 * @export
 * @interface SuccessGetContactsDto
 */
export interface SuccessGetContactsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetContactsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetContactsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetContactsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetContactsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetContactDto>}
     * @memberof SuccessGetContactsDto
     */
    result?: Array<GetContactDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetConversionRatesDto
 */
export interface SuccessGetConversionRatesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetConversionRatesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetConversionRatesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetConversionRatesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetConversionRatesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof SuccessGetConversionRatesDto
     */
    result?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface SuccessGetDashboardDto
 */
export interface SuccessGetDashboardDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetDashboardDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetDashboardDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetDashboardDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetDashboardDto
     */
    resultCount?: number;
    /**
     * 
     * @type {DashboardInfoDto}
     * @memberof SuccessGetDashboardDto
     */
    result?: DashboardInfoDto;
}
/**
 * 
 * @export
 * @interface SuccessGetEmailOtpDto
 */
export interface SuccessGetEmailOtpDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetEmailOtpDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetEmailOtpDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetEmailOtpDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetEmailOtpDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetEmailOtpResultDto}
     * @memberof SuccessGetEmailOtpDto
     */
    result?: GetEmailOtpResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetExchangeRateDto
 */
export interface SuccessGetExchangeRateDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeRateDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetExchangeRateDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeRateDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeRateDto
     */
    resultCount?: number;
    /**
     * 
     * @type {ExchangeRateDto}
     * @memberof SuccessGetExchangeRateDto
     */
    result?: ExchangeRateDto;
}
/**
 * 
 * @export
 * @interface SuccessGetExchangeTransactionsAmountsDto
 */
export interface SuccessGetExchangeTransactionsAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeTransactionsAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetExchangeTransactionsAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeTransactionsAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetExchangeTransactionsAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTransactionsAmountsDto}
     * @memberof SuccessGetExchangeTransactionsAmountsDto
     */
    result?: GetTransactionsAmountsDto;
}
/**
 * 
 * @export
 * @interface SuccessGetFreeVenuesDto
 */
export interface SuccessGetFreeVenuesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetFreeVenuesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetFreeVenuesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetFreeVenuesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetFreeVenuesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<VenueDto>}
     * @memberof SuccessGetFreeVenuesDto
     */
    result?: Array<VenueDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetKeysDto
 */
export interface SuccessGetKeysDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetKeysDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetKeysDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetKeysDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetKeysDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetStickerKeysDto}
     * @memberof SuccessGetKeysDto
     */
    result?: GetStickerKeysDto;
}
/**
 * 
 * @export
 * @interface SuccessGetLockStatusDto
 */
export interface SuccessGetLockStatusDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetLockStatusDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetLockStatusDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetLockStatusDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetLockStatusDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetLockStatusDto}
     * @memberof SuccessGetLockStatusDto
     */
    result?: GetLockStatusDto;
}
/**
 * 
 * @export
 * @interface SuccessGetMerchantsDto
 */
export interface SuccessGetMerchantsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMerchantsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetMerchantsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMerchantsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMerchantsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetMerchantsDto>}
     * @memberof SuccessGetMerchantsDto
     */
    result?: Array<GetMerchantsDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetMessagesDto
 */
export interface SuccessGetMessagesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMessagesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetMessagesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMessagesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetMessagesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<UserChatDto>}
     * @memberof SuccessGetMessagesDto
     */
    result?: Array<UserChatDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetPaymentMethodDto
 */
export interface SuccessGetPaymentMethodDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPaymentMethodDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessGetPaymentMethodDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPaymentMethodInstanceSettingResponse
 */
export interface SuccessGetPaymentMethodInstanceSettingResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodInstanceSettingResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPaymentMethodInstanceSettingResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodInstanceSettingResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodInstanceSettingResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPaymentMethodInstanceSettingResultDto}
     * @memberof SuccessGetPaymentMethodInstanceSettingResponse
     */
    result?: GetPaymentMethodInstanceSettingResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPaymentMethodsDto
 */
export interface SuccessGetPaymentMethodsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPaymentMethodsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPaymentMethodsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<PaymentMethodInstanceDto>}
     * @memberof SuccessGetPaymentMethodsDto
     */
    result?: Array<PaymentMethodInstanceDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetPendingTipsDto
 */
export interface SuccessGetPendingTipsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPendingTipsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPendingTipsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPendingTipsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPendingTipsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPendingTipsDto}
     * @memberof SuccessGetPendingTipsDto
     */
    result?: GetPendingTipsDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPersoDto
 */
export interface SuccessGetPersoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPersoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPersoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPersoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPersoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {StickerPersoDto}
     * @memberof SuccessGetPersoDto
     */
    result?: StickerPersoDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletCvcResponse
 */
export interface SuccessGetPhysicalWalletCvcResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletCvcResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletCvcResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletCvcResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletCvcResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletCVCResultDto}
     * @memberof SuccessGetPhysicalWalletCvcResponse
     */
    result?: GetPhysicalWalletCVCResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletDynamicCvcResponse
 */
export interface SuccessGetPhysicalWalletDynamicCvcResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicCvcResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletDynamicCvcResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicCvcResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicCvcResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletDynamicCVCResultDto}
     * @memberof SuccessGetPhysicalWalletDynamicCvcResponse
     */
    result?: GetPhysicalWalletDynamicCVCResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletDynamicExpiryResponse
 */
export interface SuccessGetPhysicalWalletDynamicExpiryResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicExpiryResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletDynamicExpiryResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicExpiryResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicExpiryResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletDynamicExpiryResultDto}
     * @memberof SuccessGetPhysicalWalletDynamicExpiryResponse
     */
    result?: GetPhysicalWalletDynamicExpiryResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletDynamicPanResponse
 */
export interface SuccessGetPhysicalWalletDynamicPanResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPanResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletDynamicPanResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPanResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPanResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletDynamicPanResultDto}
     * @memberof SuccessGetPhysicalWalletDynamicPanResponse
     */
    result?: GetPhysicalWalletDynamicPanResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletDynamicPinResponse
 */
export interface SuccessGetPhysicalWalletDynamicPinResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPinResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletDynamicPinResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPinResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletDynamicPinResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletDynamicPinResultDto}
     * @memberof SuccessGetPhysicalWalletDynamicPinResponse
     */
    result?: GetPhysicalWalletDynamicPinResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletExpiryResponse
 */
export interface SuccessGetPhysicalWalletExpiryResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletExpiryResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletExpiryResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletExpiryResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletExpiryResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletExpiryResultDto}
     * @memberof SuccessGetPhysicalWalletExpiryResponse
     */
    result?: GetPhysicalWalletExpiryResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletPanResponse
 */
export interface SuccessGetPhysicalWalletPanResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPanResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletPanResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPanResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPanResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletPanResultDto}
     * @memberof SuccessGetPhysicalWalletPanResponse
     */
    result?: GetPhysicalWalletPanResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletPinResponse
 */
export interface SuccessGetPhysicalWalletPinResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPinResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletPinResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPinResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPinResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletPinResultDto}
     * @memberof SuccessGetPhysicalWalletPinResponse
     */
    result?: GetPhysicalWalletPinResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletPreAuthResponse
 */
export interface SuccessGetPhysicalWalletPreAuthResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPreAuthResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletPreAuthResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPreAuthResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletPreAuthResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPhysicalWalletPreAuthResultDto}
     * @memberof SuccessGetPhysicalWalletPreAuthResponse
     */
    result?: GetPhysicalWalletPreAuthResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetPhysicalWalletTiersResponse
 */
export interface SuccessGetPhysicalWalletTiersResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletTiersResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPhysicalWalletTiersResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletTiersResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPhysicalWalletTiersResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPhysicalWalletTierDto>}
     * @memberof SuccessGetPhysicalWalletTiersResponse
     */
    result?: Array<DeepPhysicalWalletTierDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetPolicyDto
 */
export interface SuccessGetPolicyDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPolicyDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetPolicyDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPolicyDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetPolicyDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetPolicyDto}
     * @memberof SuccessGetPolicyDto
     */
    result?: GetPolicyDto;
}
/**
 * 
 * @export
 * @interface SuccessGetProfileDto
 */
export interface SuccessGetProfileDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetProfileDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetProfileDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetProfileDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetProfileDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserProfileDto}
     * @memberof SuccessGetProfileDto
     */
    result?: UserProfileDto;
}
/**
 * 
 * @export
 * @interface SuccessGetReceiveTransactionsAmountsDto
 */
export interface SuccessGetReceiveTransactionsAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetReceiveTransactionsAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetReceiveTransactionsAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetReceiveTransactionsAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetReceiveTransactionsAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTransactionsAmountsDto}
     * @memberof SuccessGetReceiveTransactionsAmountsDto
     */
    result?: GetTransactionsAmountsDto;
}
/**
 * 
 * @export
 * @interface SuccessGetRequestFundByIdDto
 */
export interface SuccessGetRequestFundByIdDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundByIdDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRequestFundByIdDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundByIdDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundByIdDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetUserRequestFundDto}
     * @memberof SuccessGetRequestFundByIdDto
     */
    result?: GetUserRequestFundDto;
}
/**
 * 
 * @export
 * @interface SuccessGetRequestFundToUserByIdDto
 */
export interface SuccessGetRequestFundToUserByIdDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundToUserByIdDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRequestFundToUserByIdDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundToUserByIdDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundToUserByIdDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetUserRequestFundDto}
     * @memberof SuccessGetRequestFundToUserByIdDto
     */
    result?: GetUserRequestFundDto;
}
/**
 * 
 * @export
 * @interface SuccessGetRequestFundsFromUsersDto
 */
export interface SuccessGetRequestFundsFromUsersDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsFromUsersDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRequestFundsFromUsersDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsFromUsersDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsFromUsersDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetUserRequestFundDto>}
     * @memberof SuccessGetRequestFundsFromUsersDto
     */
    result?: Array<GetUserRequestFundDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetRequestFundsToUsersDto
 */
export interface SuccessGetRequestFundsToUsersDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsToUsersDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRequestFundsToUsersDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsToUsersDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsToUsersDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetUserRequestFundDto>}
     * @memberof SuccessGetRequestFundsToUsersDto
     */
    result?: Array<GetUserRequestFundDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetRequestFundsViaLinkDto
 */
export interface SuccessGetRequestFundsViaLinkDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsViaLinkDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRequestFundsViaLinkDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsViaLinkDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRequestFundsViaLinkDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetRequestFundsViaLinkDto}
     * @memberof SuccessGetRequestFundsViaLinkDto
     */
    result?: GetRequestFundsViaLinkDto;
}
/**
 * 
 * @export
 * @interface SuccessGetRoamingUsersDto
 */
export interface SuccessGetRoamingUsersDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRoamingUsersDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetRoamingUsersDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRoamingUsersDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetRoamingUsersDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<TipseeUserProfileDto>}
     * @memberof SuccessGetRoamingUsersDto
     */
    result?: Array<TipseeUserProfileDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetSMSOtpDto
 */
export interface SuccessGetSMSOtpDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSMSOtpDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetSMSOtpDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSMSOtpDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSMSOtpDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetSMSOtpResultDto}
     * @memberof SuccessGetSMSOtpDto
     */
    result?: GetSMSOtpResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetSendOutTransactionsAmountsDto
 */
export interface SuccessGetSendOutTransactionsAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSendOutTransactionsAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetSendOutTransactionsAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSendOutTransactionsAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSendOutTransactionsAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTransactionsAmountsDto}
     * @memberof SuccessGetSendOutTransactionsAmountsDto
     */
    result?: GetTransactionsAmountsDto;
}
/**
 * 
 * @export
 * @interface SuccessGetStickerPinCodeDto
 */
export interface SuccessGetStickerPinCodeDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetStickerPinCodeDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetStickerPinCodeDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetStickerPinCodeDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetStickerPinCodeDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetStickerPinCodeResultDto}
     * @memberof SuccessGetStickerPinCodeDto
     */
    result?: GetStickerPinCodeResultDto;
}
/**
 * 
 * @export
 * @interface SuccessGetSummaryTransactionFeeAmountsDto
 */
export interface SuccessGetSummaryTransactionFeeAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSummaryTransactionFeeAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetSummaryTransactionFeeAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSummaryTransactionFeeAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetSummaryTransactionFeeAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetSummaryTransactionFeeAmountDto}
     * @memberof SuccessGetSummaryTransactionFeeAmountsDto
     */
    result?: GetSummaryTransactionFeeAmountDto;
}
/**
 * 
 * @export
 * @interface SuccessGetTipeesByVenueIdDto
 */
export interface SuccessGetTipeesByVenueIdDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTipeesByVenueIdDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTipeesByVenueIdDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTipeesByVenueIdDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTipeesByVenueIdDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetTipeesByVenueIdDto>}
     * @memberof SuccessGetTipeesByVenueIdDto
     */
    result?: Array<GetTipeesByVenueIdDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetTransactionAmountsDto
 */
export interface SuccessGetTransactionAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTransactionAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetTransactionAmountByPeriodDto>}
     * @memberof SuccessGetTransactionAmountsDto
     */
    result?: Array<GetTransactionAmountByPeriodDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetTransactionFeeAmountsByBaseCurrencyDto
 */
export interface SuccessGetTransactionFeeAmountsByBaseCurrencyDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsByBaseCurrencyDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTransactionFeeAmountsByBaseCurrencyDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsByBaseCurrencyDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsByBaseCurrencyDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTransactionFeeAmountByBaseCurrencyDto}
     * @memberof SuccessGetTransactionFeeAmountsByBaseCurrencyDto
     */
    result?: GetTransactionFeeAmountByBaseCurrencyDto;
}
/**
 * 
 * @export
 * @interface SuccessGetTransactionFeeAmountsDto
 */
export interface SuccessGetTransactionFeeAmountsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTransactionFeeAmountsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionFeeAmountsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetTransactionFeeAmountByPeriodDto>}
     * @memberof SuccessGetTransactionFeeAmountsDto
     */
    result?: Array<GetTransactionFeeAmountByPeriodDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetTransactionNumberDto
 */
export interface SuccessGetTransactionNumberDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionNumberDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTransactionNumberDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionNumberDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionNumberDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTransactionNumberDto}
     * @memberof SuccessGetTransactionNumberDto
     */
    result?: GetTransactionNumberDto;
}
/**
 * 
 * @export
 * @interface SuccessGetTransactionsDto
 */
export interface SuccessGetTransactionsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetTransactionsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetTransactionsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetTransactionDto>}
     * @memberof SuccessGetTransactionsDto
     */
    result?: Array<GetTransactionDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetUserDto
 */
export interface SuccessGetUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserDto
     */
    resultCount?: number;
    /**
     * 
     * @type {VenueUserProfileDto}
     * @memberof SuccessGetUserDto
     */
    result?: VenueUserProfileDto;
}
/**
 * 
 * @export
 * @interface SuccessGetUserInfoDto
 */
export interface SuccessGetUserInfoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserInfoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetUserInfoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserInfoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserInfoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserSanatizeDto}
     * @memberof SuccessGetUserInfoDto
     */
    result?: UserSanatizeDto;
}
/**
 * 
 * @export
 * @interface SuccessGetUserProfileByAdminDtoResponse
 */
export interface SuccessGetUserProfileByAdminDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserProfileByAdminDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetUserProfileByAdminDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserProfileByAdminDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUserProfileByAdminDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {GetUserProfileByAdminDto}
     * @memberof SuccessGetUserProfileByAdminDtoResponse
     */
    result?: GetUserProfileByAdminDto;
}
/**
 * 
 * @export
 * @interface SuccessGetUsersDto
 */
export interface SuccessGetUsersDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUsersDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetUsersDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUsersDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetUsersDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<VenueUserProfileDto>}
     * @memberof SuccessGetUsersDto
     */
    result?: Array<VenueUserProfileDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetVenueDto
 */
export interface SuccessGetVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenueDto
     */
    resultCount?: number;
    /**
     * 
     * @type {VenueDto}
     * @memberof SuccessGetVenueDto
     */
    result?: VenueDto;
}
/**
 * 
 * @export
 * @interface SuccessGetVenuesByMerchantIdDto
 */
export interface SuccessGetVenuesByMerchantIdDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesByMerchantIdDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetVenuesByMerchantIdDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesByMerchantIdDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesByMerchantIdDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetVenuesByMerchantIdDto>}
     * @memberof SuccessGetVenuesByMerchantIdDto
     */
    result?: Array<GetVenuesByMerchantIdDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetVenuesDto
 */
export interface SuccessGetVenuesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetVenuesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVenuesDto
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<VenueDto>}
     * @memberof SuccessGetVenuesDto
     */
    result?: Array<VenueDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessGetVersionDto
 */
export interface SuccessGetVersionDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVersionDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetVersionDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVersionDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetVersionDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetVersionDto}
     * @memberof SuccessGetVersionDto
     */
    result?: GetVersionDto;
}
/**
 * 
 * @export
 * @interface SuccessGetWalletDto
 */
export interface SuccessGetWalletDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWalletDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetWalletDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWalletDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWalletDto
     */
    resultCount?: number;
    /**
     * 
     * @type {WalletDto}
     * @memberof SuccessGetWalletDto
     */
    result?: WalletDto;
}
/**
 * 
 * @export
 * @interface SuccessGetWorkingDto
 */
export interface SuccessGetWorkingDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWorkingDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessGetWorkingDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWorkingDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessGetWorkingDto
     */
    resultCount?: number;
    /**
     * 
     * @type {GetTipeeWorkingDto}
     * @memberof SuccessGetWorkingDto
     */
    result?: GetTipeeWorkingDto;
}
/**
 * 
 * @export
 * @interface SuccessIsSessionActiveDto
 */
export interface SuccessIsSessionActiveDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessIsSessionActiveDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessIsSessionActiveDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessIsSessionActiveDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessIsSessionActiveDto
     */
    resultCount?: number;
    /**
     * 
     * @type {CheckSessionActiveResultDto}
     * @memberof SuccessIsSessionActiveDto
     */
    result?: CheckSessionActiveResultDto;
}
/**
 * 
 * @export
 * @interface SuccessJoinVenueDto
 */
export interface SuccessJoinVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessJoinVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessJoinVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessJoinVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessJoinVenueDto
     */
    resultCount?: number;
    /**
     * 
     * @type {VenueUserDto}
     * @memberof SuccessJoinVenueDto
     */
    result?: VenueUserDto;
}
/**
 * 
 * @export
 * @interface SuccessKycDtoResponse
 */
export interface SuccessKycDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessKycDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessKycDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessKycDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessKycDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {KycDto}
     * @memberof SuccessKycDtoResponse
     */
    result?: KycDto;
}
/**
 * 
 * @export
 * @interface SuccessLeaveVenueDto
 */
export interface SuccessLeaveVenueDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLeaveVenueDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLeaveVenueDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLeaveVenueDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLeaveVenueDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessListCountryDtoResponse
 */
export interface SuccessListCountryDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListCountryDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListCountryDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListCountryDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListCountryDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<CountryDto>}
     * @memberof SuccessListCountryDtoResponse
     */
    result?: Array<CountryDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListCurrencyDtoResponse
 */
export interface SuccessListCurrencyDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListCurrencyDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListCurrencyDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListCurrencyDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListCurrencyDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<CurrencyDto>}
     * @memberof SuccessListCurrencyDtoResponse
     */
    result?: Array<CurrencyDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepKycDtoResponse
 */
export interface SuccessListDeepKycDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepKycDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepKycDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepKycDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepKycDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepKycDto>}
     * @memberof SuccessListDeepKycDtoResponse
     */
    result?: Array<DeepKycDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepPaymentMethodDtoResponse
 */
export interface SuccessListDeepPaymentMethodDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPaymentMethodDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepPaymentMethodDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPaymentMethodDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPaymentMethodDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPaymentMethodDto>}
     * @memberof SuccessListDeepPaymentMethodDtoResponse
     */
    result?: Array<DeepPaymentMethodDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepPhysicalWalletDtoResponse
 */
export interface SuccessListDeepPhysicalWalletDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepPhysicalWalletDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPhysicalWalletDto>}
     * @memberof SuccessListDeepPhysicalWalletDtoResponse
     */
    result?: Array<DeepPhysicalWalletDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepPhysicalWalletPlanDtoResponse
 */
export interface SuccessListDeepPhysicalWalletPlanDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletPlanDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepPhysicalWalletPlanDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletPlanDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletPlanDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPhysicalWalletPlanDto>}
     * @memberof SuccessListDeepPhysicalWalletPlanDtoResponse
     */
    result?: Array<DeepPhysicalWalletPlanDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepPhysicalWalletTierDtoResponse
 */
export interface SuccessListDeepPhysicalWalletTierDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTierDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepPhysicalWalletTierDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTierDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTierDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPhysicalWalletTierDto>}
     * @memberof SuccessListDeepPhysicalWalletTierDtoResponse
     */
    result?: Array<DeepPhysicalWalletTierDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListDeepPhysicalWalletTypeDtoResponse
 */
export interface SuccessListDeepPhysicalWalletTypeDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTypeDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListDeepPhysicalWalletTypeDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTypeDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListDeepPhysicalWalletTypeDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<DeepPhysicalWalletTypeDto>}
     * @memberof SuccessListDeepPhysicalWalletTypeDtoResponse
     */
    result?: Array<DeepPhysicalWalletTypeDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListFeeDefinitionDtoResponse
 */
export interface SuccessListFeeDefinitionDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListFeeDefinitionDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListFeeDefinitionDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListFeeDefinitionDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListFeeDefinitionDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<FeeDefinitionDto>}
     * @memberof SuccessListFeeDefinitionDtoResponse
     */
    result?: Array<FeeDefinitionDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListGetAllUsersDtoResponse
 */
export interface SuccessListGetAllUsersDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetAllUsersDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListGetAllUsersDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetAllUsersDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetAllUsersDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetAllUsersDto>}
     * @memberof SuccessListGetAllUsersDtoResponse
     */
    result?: Array<GetAllUsersDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
 */
export interface SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetPaymentMethodInstanceBalanceAmountsDto>}
     * @memberof SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse
     */
    result?: Array<GetPaymentMethodInstanceBalanceAmountsDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListGetServiceClassIdResultDtoResponse
 */
export interface SuccessListGetServiceClassIdResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetServiceClassIdResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListGetServiceClassIdResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetServiceClassIdResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListGetServiceClassIdResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<GetServiceClassIdResultDto>}
     * @memberof SuccessListGetServiceClassIdResultDtoResponse
     */
    result?: Array<GetServiceClassIdResultDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListPhysicalWalletDtoResponse
 */
export interface SuccessListPhysicalWalletDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListPhysicalWalletDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListPhysicalWalletDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListPhysicalWalletDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListPhysicalWalletDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<PhysicalWalletDto>}
     * @memberof SuccessListPhysicalWalletDtoResponse
     */
    result?: Array<PhysicalWalletDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListRegionDtoResponse
 */
export interface SuccessListRegionDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListRegionDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListRegionDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListRegionDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListRegionDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<RegionDto>}
     * @memberof SuccessListRegionDtoResponse
     */
    result?: Array<RegionDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListReturnCodesDtoResponse
 */
export interface SuccessListReturnCodesDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListReturnCodesDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListReturnCodesDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListReturnCodesDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListReturnCodesDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<ReturnCodesDto>}
     * @memberof SuccessListReturnCodesDtoResponse
     */
    result?: Array<ReturnCodesDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListWalletDtoResponse
 */
export interface SuccessListWalletDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListWalletDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<WalletDto>}
     * @memberof SuccessListWalletDtoResponse
     */
    result?: Array<WalletDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessListWalletTypeDtoResponse
 */
export interface SuccessListWalletTypeDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletTypeDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessListWalletTypeDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletTypeDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessListWalletTypeDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {Array<WalletTypeDto>}
     * @memberof SuccessListWalletTypeDtoResponse
     */
    result?: Array<WalletTypeDto> | null;
}
/**
 * 
 * @export
 * @interface SuccessLockActivityDto
 */
export interface SuccessLockActivityDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLockActivityDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLockActivityDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLockActivityDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLockActivityDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessLockPaymentMethodDto
 */
export interface SuccessLockPaymentMethodDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLockPaymentMethodDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLockPaymentMethodDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLockPaymentMethodDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLockPaymentMethodDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessLoginBiometricsDto
 */
export interface SuccessLoginBiometricsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginBiometricsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLoginBiometricsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginBiometricsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginBiometricsDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserSanatizeDto}
     * @memberof SuccessLoginBiometricsDto
     */
    result?: UserSanatizeDto;
}
/**
 * 
 * @export
 * @interface SuccessLoginPINDto
 */
export interface SuccessLoginPINDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginPINDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLoginPINDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginPINDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLoginPINDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserSanatizeDto}
     * @memberof SuccessLoginPINDto
     */
    result?: UserSanatizeDto;
}
/**
 * 
 * @export
 * @interface SuccessLogoutDto
 */
export interface SuccessLogoutDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessLogoutDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessLogoutDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessLogoutDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessLogoutDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessPayRequestFundViaLinkDto
 */
export interface SuccessPayRequestFundViaLinkDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessPayRequestFundViaLinkDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessPayRequestFundViaLinkDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessPayRequestFundViaLinkDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessPayRequestFundViaLinkDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessPayRequestFundViaLinkDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessPayUserFundRequestDto
 */
export interface SuccessPayUserFundRequestDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessPayUserFundRequestDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessPayUserFundRequestDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessPayUserFundRequestDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessPayUserFundRequestDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessPayUserFundRequestDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessPhysicalWalletPersoDtoResponse
 */
export interface SuccessPhysicalWalletPersoDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessPhysicalWalletPersoDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessPhysicalWalletPersoDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessPhysicalWalletPersoDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessPhysicalWalletPersoDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {PhysicalWalletPersoDto}
     * @memberof SuccessPhysicalWalletPersoDtoResponse
     */
    result?: PhysicalWalletPersoDto;
}
/**
 * 
 * @export
 * @interface SuccessReadMessageDto
 */
export interface SuccessReadMessageDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessReadMessageDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessReadMessageDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessReadMessageDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessReadMessageDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserChatDto}
     * @memberof SuccessReadMessageDto
     */
    result?: UserChatDto;
}
/**
 * 
 * @export
 * @interface SuccessRefreshExchangeRatesDto
 */
export interface SuccessRefreshExchangeRatesDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessRefreshExchangeRatesDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRefreshExchangeRatesDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRefreshExchangeRatesDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRefreshExchangeRatesDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessRegionDtoResponse
 */
export interface SuccessRegionDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessRegionDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRegionDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRegionDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRegionDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {RegionDto}
     * @memberof SuccessRegionDtoResponse
     */
    result?: RegionDto;
}
/**
 * 
 * @export
 * @interface SuccessRemoveContactDto
 */
export interface SuccessRemoveContactDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveContactDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRemoveContactDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveContactDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveContactDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessRemoveUserDto
 */
export interface SuccessRemoveUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRemoveUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRemoveUserDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessRequestFundToUserDto
 */
export interface SuccessRequestFundToUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundToUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRequestFundToUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundToUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundToUserDto
     */
    resultCount?: number;
    /**
     * 
     * @type {CreateRequestUserFundResultDto}
     * @memberof SuccessRequestFundToUserDto
     */
    result?: CreateRequestUserFundResultDto;
}
/**
 * 
 * @export
 * @interface SuccessRequestFundsViaLinkDto
 */
export interface SuccessRequestFundsViaLinkDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundsViaLinkDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessRequestFundsViaLinkDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundsViaLinkDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessRequestFundsViaLinkDto
     */
    resultCount?: number;
    /**
     * 
     * @type {RequestFundsViaLinkResultDto}
     * @memberof SuccessRequestFundsViaLinkDto
     */
    result?: RequestFundsViaLinkResultDto;
}
/**
 * 
 * @export
 * @interface SuccessResendEmailDto
 */
export interface SuccessResendEmailDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessResendEmailDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessResendEmailDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessResendEmailDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessResendEmailDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessResendSMSDto
 */
export interface SuccessResendSMSDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessResendSMSDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessResendSMSDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessResendSMSDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessResendSMSDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessReservePersoDto
 */
export interface SuccessReservePersoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessReservePersoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessReservePersoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessReservePersoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessReservePersoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {ReservePersoResultDto}
     * @memberof SuccessReservePersoDto
     */
    result?: ReservePersoResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSaveUserResultDtoResponse
 */
export interface SuccessSaveUserResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessSaveUserResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSaveUserResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSaveUserResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSaveUserResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {SaveUserResultDto}
     * @memberof SuccessSaveUserResultDtoResponse
     */
    result?: SaveUserResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSendMessageDto
 */
export interface SuccessSendMessageDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSendMessageDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSendMessageDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendMessageDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendMessageDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserChatDto}
     * @memberof SuccessSendMessageDto
     */
    result?: UserChatDto;
}
/**
 * 
 * @export
 * @interface SuccessSendTipDto
 */
export interface SuccessSendTipDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSendTipDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSendTipDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendTipDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendTipDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessSendTipDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessSendToBankDto
 */
export interface SuccessSendToBankDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToBankDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSendToBankDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToBankDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToBankDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessSendToBankDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessSendToCryptoDto
 */
export interface SuccessSendToCryptoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToCryptoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSendToCryptoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToCryptoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToCryptoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessSendToCryptoDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessSendToUserDto
 */
export interface SuccessSendToUserDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToUserDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSendToUserDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToUserDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSendToUserDto
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessSendToUserDto
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessSetAuthDto
 */
export interface SuccessSetAuthDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetAuthDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetAuthDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetAuthDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetAuthDto
     */
    resultCount?: number;
    /**
     * 
     * @type {SetAuthResultDto}
     * @memberof SuccessSetAuthDto
     */
    result?: SetAuthResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSetBalanceDto
 */
export interface SuccessSetBalanceDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBalanceDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetBalanceDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBalanceDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBalanceDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetBiometricsDto
 */
export interface SuccessSetBiometricsDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBiometricsDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetBiometricsDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBiometricsDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetBiometricsDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetLocationDto
 */
export interface SuccessSetLocationDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetLocationDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetLocationDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetLocationDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetLocationDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetMainBankAccountDto
 */
export interface SuccessSetMainBankAccountDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetMainBankAccountDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetMainBankAccountDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetMainBankAccountDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetMainBankAccountDto
     */
    resultCount?: number;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof SuccessSetMainBankAccountDto
     */
    result?: PaymentMethodInstanceDto;
}
/**
 * 
 * @export
 * @interface SuccessSetPINDto
 */
export interface SuccessSetPINDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPINDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetPINDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPINDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPINDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetPaymentMethodInstanceSettingResponse
 */
export interface SuccessSetPaymentMethodInstanceSettingResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPaymentMethodInstanceSettingResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetPaymentMethodInstanceSettingResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPaymentMethodInstanceSettingResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPaymentMethodInstanceSettingResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {SetPaymentMethodInstanceSettingResultDto}
     * @memberof SuccessSetPaymentMethodInstanceSettingResponse
     */
    result?: SetPaymentMethodInstanceSettingResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSetPhysicalWalletPaymentMethodResponse
 */
export interface SuccessSetPhysicalWalletPaymentMethodResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPhysicalWalletPaymentMethodResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetPhysicalWalletPaymentMethodResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPhysicalWalletPaymentMethodResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPhysicalWalletPaymentMethodResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {SetPhysicalWalletPaymentMethodResultDto}
     * @memberof SuccessSetPhysicalWalletPaymentMethodResponse
     */
    result?: SetPhysicalWalletPaymentMethodResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSetPolicyDto
 */
export interface SuccessSetPolicyDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPolicyDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetPolicyDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPolicyDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetPolicyDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetProfileDto
 */
export interface SuccessSetProfileDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetProfileDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetProfileDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetProfileDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetProfileDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserProfileDto}
     * @memberof SuccessSetProfileDto
     */
    result?: UserProfileDto;
}
/**
 * 
 * @export
 * @interface SuccessSetSessionExpireDto
 */
export interface SuccessSetSessionExpireDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetSessionExpireDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetSessionExpireDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetSessionExpireDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetSessionExpireDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetUserInfoDto
 */
export interface SuccessSetUserInfoDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserInfoDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetUserInfoDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserInfoDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserInfoDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserSanatizeDto}
     * @memberof SuccessSetUserInfoDto
     */
    result?: UserSanatizeDto;
}
/**
 * 
 * @export
 * @interface SuccessSetUserStatusDto
 */
export interface SuccessSetUserStatusDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserStatusDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetUserStatusDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserStatusDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetUserStatusDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSetupPhysicalWalletResponse
 */
export interface SuccessSetupPhysicalWalletResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessSetupPhysicalWalletResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSetupPhysicalWalletResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetupPhysicalWalletResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSetupPhysicalWalletResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {SetupPhysicalWalletResultDto}
     * @memberof SuccessSetupPhysicalWalletResponse
     */
    result?: SetupPhysicalWalletResultDto;
}
/**
 * 
 * @export
 * @interface SuccessSignedDto
 */
export interface SuccessSignedDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessSignedDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSignedDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSignedDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSignedDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessStartWorkingDto
 */
export interface SuccessStartWorkingDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessStartWorkingDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessStartWorkingDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessStartWorkingDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessStartWorkingDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessStopWorkingDto
 */
export interface SuccessStopWorkingDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessStopWorkingDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessStopWorkingDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessStopWorkingDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessStopWorkingDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessSystemSettingsDtoResponse
 */
export interface SuccessSystemSettingsDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessSystemSettingsDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessSystemSettingsDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessSystemSettingsDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessSystemSettingsDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {SystemSettingsDto}
     * @memberof SuccessSystemSettingsDtoResponse
     */
    result?: SystemSettingsDto;
}
/**
 * 
 * @export
 * @interface SuccessTransactionDtoResponse
 */
export interface SuccessTransactionDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessTransactionDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessTransactionDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessTransactionDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessTransactionDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {TransactionDto}
     * @memberof SuccessTransactionDtoResponse
     */
    result?: TransactionDto;
}
/**
 * 
 * @export
 * @interface SuccessUndoSignedDto
 */
export interface SuccessUndoSignedDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessUndoSignedDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessUndoSignedDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessUndoSignedDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessUndoSignedDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessUnlockPaymentMethodDto
 */
export interface SuccessUnlockPaymentMethodDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessUnlockPaymentMethodDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessUnlockPaymentMethodDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessUnlockPaymentMethodDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessUnlockPaymentMethodDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessUpdateActivatedStickerDto
 */
export interface SuccessUpdateActivatedStickerDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateActivatedStickerDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessUpdateActivatedStickerDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateActivatedStickerDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateActivatedStickerDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessUpdateDeviceDto
 */
export interface SuccessUpdateDeviceDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateDeviceDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessUpdateDeviceDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateDeviceDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessUpdateDeviceDto
     */
    resultCount?: number;
    /**
     * 
     * @type {DeviceDto}
     * @memberof SuccessUpdateDeviceDto
     */
    result?: DeviceDto;
}
/**
 * 
 * @export
 * @interface SuccessUserSanatizeDtoResponse
 */
export interface SuccessUserSanatizeDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessUserSanatizeDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessUserSanatizeDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessUserSanatizeDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessUserSanatizeDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {UserSanatizeDto}
     * @memberof SuccessUserSanatizeDtoResponse
     */
    result?: UserSanatizeDto;
}
/**
 * 
 * @export
 * @interface SuccessValidatePhysicalWalletDynamicPanResponse
 */
export interface SuccessValidatePhysicalWalletDynamicPanResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessValidatePhysicalWalletDynamicPanResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessValidatePhysicalWalletDynamicPanResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessValidatePhysicalWalletDynamicPanResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessValidatePhysicalWalletDynamicPanResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {ValidateDynamicPhysicalWalletPanResultDto}
     * @memberof SuccessValidatePhysicalWalletDynamicPanResponse
     */
    result?: ValidateDynamicPhysicalWalletPanResultDto;
}
/**
 * 
 * @export
 * @interface SuccessVerifyEmailCodeDto
 */
export interface SuccessVerifyEmailCodeDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailCodeDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessVerifyEmailCodeDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailCodeDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailCodeDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessVerifyEmailDto
 */
export interface SuccessVerifyEmailDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessVerifyEmailDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyEmailDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessVerifyKycDocumentResultDtoResponse
 */
export interface SuccessVerifyKycDocumentResultDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyKycDocumentResultDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessVerifyKycDocumentResultDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyKycDocumentResultDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyKycDocumentResultDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {VerifyKycDocumentResultDto}
     * @memberof SuccessVerifyKycDocumentResultDtoResponse
     */
    result?: VerifyKycDocumentResultDto;
}
/**
 * 
 * @export
 * @interface SuccessVerifyMobileDto
 */
export interface SuccessVerifyMobileDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyMobileDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessVerifyMobileDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyMobileDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifyMobileDto
     */
    resultCount?: number;
}
/**
 * 
 * @export
 * @interface SuccessVerifySMSDto
 */
export interface SuccessVerifySMSDto {
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifySMSDto
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessVerifySMSDto
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifySMSDto
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessVerifySMSDto
     */
    resultCount?: number;
    /**
     * 
     * @type {UserVerifySmsDto}
     * @memberof SuccessVerifySMSDto
     */
    result?: UserVerifySmsDto;
}
/**
 * 
 * @export
 * @interface SuccessWalletTypeDtoResponse
 */
export interface SuccessWalletTypeDtoResponse {
    /**
     * 
     * @type {number}
     * @memberof SuccessWalletTypeDtoResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof SuccessWalletTypeDtoResponse
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof SuccessWalletTypeDtoResponse
     */
    statusCode: number;
    /**
     * 
     * @type {number}
     * @memberof SuccessWalletTypeDtoResponse
     */
    resultCount?: number;
    /**
     * 
     * @type {WalletTypeDto}
     * @memberof SuccessWalletTypeDtoResponse
     */
    result?: WalletTypeDto;
}
/**
 * 
 * @export
 * @interface SystemSettings
 */
export interface SystemSettings {
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    customerContactNumber?: string | null;
    /**
     * 
     * @type {Currency}
     * @memberof SystemSettings
     */
    baseCurrency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    baseCurrencyId?: string;
    /**
     * 
     * @type {Array<ExternalServiceSetting>}
     * @memberof SystemSettings
     */
    externalServiceSettings?: Array<ExternalServiceSetting> | null;
}
/**
 * 
 * @export
 * @interface SystemSettingsDto
 */
export interface SystemSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    customerContactNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsDto
     */
    baseCurrencyId: string;
    /**
     * 
     * @type {Array<ExternalServiceSettingDto>}
     * @memberof SystemSettingsDto
     */
    externalServiceSettings?: Array<ExternalServiceSettingDto> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TipseeRoleValues {
    Tipee = 'Tipee',
    Tipeer = 'Tipeer',
    Owner = 'Owner',
    Merchant = 'Merchant'
}

/**
 * 
 * @export
 * @interface TipseeUserProfileDto
 */
export interface TipseeUserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof TipseeUserProfileDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TipseeUserProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof TipseeUserProfileDto
     */
    nickName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TipseeUserProfileDto
     */
    latitude: number;
    /**
     * 
     * @type {number}
     * @memberof TipseeUserProfileDto
     */
    longitude: number;
    /**
     * 
     * @type {string}
     * @memberof TipseeUserProfileDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TipseeUserProfileDto
     */
    prepaidId?: string | null;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {Array<TransactionLine>}
     * @memberof Transaction
     */
    lines?: Array<TransactionLine> | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    transactionRequestId?: string | null;
    /**
     * 
     * @type {SecurityTypeValues}
     * @memberof Transaction
     */
    securityType?: SecurityTypeValues;
    /**
     * 
     * @type {RequestUserFund}
     * @memberof Transaction
     */
    requestUserFund?: RequestUserFund;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    currentLineTransactionLineId?: string | null;
    /**
     * 
     * @type {TransactionLine}
     * @memberof Transaction
     */
    currentLine?: TransactionLine;
    /**
     * 
     * @type {RequestAnonymousFundTransaction}
     * @memberof Transaction
     */
    requestAnonymousFund?: RequestAnonymousFundTransaction;
}
/**
 * 
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    currentLineTransactionLineId?: string | null;
    /**
     * 
     * @type {TransactionLineDto}
     * @memberof TransactionDto
     */
    currentLine?: TransactionLineDto;
    /**
     * 
     * @type {Array<TransactionLineDto>}
     * @memberof TransactionDto
     */
    lines?: Array<TransactionLineDto> | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    paymentReference?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionDto
     */
    tfxProfit?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    transactionRequestId?: string | null;
    /**
     * 
     * @type {SecurityTypeValues}
     * @memberof TransactionDto
     */
    securityType: SecurityTypeValues;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    fromUserId: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    fromUserName: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    toUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    toUserName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDto
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionLine
 */
export interface TransactionLine {
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionLine
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    paymentMethodFromPaymentMethodInstanceId?: string;
    /**
     * 
     * @type {PaymentMethodInstance}
     * @memberof TransactionLine
     */
    paymentMethodFrom?: PaymentMethodInstance;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    paymentMethodToPaymentMethodInstanceId?: string;
    /**
     * 
     * @type {PaymentMethodInstance}
     * @memberof TransactionLine
     */
    paymentMethodTo?: PaymentMethodInstance;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    currencyFromCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof TransactionLine
     */
    currencyFrom?: Currency;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    currencyToCurrencyId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof TransactionLine
     */
    currencyTo?: Currency;
    /**
     * 
     * @type {number}
     * @memberof TransactionLine
     */
    amountFrom?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLine
     */
    amountTo?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLine
     */
    conversionRatio?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLine
     */
    baseCurrencyRate?: number;
    /**
     * 
     * @type {TransactionStatusValues}
     * @memberof TransactionLine
     */
    status?: TransactionStatusValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof TransactionLine
     */
    type?: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof TransactionLine
     */
    paymentType?: PaymentTypeValues;
    /**
     * 
     * @type {string}
     * @memberof TransactionLine
     */
    transactionId?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof TransactionLine
     */
    transaction?: Transaction;
    /**
     * 
     * @type {Array<TransactionLineFee>}
     * @memberof TransactionLine
     */
    fees?: Array<TransactionLineFee> | null;
}
/**
 * 
 * @export
 * @interface TransactionLineDto
 */
export interface TransactionLineDto {
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    paymentMethodFromPaymentMethodInstanceId: string;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof TransactionLineDto
     */
    paymentMethodFrom?: PaymentMethodInstanceDto;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    paymentMethodToPaymentMethodInstanceId: string;
    /**
     * 
     * @type {PaymentMethodInstanceDto}
     * @memberof TransactionLineDto
     */
    paymentMethodTo?: PaymentMethodInstanceDto;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    currencyFromCurrencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof TransactionLineDto
     */
    currencyFrom?: CurrencyDto;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    currencyToCurrencyId: string;
    /**
     * 
     * @type {CurrencyDto}
     * @memberof TransactionLineDto
     */
    currencyTo?: CurrencyDto;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineDto
     */
    amountFrom: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineDto
     */
    amountTo: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineDto
     */
    fees?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineDto
     */
    conversionRatio?: number;
    /**
     * 
     * @type {TransactionStatusValues}
     * @memberof TransactionLineDto
     */
    status?: TransactionStatusValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof TransactionLineDto
     */
    type: TransactionTypeValues;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromUserId: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromUserFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromUserMiddleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromUserLastName: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toUserFirstName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toUserMiddleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toUserLastName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toCurrencyName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineDto
     */
    convertedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    convertedCurrency?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    moneyCameFromDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    toUserFullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineDto
     */
    fromUserFullName?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionLineFee
 */
export interface TransactionLineFee {
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionLineFee
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    transactionLineId?: string;
    /**
     * 
     * @type {TransactionLine}
     * @memberof TransactionLineFee
     */
    transactionLine?: TransactionLine;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionLineFee
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    currency?: string | null;
    /**
     * 
     * @type {FeeTypeValues}
     * @memberof TransactionLineFee
     */
    type?: FeeTypeValues;
    /**
     * 
     * @type {FeeUnitValues}
     * @memberof TransactionLineFee
     */
    unit?: FeeUnitValues;
    /**
     * 
     * @type {FeePaidByValues}
     * @memberof TransactionLineFee
     */
    paidBy?: FeePaidByValues;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionLineFee
     */
    isChoice?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionLineFee
     */
    feeReference?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TransactionPeriodUnitValues {
    Date = 'Date',
    Month = 'Month',
    Quarter = 'Quarter',
    Year = 'Year'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum TransactionStatusValues {
    Completed = 'Completed',
    Cancelled = 'Cancelled',
    Reversed = 'Reversed',
    Inprogress = 'Inprogress',
    New = 'New',
    Locked = 'Locked'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum TransactionTypeValues {
    Exchange = 'Exchange',
    InternalTransfer = 'InternalTransfer',
    ExternalTransferIn = 'ExternalTransferIn',
    ExternalTransferOut = 'ExternalTransferOut'
}

/**
 * 
 * @export
 * @interface UnDeleteCurrencyRequest
 */
export interface UnDeleteCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof UnDeleteCurrencyRequest
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UnDeletePaymentMethodRequest
 */
export interface UnDeletePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof UnDeletePaymentMethodRequest
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UnDeleteRegionRequest
 */
export interface UnDeleteRegionRequest {
    /**
     * 
     * @type {string}
     * @memberof UnDeleteRegionRequest
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UndoSignedRequest
 */
export interface UndoSignedRequest {
    /**
     * 
     * @type {string}
     * @memberof UndoSignedRequest
     */
    serial: string;
}
/**
 * 
 * @export
 * @interface UnlockPaymentMethodRequest
 */
export interface UnlockPaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof UnlockPaymentMethodRequest
     */
    paymentMethodId: string;
}
/**
 * 
 * @export
 * @interface UpdateActivatedStickerRequest
 */
export interface UpdateActivatedStickerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateActivatedStickerRequest
     */
    serial: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActivatedStickerRequest
     */
    macAddress: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActivatedStickerRequest
     */
    signature: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActivatedStickerRequest
     */
    signedPackage?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateCurrencyRequest
 */
export interface UpdateCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrencyRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrencyRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrencyRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateCurrencyRequest
     */
    precision: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrencyRequest
     */
    format: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCurrencyRequest
     */
    isDeleted?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateDeviceRequest
 */
export interface UpdateDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    uuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    deviceToken: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    system?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    systemVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    brand?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateDeviceRequest
     */
    model?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateFeeDefinitionDto
 */
export interface UpdateFeeDefinitionDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionDto
     */
    fromCurrencyId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionDto
     */
    toCurrencyId: string;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof UpdateFeeDefinitionDto
     */
    fromPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {PaymentMethodTypeValues}
     * @memberof UpdateFeeDefinitionDto
     */
    toPaymentMethodType: PaymentMethodTypeValues;
    /**
     * 
     * @type {TransactionTypeValues}
     * @memberof UpdateFeeDefinitionDto
     */
    transactionType: TransactionTypeValues;
    /**
     * 
     * @type {PaymentTypeValues}
     * @memberof UpdateFeeDefinitionDto
     */
    paymentType: PaymentTypeValues;
    /**
     * 
     * @type {Array<UpdateFeeDefinitionValueDto>}
     * @memberof UpdateFeeDefinitionDto
     */
    values?: Array<UpdateFeeDefinitionValueDto> | null;
}
/**
 * 
 * @export
 * @interface UpdateFeeDefinitionRequest
 */
export interface UpdateFeeDefinitionRequest {
    /**
     * 
     * @type {UpdateFeeDefinitionDto}
     * @memberof UpdateFeeDefinitionRequest
     */
    feeDefinition?: UpdateFeeDefinitionDto;
}
/**
 * 
 * @export
 * @interface UpdateFeeDefinitionValueCountryDto
 */
export interface UpdateFeeDefinitionValueCountryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueCountryDto
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueCountryDto
     */
    fromCountryIso?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueCountryDto
     */
    toCountryIso?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateFeeDefinitionValueDto
 */
export interface UpdateFeeDefinitionValueDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueDto
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueDto
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateFeeDefinitionValueDto
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeeDefinitionValueDto
     */
    currencyId?: string;
    /**
     * 
     * @type {FeeTypeValues}
     * @memberof UpdateFeeDefinitionValueDto
     */
    type: FeeTypeValues;
    /**
     * 
     * @type {FeeUnitValues}
     * @memberof UpdateFeeDefinitionValueDto
     */
    unit: FeeUnitValues;
    /**
     * 
     * @type {FeePaidByValues}
     * @memberof UpdateFeeDefinitionValueDto
     */
    paidBy: FeePaidByValues;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFeeDefinitionValueDto
     */
    isChoice: boolean;
    /**
     * 
     * @type {Array<UpdateFeeDefinitionValueCountryDto>}
     * @memberof UpdateFeeDefinitionValueDto
     */
    countries?: Array<UpdateFeeDefinitionValueCountryDto> | null;
}
/**
 * 
 * @export
 * @interface UpdateKycStatusRequest
 */
export interface UpdateKycStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateKycStatusRequest
     */
    kycId: string;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof UpdateKycStatusRequest
     */
    level: KycLevelValues;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof UpdateKycStatusRequest
     */
    status: KycStatusValues;
}
/**
 * 
 * @export
 * @interface UpdatePaymentMethodRequest
 */
export interface UpdatePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    canSend?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    canReceive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    canExchange?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    hasBalance?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    canBank?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    canLock?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentMethodRequest
     */
    minimalTransferOutAmount: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentMethodRequest
     */
    minimalExchangeAmount: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    subCurrencyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    subCurrencySymbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdatePaymentMethodRequest
     */
    subCurrencyValue?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePaymentMethodRequest
     */
    regionIds?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePaymentMethodRequest
     */
    isDeleted?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdatePhysicalWalletPlanRequest
 */
export interface UpdatePhysicalWalletPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePhysicalWalletPlanRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePhysicalWalletPlanRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdatePhysicalWalletPlanRequest
     */
    price: number;
}
/**
 * 
 * @export
 * @interface UpdatePhysicalWalletTierRequest
 */
export interface UpdatePhysicalWalletTierRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePhysicalWalletTierRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePhysicalWalletTierRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdatePhysicalWalletTierRequest
     */
    ordering?: number;
}
/**
 * 
 * @export
 * @interface UpdateRegionRequest
 */
export interface UpdateRegionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRegionRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegionRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegionRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegionRequest
     */
    primaryCurrencyId: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRegionRequest
     */
    isDeleted?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSettingsRequest
 */
export interface UpdateSettingsRequest {
    /**
     * 
     * @type {SystemSettingsDto}
     * @memberof UpdateSettingsRequest
     */
    settings?: SystemSettingsDto;
}
/**
 * 
 * @export
 * @interface UpdateWalletTypeRequest
 */
export interface UpdateWalletTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWalletTypeRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWalletTypeRequest
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface UploadedFile
 */
export interface UploadedFile {
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    fileName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    contentType?: string | null;
    /**
     * 
     * @type {Stream}
     * @memberof UploadedFile
     */
    stream?: Stream;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    tmpFile?: string | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    applicationInstanceId?: string;
    /**
     * 
     * @type {ApplicationInstance}
     * @memberof User
     */
    application?: ApplicationInstance;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    position?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nickName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    showNickname?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    imageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    login?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedEmail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedMobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    pin?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    salt?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    clientPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    clientBiometricPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    serverPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    serverPrivateKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    address1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    address2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    zipcode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    regionId?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof User
     */
    region?: Region;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {RoleValues}
     * @memberof User
     */
    role?: RoleValues;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    applicationRole?: string | null;
    /**
     * 
     * @type {UserStatusValues}
     * @memberof User
     */
    status?: UserStatusValues;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    emailOTP?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    emailOTPLastSent?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    referral?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isMobileVerified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isTempPassword?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    hasBioMetricKey?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    hasMainBankAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    contactVia?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    publicURI?: string | null;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    longitude?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {Array<Wallet>}
     * @memberof User
     */
    wallets?: Array<Wallet> | null;
    /**
     * 
     * @type {Array<Device>}
     * @memberof User
     */
    devices?: Array<Device> | null;
    /**
     * 
     * @type {Array<StickerPerso>}
     * @memberof User
     */
    stickers?: Array<StickerPerso> | null;
    /**
     * 
     * @type {Array<VenueUser>}
     * @memberof User
     */
    venues?: Array<VenueUser> | null;
    /**
     * 
     * @type {Array<RequestAnonymousFund>}
     * @memberof User
     */
    requestAnonymousFunds?: Array<RequestAnonymousFund> | null;
    /**
     * 
     * @type {Array<RequestUserFund>}
     * @memberof User
     */
    requestUserFundsBySendUser?: Array<RequestUserFund> | null;
    /**
     * 
     * @type {Array<RequestUserFund>}
     * @memberof User
     */
    requestUserFundsByReceiveUser?: Array<RequestUserFund> | null;
    /**
     * 
     * @type {Array<UserChat>}
     * @memberof User
     */
    user1Chats?: Array<UserChat> | null;
    /**
     * 
     * @type {Array<UserChat>}
     * @memberof User
     */
    user2Chats?: Array<UserChat> | null;
    /**
     * 
     * @type {Array<UserContact>}
     * @memberof User
     */
    users?: Array<UserContact> | null;
    /**
     * 
     * @type {Array<UserContact>}
     * @memberof User
     */
    contacts?: Array<UserContact> | null;
    /**
     * 
     * @type {PaymentMethodInstanceSetting}
     * @memberof User
     */
    paymentMethodInstanceSetting?: PaymentMethodInstanceSetting;
    /**
     * 
     * @type {Array<PhysicalWallet>}
     * @memberof User
     */
    physicalWallets?: Array<PhysicalWallet> | null;
    /**
     * 
     * @type {Kyc}
     * @memberof User
     */
    kyc?: Kyc;
    /**
     * 
     * @type {Array<Kyc>}
     * @memberof User
     */
    checkByKycs?: Array<Kyc> | null;
    /**
     * 
     * @type {Array<KycHistory>}
     * @memberof User
     */
    kycHistories?: Array<KycHistory> | null;
    /**
     * 
     * @type {Array<KycHistory>}
     * @memberof User
     */
    checkByKycHistories?: Array<KycHistory> | null;
}
/**
 * 
 * @export
 * @interface UserChat
 */
export interface UserChat {
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserChat
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    user1Id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserChat
     */
    user1?: User;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    user2Id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserChat
     */
    user2?: User;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    message?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserChat
     */
    user1Read?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserChat
     */
    user2Read?: boolean;
    /**
     * 
     * @type {ChatMessageTypeValues}
     * @memberof UserChat
     */
    type?: ChatMessageTypeValues;
    /**
     * 
     * @type {string}
     * @memberof UserChat
     */
    additionalInfo?: string | null;
}
/**
 * 
 * @export
 * @interface UserChatDto
 */
export interface UserChatDto {
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    user1Id: string;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    user2Id: string;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    message: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserChatDto
     */
    user1Read: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserChatDto
     */
    user2Read: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    userChatSessionId?: string | null;
    /**
     * 
     * @type {ChatMessageTypeValues}
     * @memberof UserChatDto
     */
    type?: ChatMessageTypeValues;
    /**
     * 
     * @type {string}
     * @memberof UserChatDto
     */
    additionalInfo?: string | null;
}
/**
 * 
 * @export
 * @interface UserContact
 */
export interface UserContact {
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserContact
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    contactUserId?: string;
    /**
     * 
     * @type {User}
     * @memberof UserContact
     */
    contact?: User;
    /**
     * 
     * @type {string}
     * @memberof UserContact
     */
    nickName?: string | null;
}
/**
 * 
 * @export
 * @interface UserProfileDto
 */
export interface UserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    nickName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDto
     */
    imageURL?: string | null;
}
/**
 * 
 * @export
 * @interface UserSanatizeDto
 */
export interface UserSanatizeDto {
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    applicationInstanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    position?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    middleName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    fullName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    nickName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    showNickname?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    updatedEmail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    updatedMobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    clientPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    clientBiometricPublicKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    address1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    address2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    houseNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    postcode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    city?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    state?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    regionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {RoleValues}
     * @memberof UserSanatizeDto
     */
    role: RoleValues;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    applicationRole?: string | null;
    /**
     * 
     * @type {UserStatusValues}
     * @memberof UserSanatizeDto
     */
    status: UserStatusValues;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    mobileNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    countryCode?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    isMobileVerified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    isEmailVerified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    isTempPassword?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    hasBioMetricKey?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    hasMainBankAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    contactVia?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSanatizeDto
     */
    publicURI?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSanatizeDto
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSanatizeDto
     */
    longitude?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSanatizeDto
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {Array<WalletDto>}
     * @memberof UserSanatizeDto
     */
    wallets?: Array<WalletDto> | null;
    /**
     * 
     * @type {Array<DeviceDto>}
     * @memberof UserSanatizeDto
     */
    devices?: Array<DeviceDto> | null;
    /**
     * 
     * @type {Array<StickerPersoDto>}
     * @memberof UserSanatizeDto
     */
    stickers?: Array<StickerPersoDto> | null;
    /**
     * 
     * @type {Array<VenueUserDto>}
     * @memberof UserSanatizeDto
     */
    venues?: Array<VenueUserDto> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum UserStatusValues {
    InActive = 'InActive',
    Active = 'Active',
    Blocked = 'Blocked',
    UnVerifiedSms = 'UnVerifiedSMS',
    UnVerifiedEmail = 'UnVerifiedEmail',
    ExpectingPassword = 'ExpectingPassword',
    SignUp = 'SignUp',
    Order = 'Order',
    UnVerifiedEmail2 = 'UnVerifiedEmail2',
    UnVerifiedSms2 = 'UnVerifiedSMS2',
    ExpectingPassword2 = 'ExpectingPassword2'
}

/**
 * 
 * @export
 * @interface UserVerifySmsDto
 */
export interface UserVerifySmsDto {
    /**
     * 
     * @type {boolean}
     * @memberof UserVerifySmsDto
     */
    isUserExists: boolean;
}
/**
 * 
 * @export
 * @interface ValidateDynamicPhysicalWalletPanResultDto
 */
export interface ValidateDynamicPhysicalWalletPanResultDto {
    /**
     * 
     * @type {PhysicalWalletValidateStatus}
     * @memberof ValidateDynamicPhysicalWalletPanResultDto
     */
    status: PhysicalWalletValidateStatus;
}
/**
 * 
 * @export
 * @interface ValidatePhysicalWalletDynamicCvcRequest
 */
export interface ValidatePhysicalWalletDynamicCvcRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicCvcRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicCvcRequest
     */
    cvc: string;
    /**
     * 
     * @type {number}
     * @memberof ValidatePhysicalWalletDynamicCvcRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface ValidatePhysicalWalletDynamicExpiryRequest
 */
export interface ValidatePhysicalWalletDynamicExpiryRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicExpiryRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicExpiryRequest
     */
    expiry: string;
    /**
     * 
     * @type {number}
     * @memberof ValidatePhysicalWalletDynamicExpiryRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface ValidatePhysicalWalletDynamicPanRequest
 */
export interface ValidatePhysicalWalletDynamicPanRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicPanRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicPanRequest
     */
    pan: string;
    /**
     * 
     * @type {number}
     * @memberof ValidatePhysicalWalletDynamicPanRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface ValidatePhysicalWalletDynamicPinRequest
 */
export interface ValidatePhysicalWalletDynamicPinRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicPinRequest
     */
    physicalWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatePhysicalWalletDynamicPinRequest
     */
    pin: string;
    /**
     * 
     * @type {number}
     * @memberof ValidatePhysicalWalletDynamicPinRequest
     */
    functionNumber: number;
}
/**
 * 
 * @export
 * @interface Venue
 */
export interface Venue {
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    isValidated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    addressId?: string;
    /**
     * 
     * @type {Address}
     * @memberof Venue
     */
    address?: Address;
    /**
     * 
     * @type {boolean}
     * @memberof Venue
     */
    policyActive?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Venue
     */
    minimumPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Venue
     */
    distributedPercentage?: number;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    lockVenueUntil?: string;
    /**
     * 
     * @type {Array<VenueUser>}
     * @memberof Venue
     */
    users?: Array<VenueUser> | null;
}
/**
 * 
 * @export
 * @interface VenueDto
 */
export interface VenueDto {
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDto
     */
    isValidated: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDto
     */
    isActive: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    addressId: string;
    /**
     * 
     * @type {AddressDto}
     * @memberof VenueDto
     */
    address?: AddressDto;
    /**
     * 
     * @type {boolean}
     * @memberof VenueDto
     */
    policyActive?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VenueDto
     */
    minimumPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueDto
     */
    distributedPercentage?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    lockVenueUntil?: string;
}
/**
 * 
 * @export
 * @interface VenueUser
 */
export interface VenueUser {
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUser
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    venueId?: string;
    /**
     * 
     * @type {Venue}
     * @memberof VenueUser
     */
    venue?: Venue;
    /**
     * 
     * @type {TipseeRoleValues}
     * @memberof VenueUser
     */
    role?: TipseeRoleValues;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUser
     */
    showNickname?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUser
     */
    isActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUser
     */
    isValidated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUser
     */
    isWorking?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VenueUser
     */
    hours?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueUser
     */
    minutes?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    workingSince?: string;
    /**
     * 
     * @type {number}
     * @memberof VenueUser
     */
    pendingTipAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueUser
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface VenueUserDto
 */
export interface VenueUserDto {
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    venueId: string;
    /**
     * 
     * @type {TipseeRoleValues}
     * @memberof VenueUserDto
     */
    role: TipseeRoleValues;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserDto
     */
    showNickname: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserDto
     */
    isActive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserDto
     */
    isValidated: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserDto
     */
    isWorking: boolean;
    /**
     * 
     * @type {number}
     * @memberof VenueUserDto
     */
    hours: number;
    /**
     * 
     * @type {number}
     * @memberof VenueUserDto
     */
    minutes: number;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    workingSince?: string;
    /**
     * 
     * @type {number}
     * @memberof VenueUserDto
     */
    pendingTipAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    comments?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueUserDto
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface VenueUserProfileDto
 */
export interface VenueUserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof VenueUserProfileDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUserProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof VenueUserProfileDto
     */
    nickName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueUserProfileDto
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VenueUserProfileDto
     */
    prepaidId?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserProfileDto
     */
    isValidated: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserProfileDto
     */
    isWorking: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VenueUserProfileDto
     */
    isActive: boolean;
}
/**
 * 
 * @export
 * @interface VerifyEmailCodeRequest
 */
export interface VerifyEmailCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailCodeRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailCodeRequest
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface VerifyKycDocumentResultDto
 */
export interface VerifyKycDocumentResultDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyKycDocumentResultDto
     */
    kycId: string;
    /**
     * 
     * @type {KycLevelValues}
     * @memberof VerifyKycDocumentResultDto
     */
    level?: KycLevelValues;
    /**
     * 
     * @type {KycStatusValues}
     * @memberof VerifyKycDocumentResultDto
     */
    status?: KycStatusValues;
}
/**
 * 
 * @export
 * @interface VerifyMobileRequest
 */
export interface VerifyMobileRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyMobileRequest
     */
    mobileNumber: string;
}
/**
 * 
 * @export
 * @interface VerifySMSRequest
 */
export interface VerifySMSRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifySMSRequest
     */
    mobileNumber: string;
    /**
     * 
     * @type {string}
     * @memberof VerifySMSRequest
     */
    pin: string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Wallet
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    selectedPaymentMethodPaymentMethodInstanceId?: string | null;
    /**
     * 
     * @type {PaymentMethodInstance}
     * @memberof Wallet
     */
    selectedPaymentMethod?: PaymentMethodInstance;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    mainBankAccountPaymentMethodInstanceId?: string | null;
    /**
     * 
     * @type {PaymentMethodInstance}
     * @memberof Wallet
     */
    mainBankAccount?: PaymentMethodInstance;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    userId?: string;
    /**
     * 
     * @type {Array<PaymentMethodInstance>}
     * @memberof Wallet
     */
    paymentMethods?: Array<PaymentMethodInstance> | null;
}
/**
 * 
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    cardId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    selectedPaymentMethodPaymentMethodInstanceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    mainBankAccountPaymentMethodInstanceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletDto
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface WalletType
 */
export interface WalletType {
    /**
     * 
     * @type {string}
     * @memberof WalletType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletType
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletType
     */
    updated?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WalletType
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WalletType
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletType
     */
    description?: string | null;
    /**
     * 
     * @type {Array<PhysicalWalletType>}
     * @memberof WalletType
     */
    physicalWalletTypes?: Array<PhysicalWalletType> | null;
}
/**
 * 
 * @export
 * @interface WalletTypeDto
 */
export interface WalletTypeDto {
    /**
     * 
     * @type {string}
     * @memberof WalletTypeDto
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTypeDto
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTypeDto
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTypeDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTypeDto
     */
    description?: string | null;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete direct debit
         * @param {string} accountId 
         * @param {string} directDebitId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDirectDebit: async (accountId: string, directDebitId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteDirectDebit', 'accountId', accountId)
            // verify required parameter 'directDebitId' is not null or undefined
            assertParamExists('deleteDirectDebit', 'directDebitId', directDebitId)
            const localVarPath = `/accounts/{account_id}/direct-debits/{direct_debit_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"direct_debit_id"}}`, encodeURIComponent(String(directDebitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete standing order
         * @param {string} accountId 
         * @param {string} standingOrderId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStandingOrder: async (accountId: string, standingOrderId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteStandingOrder', 'accountId', accountId)
            // verify required parameter 'standingOrderId' is not null or undefined
            assertParamExists('deleteStandingOrder', 'standingOrderId', standingOrderId)
            const localVarPath = `/accounts/{account_id}/standing-orders/{standing_order_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"standing_order_id"}}`, encodeURIComponent(String(standingOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balance
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalance: async (accountId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBalance', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/balance`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions: async (accountId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTransactions', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct debits
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDebits: async (accountId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getDirectDebits', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/direct-debits`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payees
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayees: async (accountId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPayees', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/payees`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save new payee
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {CreatePayeeRequestDto} [createPayeeRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveNewPayee: async (accountId: string, xJwsSignature?: string, xUserIp?: string, createPayeeRequestDto?: CreatePayeeRequestDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('saveNewPayee', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/payees`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPayeeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get standing orders
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standingOrders: async (accountId: string, xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('standingOrders', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/standing-orders`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete direct debit
         * @param {string} accountId 
         * @param {string} directDebitId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDirectDebit(accountId: string, directDebitId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDirectDebit(accountId, directDebitId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete standing order
         * @param {string} accountId 
         * @param {string} standingOrderId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStandingOrder(accountId: string, standingOrderId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStandingOrder(accountId, standingOrderId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get balance
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBalance(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBalance(accountId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactions(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactions(accountId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get direct debits
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectDebits(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectDebits(accountId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payees
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayees(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayees(accountId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save new payee
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {CreatePayeeRequestDto} [createPayeeRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveNewPayee(accountId: string, xJwsSignature?: string, xUserIp?: string, createPayeeRequestDto?: CreatePayeeRequestDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveNewPayee(accountId, xJwsSignature, xUserIp, createPayeeRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get standing orders
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async standingOrders(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.standingOrders(accountId, xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete direct debit
         * @param {string} accountId 
         * @param {string} directDebitId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDirectDebit(accountId: string, directDebitId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDirectDebit(accountId, directDebitId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete standing order
         * @param {string} accountId 
         * @param {string} standingOrderId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStandingOrder(accountId: string, standingOrderId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStandingOrder(accountId, standingOrderId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balance
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalance(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAccountBalance(accountId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAccountTransactions(accountId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get direct debits
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDebits(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getDirectDebits(accountId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payees
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayees(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getPayees(accountId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save new payee
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {CreatePayeeRequestDto} [createPayeeRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveNewPayee(accountId: string, xJwsSignature?: string, xUserIp?: string, createPayeeRequestDto?: CreatePayeeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.saveNewPayee(accountId, xJwsSignature, xUserIp, createPayeeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get standing orders
         * @param {string} accountId 
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standingOrders(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.standingOrders(accountId, xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @summary Delete direct debit
     * @param {string} accountId 
     * @param {string} directDebitId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteDirectDebit(accountId: string, directDebitId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).deleteDirectDebit(accountId, directDebitId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete standing order
     * @param {string} accountId 
     * @param {string} standingOrderId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteStandingOrder(accountId: string, standingOrderId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).deleteStandingOrder(accountId, standingOrderId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balance
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountBalance(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountBalance(accountId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transactions
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountTransactions(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountTransactions(accountId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get direct debits
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getDirectDebits(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).getDirectDebits(accountId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payees
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getPayees(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).getPayees(accountId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save new payee
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {CreatePayeeRequestDto} [createPayeeRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public saveNewPayee(accountId: string, xJwsSignature?: string, xUserIp?: string, createPayeeRequestDto?: CreatePayeeRequestDto, options?: any) {
        return AccountsApiFp(this.configuration).saveNewPayee(accountId, xJwsSignature, xUserIp, createPayeeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get standing orders
     * @param {string} accountId 
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public standingOrders(accountId: string, xJwsSignature?: string, xUserIp?: string, options?: any) {
        return AccountsApiFp(this.configuration).standingOrders(accountId, xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtain access token
         * @param {string} [xJwsSignature] 
         * @param {string} [grantType] 
         * @param {string} [code] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessToken: async (xJwsSignature?: string, grantType?: string, code?: string, refreshToken?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }


            if (grantType !== undefined) { 
                localVarFormParams.append('grant_type', grantType as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.append('code', code as any);
            }
    
            if (refreshToken !== undefined) { 
                localVarFormParams.append('refresh_token', refreshToken as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xJwsSignature] 
         * @param {AuthorizeBodyRequest} [authorizeBodyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorise: async (xJwsSignature?: string, authorizeBodyRequest?: AuthorizeBodyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/authorise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizeBodyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Obtain access token
         * @param {string} [xJwsSignature] 
         * @param {string} [grantType] 
         * @param {string} [code] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessToken(xJwsSignature?: string, grantType?: string, code?: string, refreshToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessToken(xJwsSignature, grantType, code, refreshToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [xJwsSignature] 
         * @param {AuthorizeBodyRequest} [authorizeBodyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorise(xJwsSignature?: string, authorizeBodyRequest?: AuthorizeBodyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorise(xJwsSignature, authorizeBodyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Obtain access token
         * @param {string} [xJwsSignature] 
         * @param {string} [grantType] 
         * @param {string} [code] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessToken(xJwsSignature?: string, grantType?: string, code?: string, refreshToken?: string, options?: any): AxiosPromise<void> {
            return localVarFp.accessToken(xJwsSignature, grantType, code, refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [xJwsSignature] 
         * @param {AuthorizeBodyRequest} [authorizeBodyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorise(xJwsSignature?: string, authorizeBodyRequest?: AuthorizeBodyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authorise(xJwsSignature, authorizeBodyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Obtain access token
     * @param {string} [xJwsSignature] 
     * @param {string} [grantType] 
     * @param {string} [code] 
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public accessToken(xJwsSignature?: string, grantType?: string, code?: string, refreshToken?: string, options?: any) {
        return AuthApiFp(this.configuration).accessToken(xJwsSignature, grantType, code, refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [xJwsSignature] 
     * @param {AuthorizeBodyRequest} [authorizeBodyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authorise(xJwsSignature?: string, authorizeBodyRequest?: AuthorizeBodyRequest, options?: any) {
        return AuthApiFp(this.configuration).authorise(xJwsSignature, authorizeBodyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get messages sent from one user contact
         * @param {string} withUserId user contact id
         * @param {string} [fromMessageId] message id which sent from user contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (withUserId: string, fromMessageId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withUserId' is not null or undefined
            assertParamExists('getMessages', 'withUserId', withUserId)
            const localVarPath = `/api/v1/chat/getmessages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withUserId !== undefined) {
                localVarQueryParameter['withUserId'] = withUserId;
            }

            if (fromMessageId !== undefined) {
                localVarQueryParameter['fromMessageId'] = fromMessageId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read message receive
         * @param {ReadMessageRequest} [readMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessage: async (readMessageRequest?: ReadMessageRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/readmessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send message to user
         * @param {SendMessageRequest} [sendMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageRequest?: SendMessageRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/sendmessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get messages sent from one user contact
         * @param {string} withUserId user contact id
         * @param {string} [fromMessageId] message id which sent from user contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(withUserId: string, fromMessageId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetMessagesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessages(withUserId, fromMessageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read message receive
         * @param {ReadMessageRequest} [readMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMessage(readMessageRequest?: ReadMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessReadMessageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMessage(readMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary send message to user
         * @param {SendMessageRequest} [sendMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageRequest?: SendMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendMessageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * 
         * @summary Get messages sent from one user contact
         * @param {string} withUserId user contact id
         * @param {string} [fromMessageId] message id which sent from user contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(withUserId: string, fromMessageId?: string, options?: any): AxiosPromise<SuccessGetMessagesDto> {
            return localVarFp.getMessages(withUserId, fromMessageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read message receive
         * @param {ReadMessageRequest} [readMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessage(readMessageRequest?: ReadMessageRequest, options?: any): AxiosPromise<SuccessReadMessageDto> {
            return localVarFp.readMessage(readMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send message to user
         * @param {SendMessageRequest} [sendMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageRequest?: SendMessageRequest, options?: any): AxiosPromise<SuccessSendMessageDto> {
            return localVarFp.sendMessage(sendMessageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * 
     * @summary Get messages sent from one user contact
     * @param {string} withUserId user contact id
     * @param {string} [fromMessageId] message id which sent from user contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getMessages(withUserId: string, fromMessageId?: string, options?: any) {
        return ChatApiFp(this.configuration).getMessages(withUserId, fromMessageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read message receive
     * @param {ReadMessageRequest} [readMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public readMessage(readMessageRequest?: ReadMessageRequest, options?: any) {
        return ChatApiFp(this.configuration).readMessage(readMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send message to user
     * @param {SendMessageRequest} [sendMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public sendMessage(sendMessageRequest?: SendMessageRequest, options?: any) {
        return ChatApiFp(this.configuration).sendMessage(sendMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute payment
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment: async (xJwsSignature?: string, xUserIp?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xJwsSignature !== undefined && xJwsSignature !== null) {
                localVarHeaderParameter['x_jws_signature'] = String(xJwsSignature);
            }

            if (xUserIp !== undefined && xUserIp !== null) {
                localVarHeaderParameter['x_user_ip'] = String(xUserIp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute payment
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payment(xJwsSignature?: string, xUserIp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payment(xJwsSignature, xUserIp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute payment
         * @param {string} [xJwsSignature] 
         * @param {string} [xUserIp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payment(xJwsSignature?: string, xUserIp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.payment(xJwsSignature, xUserIp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Execute payment
     * @param {string} [xJwsSignature] 
     * @param {string} [xUserIp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public payment(xJwsSignature?: string, xUserIp?: string, options?: any) {
        return PaymentsApiFp(this.configuration).payment(xJwsSignature, xUserIp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhysicalWalletApi - axios parameter creator
 * @export
 */
export const PhysicalWalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CancelPreAuthPhysicalWalletRequest} [cancelPreAuthPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPreAuthPhysicalWallet: async (cancelPreAuthPhysicalWalletRequest?: CancelPreAuthPhysicalWalletRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/cancelpreauthphysicalwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelPreAuthPhysicalWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClearPhysicalWalletPaymentMethodRequest} [clearPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearPhysicalWalletPaymentMethod: async (clearPhysicalWalletPaymentMethodRequest?: ClearPhysicalWalletPaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/clearphysicalwalletpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clearPhysicalWalletPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConfigurePreAuthRequest} [configurePreAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configPhysicalWalletPreAuth: async (configurePreAuthRequest?: ConfigurePreAuthRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/configphysicalwalletpreauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurePreAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a physical wallet (can be virtual or real scheme cards, chip stickers, ScamCards etc).
         * @param {CreatePhysicalWalletRequest} [createPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWallet: async (createPhysicalWalletRequest?: CreatePhysicalWalletRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/createphysicalwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPhysicalWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Destroy physicalWallet (cannot be undone)
         * @param {DestroyPhysicalWalletRequest} [destroyPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPhysicalWallet: async (destroyPhysicalWalletRequest?: DestroyPhysicalWalletRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/destroyphysicalwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destroyPhysicalWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finish setup physicalWallet.If this fails, the user needs to call /set-up-physicalWallet again. Upon success, this cannot be called with the same physicalWallet again.
         * @param {FinishSetupPhysicalWalletRequest} [finishSetupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishSetupPhysicalWallet: async (finishSetupPhysicalWalletRequest?: FinishSetupPhysicalWalletRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/finishsetupphysicalwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finishSetupPhysicalWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletCvc: async (physicalWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletCvc', 'physicalWalletId', physicalWalletId)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletcvc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicCvc: async (physicalWalletId: string, functionNumber: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicCvc', 'physicalWalletId', physicalWalletId)
            // verify required parameter 'functionNumber' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicCvc', 'functionNumber', functionNumber)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletdynamiccvc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }

            if (functionNumber !== undefined) {
                localVarQueryParameter['functionNumber'] = functionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet Expiry date if applicable; this function will not   work Physical Wallets that can generate their own Expiry/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicExpiry: async (physicalWalletId: string, functionNumber: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicExpiry', 'physicalWalletId', physicalWalletId)
            // verify required parameter 'functionNumber' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicExpiry', 'functionNumber', functionNumber)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletdynamicexpiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }

            if (functionNumber !== undefined) {
                localVarQueryParameter['functionNumber'] = functionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PAN if applicable; this function will not   work Physical Wallets that can generate their own PAN.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicPan: async (physicalWalletId: string, functionNumber: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicPan', 'physicalWalletId', physicalWalletId)
            // verify required parameter 'functionNumber' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicPan', 'functionNumber', functionNumber)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletdynamicpan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }

            if (functionNumber !== undefined) {
                localVarQueryParameter['functionNumber'] = functionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PIN if applicable; this function will not   work Physical Wallets that can generate their own PIN/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicPin: async (physicalWalletId: string, functionNumber: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicPin', 'physicalWalletId', physicalWalletId)
            // verify required parameter 'functionNumber' is not null or undefined
            assertParamExists('getPhysicalWalletDynamicPin', 'functionNumber', functionNumber)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletdynamicpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }

            if (functionNumber !== undefined) {
                localVarQueryParameter['functionNumber'] = functionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get physicalWallet expiry date
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletExpiry: async (physicalWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletExpiry', 'physicalWalletId', physicalWalletId)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletexpiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the PAN (or other secret \'address\' for a physical wallet)   for this physical wallet.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPan: async (physicalWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletPan', 'physicalWalletId', physicalWalletId)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletpan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Physical Wallet PIN if applicable.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPin: async (physicalWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletPin', 'physicalWalletId', physicalWalletId)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPreAuth: async (physicalWalletId: string, functionNumber: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletPreAuth', 'physicalWalletId', physicalWalletId)
            // verify required parameter 'functionNumber' is not null or undefined
            assertParamExists('getPhysicalWalletPreAuth', 'functionNumber', functionNumber)
            const localVarPath = `/api/v1/physicalwallet/getphysicalwalletpreauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }

            if (functionNumber !== undefined) {
                localVarQueryParameter['functionNumber'] = functionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTiers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/getphysicalwallettiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Physical Wallets for the user attached to the sessionToken.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWallets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/getphysicalwallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets or overwrites the payment method on any physicalWallet.
         * @param {SetPhysicalWalletPaymentMethodRequest} [setPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhysicalWalletPaymentMethod: async (setPhysicalWalletPaymentMethodRequest?: SetPhysicalWalletPaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/setphysicalwalletpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPhysicalWalletPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set physicalWallet status
         * @param {SetPhysicalWalletStatusRequest} [setPhysicalWalletStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhysicalWalletStatus: async (setPhysicalWalletStatusRequest?: SetPhysicalWalletStatusRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/setphysicalwalletstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPhysicalWalletStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup physicalWallet
         * @param {SetupPhysicalWalletRequest} [setupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPhysicalWallet: async (setupPhysicalWalletRequest?: SetupPhysicalWalletRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/setupphysicalwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupPhysicalWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the dynamic CVV entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicCvcRequest} [validatePhysicalWalletDynamicCvcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicCvc: async (validatePhysicalWalletDynamicCvcRequest?: ValidatePhysicalWalletDynamicCvcRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/validatephysicalwalletdynamiccvc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePhysicalWalletDynamicCvcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the dynamic Expiry Date entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicExpiryRequest} [validatePhysicalWalletDynamicExpiryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicExpiry: async (validatePhysicalWalletDynamicExpiryRequest?: ValidatePhysicalWalletDynamicExpiryRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/validatephysicalwalletdynamicexpiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePhysicalWalletDynamicExpiryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate a dynamic PAN    TODO: this seems useless
         * @param {ValidatePhysicalWalletDynamicPanRequest} [validatePhysicalWalletDynamicPanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicPan: async (validatePhysicalWalletDynamicPanRequest?: ValidatePhysicalWalletDynamicPanRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/validatephysicalwalletdynamicpan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePhysicalWalletDynamicPanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the dynamic PIN entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicPinRequest} [validatePhysicalWalletDynamicPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicPin: async (validatePhysicalWalletDynamicPinRequest?: ValidatePhysicalWalletDynamicPinRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/physicalwallet/validatephysicalwalletdynamicpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePhysicalWalletDynamicPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhysicalWalletApi - functional programming interface
 * @export
 */
export const PhysicalWalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhysicalWalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CancelPreAuthPhysicalWalletRequest} [cancelPreAuthPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest?: CancelPreAuthPhysicalWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClearPhysicalWalletPaymentMethodRequest} [clearPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest?: ClearPhysicalWalletPaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetPhysicalWalletPaymentMethodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConfigurePreAuthRequest} [configurePreAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configPhysicalWalletPreAuth(configurePreAuthRequest?: ConfigurePreAuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessConfigPhysicalWalletPreAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configPhysicalWalletPreAuth(configurePreAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a physical wallet (can be virtual or real scheme cards, chip stickers, ScamCards etc).
         * @param {CreatePhysicalWalletRequest} [createPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhysicalWallet(createPhysicalWalletRequest?: CreatePhysicalWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreatePhysicalWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhysicalWallet(createPhysicalWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Destroy physicalWallet (cannot be undone)
         * @param {DestroyPhysicalWalletRequest} [destroyPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPhysicalWallet(destroyPhysicalWalletRequest?: DestroyPhysicalWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPhysicalWallet(destroyPhysicalWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finish setup physicalWallet.If this fails, the user needs to call /set-up-physicalWallet again. Upon success, this cannot be called with the same physicalWallet again.
         * @param {FinishSetupPhysicalWalletRequest} [finishSetupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest?: FinishSetupPhysicalWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletCvc(physicalWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletCvcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletCvc(physicalWalletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletDynamicCvc(physicalWalletId: string, functionNumber: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletDynamicCvcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletDynamicCvc(physicalWalletId, functionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet Expiry date if applicable; this function will not   work Physical Wallets that can generate their own Expiry/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletDynamicExpiry(physicalWalletId: string, functionNumber: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletDynamicExpiryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletDynamicExpiry(physicalWalletId, functionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PAN if applicable; this function will not   work Physical Wallets that can generate their own PAN.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletDynamicPan(physicalWalletId: string, functionNumber: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletDynamicPanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletDynamicPan(physicalWalletId, functionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PIN if applicable; this function will not   work Physical Wallets that can generate their own PIN/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletDynamicPin(physicalWalletId: string, functionNumber: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletDynamicPinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletDynamicPin(physicalWalletId, functionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get physicalWallet expiry date
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletExpiry(physicalWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletExpiryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletExpiry(physicalWalletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the PAN (or other secret \'address\' for a physical wallet)   for this physical wallet.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPan(physicalWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletPanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPan(physicalWalletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Physical Wallet PIN if applicable.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPin(physicalWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletPinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPin(physicalWalletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPreAuth(physicalWalletId: string, functionNumber: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletPreAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPreAuth(physicalWalletId, functionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletTiers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPhysicalWalletTiersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletTiers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Physical Wallets for the user attached to the sessionToken.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWallets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepPhysicalWalletDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWallets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets or overwrites the payment method on any physicalWallet.
         * @param {SetPhysicalWalletPaymentMethodRequest} [setPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest?: SetPhysicalWalletPaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetPhysicalWalletPaymentMethodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set physicalWallet status
         * @param {SetPhysicalWalletStatusRequest} [setPhysicalWalletStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPhysicalWalletStatus(setPhysicalWalletStatusRequest?: SetPhysicalWalletStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPhysicalWalletStatus(setPhysicalWalletStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Setup physicalWallet
         * @param {SetupPhysicalWalletRequest} [setupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupPhysicalWallet(setupPhysicalWalletRequest?: SetupPhysicalWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetupPhysicalWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupPhysicalWallet(setupPhysicalWalletRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate the dynamic CVV entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicCvcRequest} [validatePhysicalWalletDynamicCvcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest?: ValidatePhysicalWalletDynamicCvcRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate the dynamic Expiry Date entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicExpiryRequest} [validatePhysicalWalletDynamicExpiryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest?: ValidatePhysicalWalletDynamicExpiryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate a dynamic PAN    TODO: this seems useless
         * @param {ValidatePhysicalWalletDynamicPanRequest} [validatePhysicalWalletDynamicPanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest?: ValidatePhysicalWalletDynamicPanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessValidatePhysicalWalletDynamicPanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate the dynamic PIN entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicPinRequest} [validatePhysicalWalletDynamicPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest?: ValidatePhysicalWalletDynamicPinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhysicalWalletApi - factory interface
 * @export
 */
export const PhysicalWalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhysicalWalletApiFp(configuration)
    return {
        /**
         * 
         * @param {CancelPreAuthPhysicalWalletRequest} [cancelPreAuthPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest?: CancelPreAuthPhysicalWalletRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClearPhysicalWalletPaymentMethodRequest} [clearPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest?: ClearPhysicalWalletPaymentMethodRequest, options?: any): AxiosPromise<SuccessSetPhysicalWalletPaymentMethodResponse> {
            return localVarFp.clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConfigurePreAuthRequest} [configurePreAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configPhysicalWalletPreAuth(configurePreAuthRequest?: ConfigurePreAuthRequest, options?: any): AxiosPromise<SuccessConfigPhysicalWalletPreAuthResponse> {
            return localVarFp.configPhysicalWalletPreAuth(configurePreAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a physical wallet (can be virtual or real scheme cards, chip stickers, ScamCards etc).
         * @param {CreatePhysicalWalletRequest} [createPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWallet(createPhysicalWalletRequest?: CreatePhysicalWalletRequest, options?: any): AxiosPromise<SuccessCreatePhysicalWalletResponse> {
            return localVarFp.createPhysicalWallet(createPhysicalWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Destroy physicalWallet (cannot be undone)
         * @param {DestroyPhysicalWalletRequest} [destroyPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPhysicalWallet(destroyPhysicalWalletRequest?: DestroyPhysicalWalletRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.destroyPhysicalWallet(destroyPhysicalWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finish setup physicalWallet.If this fails, the user needs to call /set-up-physicalWallet again. Upon success, this cannot be called with the same physicalWallet again.
         * @param {FinishSetupPhysicalWalletRequest} [finishSetupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest?: FinishSetupPhysicalWalletRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletCvc(physicalWalletId: string, options?: any): AxiosPromise<SuccessGetPhysicalWalletCvcResponse> {
            return localVarFp.getPhysicalWalletCvc(physicalWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicCvc(physicalWalletId: string, functionNumber: number, options?: any): AxiosPromise<SuccessGetPhysicalWalletDynamicCvcResponse> {
            return localVarFp.getPhysicalWalletDynamicCvc(physicalWalletId, functionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet Expiry date if applicable; this function will not   work Physical Wallets that can generate their own Expiry/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicExpiry(physicalWalletId: string, functionNumber: number, options?: any): AxiosPromise<SuccessGetPhysicalWalletDynamicExpiryResponse> {
            return localVarFp.getPhysicalWalletDynamicExpiry(physicalWalletId, functionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PAN if applicable; this function will not   work Physical Wallets that can generate their own PAN.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicPan(physicalWalletId: string, functionNumber: number, options?: any): AxiosPromise<SuccessGetPhysicalWalletDynamicPanResponse> {
            return localVarFp.getPhysicalWalletDynamicPan(physicalWalletId, functionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Dynamic Wallet PIN if applicable; this function will not   work Physical Wallets that can generate their own PIN/OTP.
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletDynamicPin(physicalWalletId: string, functionNumber: number, options?: any): AxiosPromise<SuccessGetPhysicalWalletDynamicPinResponse> {
            return localVarFp.getPhysicalWalletDynamicPin(physicalWalletId, functionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get physicalWallet expiry date
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletExpiry(physicalWalletId: string, options?: any): AxiosPromise<SuccessGetPhysicalWalletExpiryResponse> {
            return localVarFp.getPhysicalWalletExpiry(physicalWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the PAN (or other secret \'address\' for a physical wallet)   for this physical wallet.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPan(physicalWalletId: string, options?: any): AxiosPromise<SuccessGetPhysicalWalletPanResponse> {
            return localVarFp.getPhysicalWalletPan(physicalWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Physical Wallet PIN if applicable.
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPin(physicalWalletId: string, options?: any): AxiosPromise<SuccessGetPhysicalWalletPinResponse> {
            return localVarFp.getPhysicalWalletPin(physicalWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {number} functionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPreAuth(physicalWalletId: string, functionNumber: number, options?: any): AxiosPromise<SuccessGetPhysicalWalletPreAuthResponse> {
            return localVarFp.getPhysicalWalletPreAuth(physicalWalletId, functionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTiers(options?: any): AxiosPromise<SuccessGetPhysicalWalletTiersResponse> {
            return localVarFp.getPhysicalWalletTiers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Physical Wallets for the user attached to the sessionToken.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWallets(options?: any): AxiosPromise<SuccessListDeepPhysicalWalletDtoResponse> {
            return localVarFp.getPhysicalWallets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets or overwrites the payment method on any physicalWallet.
         * @param {SetPhysicalWalletPaymentMethodRequest} [setPhysicalWalletPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest?: SetPhysicalWalletPaymentMethodRequest, options?: any): AxiosPromise<SuccessSetPhysicalWalletPaymentMethodResponse> {
            return localVarFp.setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set physicalWallet status
         * @param {SetPhysicalWalletStatusRequest} [setPhysicalWalletStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhysicalWalletStatus(setPhysicalWalletStatusRequest?: SetPhysicalWalletStatusRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.setPhysicalWalletStatus(setPhysicalWalletStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup physicalWallet
         * @param {SetupPhysicalWalletRequest} [setupPhysicalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPhysicalWallet(setupPhysicalWalletRequest?: SetupPhysicalWalletRequest, options?: any): AxiosPromise<SuccessSetupPhysicalWalletResponse> {
            return localVarFp.setupPhysicalWallet(setupPhysicalWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate the dynamic CVV entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicCvcRequest} [validatePhysicalWalletDynamicCvcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest?: ValidatePhysicalWalletDynamicCvcRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate the dynamic Expiry Date entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicExpiryRequest} [validatePhysicalWalletDynamicExpiryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest?: ValidatePhysicalWalletDynamicExpiryRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate a dynamic PAN    TODO: this seems useless
         * @param {ValidatePhysicalWalletDynamicPanRequest} [validatePhysicalWalletDynamicPanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest?: ValidatePhysicalWalletDynamicPanRequest, options?: any): AxiosPromise<SuccessValidatePhysicalWalletDynamicPanResponse> {
            return localVarFp.validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate the dynamic PIN entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
         * @param {ValidatePhysicalWalletDynamicPinRequest} [validatePhysicalWalletDynamicPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest?: ValidatePhysicalWalletDynamicPinRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhysicalWalletApi - object-oriented interface
 * @export
 * @class PhysicalWalletApi
 * @extends {BaseAPI}
 */
export class PhysicalWalletApi extends BaseAPI {
    /**
     * 
     * @param {CancelPreAuthPhysicalWalletRequest} [cancelPreAuthPhysicalWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest?: CancelPreAuthPhysicalWalletRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).cancelPreAuthPhysicalWallet(cancelPreAuthPhysicalWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClearPhysicalWalletPaymentMethodRequest} [clearPhysicalWalletPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest?: ClearPhysicalWalletPaymentMethodRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).clearPhysicalWalletPaymentMethod(clearPhysicalWalletPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfigurePreAuthRequest} [configurePreAuthRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public configPhysicalWalletPreAuth(configurePreAuthRequest?: ConfigurePreAuthRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).configPhysicalWalletPreAuth(configurePreAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a physical wallet (can be virtual or real scheme cards, chip stickers, ScamCards etc).
     * @param {CreatePhysicalWalletRequest} [createPhysicalWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public createPhysicalWallet(createPhysicalWalletRequest?: CreatePhysicalWalletRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).createPhysicalWallet(createPhysicalWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Destroy physicalWallet (cannot be undone)
     * @param {DestroyPhysicalWalletRequest} [destroyPhysicalWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public destroyPhysicalWallet(destroyPhysicalWalletRequest?: DestroyPhysicalWalletRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).destroyPhysicalWallet(destroyPhysicalWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finish setup physicalWallet.If this fails, the user needs to call /set-up-physicalWallet again. Upon success, this cannot be called with the same physicalWallet again.
     * @param {FinishSetupPhysicalWalletRequest} [finishSetupPhysicalWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest?: FinishSetupPhysicalWalletRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).finishSetupPhysicalWallet(finishSetupPhysicalWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
     * @param {string} physicalWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletCvc(physicalWalletId: string, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletCvc(physicalWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Dynamic Wallet CVV if applicable; this function will not   work Physical Wallets that can generate their own CVV/OTP.
     * @param {string} physicalWalletId 
     * @param {number} functionNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletDynamicCvc(physicalWalletId: string, functionNumber: number, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletDynamicCvc(physicalWalletId, functionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Dynamic Wallet Expiry date if applicable; this function will not   work Physical Wallets that can generate their own Expiry/OTP.
     * @param {string} physicalWalletId 
     * @param {number} functionNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletDynamicExpiry(physicalWalletId: string, functionNumber: number, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletDynamicExpiry(physicalWalletId, functionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Dynamic Wallet PAN if applicable; this function will not   work Physical Wallets that can generate their own PAN.
     * @param {string} physicalWalletId 
     * @param {number} functionNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletDynamicPan(physicalWalletId: string, functionNumber: number, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletDynamicPan(physicalWalletId, functionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Dynamic Wallet PIN if applicable; this function will not   work Physical Wallets that can generate their own PIN/OTP.
     * @param {string} physicalWalletId 
     * @param {number} functionNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletDynamicPin(physicalWalletId: string, functionNumber: number, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletDynamicPin(physicalWalletId, functionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get physicalWallet expiry date
     * @param {string} physicalWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletExpiry(physicalWalletId: string, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletExpiry(physicalWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the PAN (or other secret \'address\' for a physical wallet)   for this physical wallet.
     * @param {string} physicalWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletPan(physicalWalletId: string, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletPan(physicalWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Physical Wallet PIN if applicable.
     * @param {string} physicalWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletPin(physicalWalletId: string, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletPin(physicalWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} physicalWalletId 
     * @param {number} functionNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletPreAuth(physicalWalletId: string, functionNumber: number, options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletPreAuth(physicalWalletId, functionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWalletTiers(options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWalletTiers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Physical Wallets for the user attached to the sessionToken.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public getPhysicalWallets(options?: any) {
        return PhysicalWalletApiFp(this.configuration).getPhysicalWallets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets or overwrites the payment method on any physicalWallet.
     * @param {SetPhysicalWalletPaymentMethodRequest} [setPhysicalWalletPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest?: SetPhysicalWalletPaymentMethodRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).setPhysicalWalletPaymentMethod(setPhysicalWalletPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set physicalWallet status
     * @param {SetPhysicalWalletStatusRequest} [setPhysicalWalletStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public setPhysicalWalletStatus(setPhysicalWalletStatusRequest?: SetPhysicalWalletStatusRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).setPhysicalWalletStatus(setPhysicalWalletStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup physicalWallet
     * @param {SetupPhysicalWalletRequest} [setupPhysicalWalletRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public setupPhysicalWallet(setupPhysicalWalletRequest?: SetupPhysicalWalletRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).setupPhysicalWallet(setupPhysicalWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate the dynamic CVV entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
     * @param {ValidatePhysicalWalletDynamicCvcRequest} [validatePhysicalWalletDynamicCvcRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest?: ValidatePhysicalWalletDynamicCvcRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).validatePhysicalWalletDynamicCvc(validatePhysicalWalletDynamicCvcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate the dynamic Expiry Date entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
     * @param {ValidatePhysicalWalletDynamicExpiryRequest} [validatePhysicalWalletDynamicExpiryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest?: ValidatePhysicalWalletDynamicExpiryRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).validatePhysicalWalletDynamicExpiry(validatePhysicalWalletDynamicExpiryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate a dynamic PAN    TODO: this seems useless
     * @param {ValidatePhysicalWalletDynamicPanRequest} [validatePhysicalWalletDynamicPanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest?: ValidatePhysicalWalletDynamicPanRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).validatePhysicalWalletDynamicPan(validatePhysicalWalletDynamicPanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate the dynamic PIN entered into the system.   TODO: is this actually interesting or valid for Users? Only the processor will do this?
     * @param {ValidatePhysicalWalletDynamicPinRequest} [validatePhysicalWalletDynamicPinRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhysicalWalletApi
     */
    public validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest?: ValidatePhysicalWalletDynamicPinRequest, options?: any) {
        return PhysicalWalletApiFp(this.configuration).validatePhysicalWalletDynamicPin(validatePhysicalWalletDynamicPinRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecretApi - axios parameter creator
 * @export
 */
export const SecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPhysicalWalletExpiredPreAuths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/secret/cancelphysicalwalletexpiredpreauths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExcutePaymentRequest} [excutePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excutePayment: async (excutePaymentRequest?: ExcutePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/secret/excutepayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(excutePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyPhysicalWalletAlmostExpiredPreAuths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/secret/notifyphysicalwalletalmostexpiredpreauths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretApi - functional programming interface
 * @export
 */
export const SecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPhysicalWalletExpiredPreAuths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPhysicalWalletExpiredPreAuths(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExcutePaymentRequest} [excutePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excutePayment(excutePaymentRequest?: ExcutePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessExecutePaymentPhysicalWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excutePayment(excutePaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyPhysicalWalletAlmostExpiredPreAuths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyPhysicalWalletAlmostExpiredPreAuths(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecretApi - factory interface
 * @export
 */
export const SecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPhysicalWalletExpiredPreAuths(options?: any): AxiosPromise<void> {
            return localVarFp.cancelPhysicalWalletExpiredPreAuths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExcutePaymentRequest} [excutePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excutePayment(excutePaymentRequest?: ExcutePaymentRequest, options?: any): AxiosPromise<SuccessExecutePaymentPhysicalWalletResponse> {
            return localVarFp.excutePayment(excutePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyPhysicalWalletAlmostExpiredPreAuths(options?: any): AxiosPromise<void> {
            return localVarFp.notifyPhysicalWalletAlmostExpiredPreAuths(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecretApi - object-oriented interface
 * @export
 * @class SecretApi
 * @extends {BaseAPI}
 */
export class SecretApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretApi
     */
    public cancelPhysicalWalletExpiredPreAuths(options?: any) {
        return SecretApiFp(this.configuration).cancelPhysicalWalletExpiredPreAuths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExcutePaymentRequest} [excutePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretApi
     */
    public excutePayment(excutePaymentRequest?: ExcutePaymentRequest, options?: any) {
        return SecretApiFp(this.configuration).excutePayment(excutePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretApi
     */
    public notifyPhysicalWalletAlmostExpiredPreAuths(options?: any) {
        return SecretApiFp(this.configuration).notifyPhysicalWalletAlmostExpiredPreAuths(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StickerApi - axios parameter creator
 * @export
 */
export const StickerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate sticker
         * @param {ActivateRequest} [activateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (activateRequest?: ActivateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get activate sticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivatedSticker: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/getactivatedsticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get private and public keys with serial corresponding
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (serial: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serial' is not null or undefined
            assertParamExists('getKeys', 'serial', serial)
            const localVarPath = `/api/v1/sticker/getkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get perso serial
         * @param {string} [serial] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerso: async (serial?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/getperso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate sticker perso
         * @param {ReservePersoRequest} [reservePersoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservePerso: async (reservePersoRequest?: ReservePersoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/reserveperso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservePersoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signed
         * @param {SignedRequest} [signedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signed: async (signedRequest?: SignedRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/signed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo Signed
         * @param {UndoSignedRequest} [undoSignedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoSigned: async (undoSignedRequest?: UndoSignedRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/undosigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(undoSignedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update sticker perso with MacAddress,Signature,SignedPackage
         * @param {UpdateActivatedStickerRequest} [updateActivatedStickerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivatedSticker: async (updateActivatedStickerRequest?: UpdateActivatedStickerRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sticker/updateactivatedsticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateActivatedStickerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StickerApi - functional programming interface
 * @export
 */
export const StickerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StickerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate sticker
         * @param {ActivateRequest} [activateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(activateRequest?: ActivateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessActivateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activate(activateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get activate sticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivatedSticker(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetActivatedStickerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivatedSticker(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get private and public keys with serial corresponding
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(serial: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetKeysDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(serial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get perso serial
         * @param {string} [serial] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerso(serial?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPersoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerso(serial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate sticker perso
         * @param {ReservePersoRequest} [reservePersoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservePerso(reservePersoRequest?: ReservePersoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessReservePersoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservePerso(reservePersoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Signed
         * @param {SignedRequest} [signedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signed(signedRequest?: SignedRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSignedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signed(signedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undo Signed
         * @param {UndoSignedRequest} [undoSignedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoSigned(undoSignedRequest?: UndoSignedRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessUndoSignedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undoSigned(undoSignedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update sticker perso with MacAddress,Signature,SignedPackage
         * @param {UpdateActivatedStickerRequest} [updateActivatedStickerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivatedSticker(updateActivatedStickerRequest?: UpdateActivatedStickerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessUpdateActivatedStickerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivatedSticker(updateActivatedStickerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StickerApi - factory interface
 * @export
 */
export const StickerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StickerApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate sticker
         * @param {ActivateRequest} [activateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(activateRequest?: ActivateRequest, options?: any): AxiosPromise<SuccessActivateDto> {
            return localVarFp.activate(activateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get activate sticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivatedSticker(options?: any): AxiosPromise<SuccessGetActivatedStickerDto> {
            return localVarFp.getActivatedSticker(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get private and public keys with serial corresponding
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(serial: string, options?: any): AxiosPromise<SuccessGetKeysDto> {
            return localVarFp.getKeys(serial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get perso serial
         * @param {string} [serial] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerso(serial?: string, options?: any): AxiosPromise<SuccessGetPersoDto> {
            return localVarFp.getPerso(serial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate sticker perso
         * @param {ReservePersoRequest} [reservePersoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservePerso(reservePersoRequest?: ReservePersoRequest, options?: any): AxiosPromise<SuccessReservePersoDto> {
            return localVarFp.reservePerso(reservePersoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signed
         * @param {SignedRequest} [signedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signed(signedRequest?: SignedRequest, options?: any): AxiosPromise<SuccessSignedDto> {
            return localVarFp.signed(signedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undo Signed
         * @param {UndoSignedRequest} [undoSignedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoSigned(undoSignedRequest?: UndoSignedRequest, options?: any): AxiosPromise<SuccessUndoSignedDto> {
            return localVarFp.undoSigned(undoSignedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update sticker perso with MacAddress,Signature,SignedPackage
         * @param {UpdateActivatedStickerRequest} [updateActivatedStickerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivatedSticker(updateActivatedStickerRequest?: UpdateActivatedStickerRequest, options?: any): AxiosPromise<SuccessUpdateActivatedStickerDto> {
            return localVarFp.updateActivatedSticker(updateActivatedStickerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StickerApi - object-oriented interface
 * @export
 * @class StickerApi
 * @extends {BaseAPI}
 */
export class StickerApi extends BaseAPI {
    /**
     * 
     * @summary Activate sticker
     * @param {ActivateRequest} [activateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public activate(activateRequest?: ActivateRequest, options?: any) {
        return StickerApiFp(this.configuration).activate(activateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get activate sticker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public getActivatedSticker(options?: any) {
        return StickerApiFp(this.configuration).getActivatedSticker(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get private and public keys with serial corresponding
     * @param {string} serial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public getKeys(serial: string, options?: any) {
        return StickerApiFp(this.configuration).getKeys(serial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get perso serial
     * @param {string} [serial] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public getPerso(serial?: string, options?: any) {
        return StickerApiFp(this.configuration).getPerso(serial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate sticker perso
     * @param {ReservePersoRequest} [reservePersoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public reservePerso(reservePersoRequest?: ReservePersoRequest, options?: any) {
        return StickerApiFp(this.configuration).reservePerso(reservePersoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signed
     * @param {SignedRequest} [signedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public signed(signedRequest?: SignedRequest, options?: any) {
        return StickerApiFp(this.configuration).signed(signedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undo Signed
     * @param {UndoSignedRequest} [undoSignedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public undoSigned(undoSignedRequest?: UndoSignedRequest, options?: any) {
        return StickerApiFp(this.configuration).undoSigned(undoSignedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update sticker perso with MacAddress,Signature,SignedPackage
     * @param {UpdateActivatedStickerRequest} [updateActivatedStickerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickerApi
     */
    public updateActivatedSticker(updateActivatedStickerRequest?: UpdateActivatedStickerRequest, options?: any) {
        return StickerApiFp(this.configuration).updateActivatedSticker(updateActivatedStickerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuperAdminApi - axios parameter creator
 * @export
 */
export const SuperAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create currency
         * @param {CreateCurrencyRequest} [createCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency: async (createCurrencyRequest?: CreateCurrencyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createcurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create FeeDefinition
         * @param {CreateFeeDefinitionRequest} [createFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeDefinition: async (createFeeDefinitionRequest?: CreateFeeDefinitionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createfeedefinition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeeDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create PaymentMethod
         * @param {CreatePaymentMethodRequest} [createPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodByAdmin: async (createPaymentMethodRequest?: CreatePaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createpaymentmethodbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create physical wallet plan
         * @param {CreatePhysicalWalletPlanRequest} [createPhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletPlan: async (createPhysicalWalletPlanRequest?: CreatePhysicalWalletPlanRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createphysicalwalletplan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPhysicalWalletPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create physical wallet tier
         * @param {CreatePhysicalWalletTierRequest} [createPhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletTier: async (createPhysicalWalletTierRequest?: CreatePhysicalWalletTierRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createphysicalwallettier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPhysicalWalletTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create physical wallet type
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {string} [walletTypeId] 
         * @param {PhysicalWalletSchemeValues} [scheme] 
         * @param {boolean} [hasKeyboard] 
         * @param {boolean} [hasCvvDisplay] 
         * @param {boolean} [hasPinDisplay] 
         * @param {boolean} [hasPanDisplay] 
         * @param {boolean} [hasDynamicCvv] 
         * @param {boolean} [hasDynamicPan] 
         * @param {boolean} [hasDynamicPin] 
         * @param {boolean} [physicalAuth] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {string} [costCurrencyId] 
         * @param {string} [issuerName] 
         * @param {string} [physicalWalletTierId] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletType: async (name?: string, description?: string, image?: any, walletTypeId?: string, scheme?: PhysicalWalletSchemeValues, hasKeyboard?: boolean, hasCvvDisplay?: boolean, hasPinDisplay?: boolean, hasPanDisplay?: boolean, hasDynamicCvv?: boolean, hasDynamicPan?: boolean, hasDynamicPin?: boolean, physicalAuth?: boolean, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, costCurrencyId?: string, issuerName?: string, physicalWalletTierId?: string, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createphysicalwallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('Description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('Image', image as any);
            }
    
            if (walletTypeId !== undefined) { 
                localVarFormParams.append('WalletTypeId', new Blob([JSON.stringify(walletTypeId)], { type: "application/json", }));
            }
    
            if (scheme !== undefined) { 
                localVarFormParams.append('Scheme', new Blob([JSON.stringify(scheme)], { type: "application/json", }));
            }
    
            if (hasKeyboard !== undefined) { 
                localVarFormParams.append('HasKeyboard', hasKeyboard as any);
            }
    
            if (hasCvvDisplay !== undefined) { 
                localVarFormParams.append('HasCvvDisplay', hasCvvDisplay as any);
            }
    
            if (hasPinDisplay !== undefined) { 
                localVarFormParams.append('HasPinDisplay', hasPinDisplay as any);
            }
    
            if (hasPanDisplay !== undefined) { 
                localVarFormParams.append('HasPanDisplay', hasPanDisplay as any);
            }
    
            if (hasDynamicCvv !== undefined) { 
                localVarFormParams.append('HasDynamicCvv', hasDynamicCvv as any);
            }
    
            if (hasDynamicPan !== undefined) { 
                localVarFormParams.append('HasDynamicPan', hasDynamicPan as any);
            }
    
            if (hasDynamicPin !== undefined) { 
                localVarFormParams.append('HasDynamicPin', hasDynamicPin as any);
            }
    
            if (physicalAuth !== undefined) { 
                localVarFormParams.append('PhysicalAuth', physicalAuth as any);
            }
    
            if (material !== undefined) { 
                localVarFormParams.append('Material', material as any);
            }
    
            if (color !== undefined) { 
                localVarFormParams.append('Color', color as any);
            }
    
            if (appColor !== undefined) { 
                localVarFormParams.append('AppColor', appColor as any);
            }
    
            if (finish !== undefined) { 
                localVarFormParams.append('Finish', finish as any);
            }
    
            if (cost !== undefined) { 
                localVarFormParams.append('Cost', cost as any);
            }
    
            if (costCurrencyId !== undefined) { 
                localVarFormParams.append('CostCurrencyId', new Blob([JSON.stringify(costCurrencyId)], { type: "application/json", }));
            }
    
            if (issuerName !== undefined) { 
                localVarFormParams.append('IssuerName', issuerName as any);
            }
    
            if (physicalWalletTierId !== undefined) { 
                localVarFormParams.append('PhysicalWalletTierId', new Blob([JSON.stringify(physicalWalletTierId)], { type: "application/json", }));
            }
    
            if (preAuthAllEnabled !== undefined) { 
                localVarFormParams.append('PreAuthAllEnabled', preAuthAllEnabled as any);
            }
    
            if (preAuthMultiUseAllAllowed !== undefined) { 
                localVarFormParams.append('PreAuthMultiUseAllAllowed', preAuthMultiUseAllAllowed as any);
            }
    
            if (preAuthAllMandatory !== undefined) { 
                localVarFormParams.append('PreAuthAllMandatory', preAuthAllMandatory as any);
            }
    
            if (preAuthMagstripeEnabled !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeEnabled', preAuthMagstripeEnabled as any);
            }
    
            if (preAuthMagstripeMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeMinAmount', preAuthMagstripeMinAmount as any);
            }
    
            if (preAuthMagstripeMandatory !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeMandatory', preAuthMagstripeMandatory as any);
            }
    
            if (preAuthContactlessEnabled !== undefined) { 
                localVarFormParams.append('PreAuthContactlessEnabled', preAuthContactlessEnabled as any);
            }
    
            if (preAuthContactlessMandatory !== undefined) { 
                localVarFormParams.append('PreAuthContactlessMandatory', preAuthContactlessMandatory as any);
            }
    
            if (preAuthContactlessMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthContactlessMinAmount', preAuthContactlessMinAmount as any);
            }
    
            if (preAuthChipAndSigEnabled !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigEnabled', preAuthChipAndSigEnabled as any);
            }
    
            if (preAuthChipAndSigMandatory !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigMandatory', preAuthChipAndSigMandatory as any);
            }
    
            if (preAuthChipAndSigMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigMinAmount', preAuthChipAndSigMinAmount as any);
            }
    
            if (preAuthChipAndPinEnabled !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinEnabled', preAuthChipAndPinEnabled as any);
            }
    
            if (preAuthChipAndPinMandatory !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinMandatory', preAuthChipAndPinMandatory as any);
            }
    
            if (preAuthChipAndPinMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinMinAmount', preAuthChipAndPinMinAmount as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create Region
         * @param {CreateRegionRequest} [createRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegion: async (createRegionRequest?: CreateRegionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createregion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create wallet type for physcial wallet
         * @param {CreateWalletTypeRequest} [createWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletType: async (createWalletTypeRequest?: CreateWalletTypeRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/createwallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete currency
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCurrency', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletecurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeeDefinition: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFeeDefinition', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletefeedefinition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Merchant
         * @param {DeleteMerchantRequest} [deleteMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant: async (deleteMerchantRequest?: DeleteMerchantRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/deletemerchant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMerchantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodByAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentMethodByAdmin', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletepaymentmethodbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete physical wallet plan
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletPlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePhysicalWalletPlan', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletephysicalwalletplan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete physical wallet tier
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletTier: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePhysicalWalletTier', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletephysicalwallettier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePhysicalWalletType', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletephysicalwallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Region
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRegion', 'id', id)
            const localVarPath = `/api/v1/superadmin/deleteregion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary use to delete user by login (mobileNumber or email)
         * @param {DeleteUserByAdminRequest} [deleteUserByAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByAdmin: async (deleteUserByAdminRequest?: DeleteUserByAdminRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/deleteuserbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserByAdminRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Venue
         * @param {DeleteVenueRequest} [deleteVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVenue: async (deleteVenueRequest?: DeleteVenueRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/deletevenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete wallet type
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWalletType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWalletType', 'id', id)
            const localVarPath = `/api/v1/superadmin/deletewallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary use to delete wallets by login (mobileNumber or email)
         * @param {DeleteWalletsRequest} [deleteWalletsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWallets: async (deleteWalletsRequest?: DeleteWalletsRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/deletewallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteWalletsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generate perso batch
         * @param {GeneratePersoBatchRequest} [generatePersoBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePersoBatch: async (generatePersoBatchRequest?: GeneratePersoBatchRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/generatepersobatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatePersoBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReturnCodes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/generatereturncodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all countries in the world
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getallcountries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all breau Issuer names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIssuers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getallissuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all stickers
         * @param {string} [serial] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStickers: async (serial?: string, page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getallstickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all transactions for all users as admin user
         * @param {string} [application] 
         * @param {string} [userId] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesFrom] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesTo] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<TransactionTypeValues>} [transactionTypes] An array of allowed transaction Types (Exchange,InternalTransfer,ExteralTransferIn,ExternalTransferOut)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (application?: string, userId?: string, page?: number, count?: number, beginDate?: string, endDate?: string, paymentMethodTypesFrom?: Array<PaymentMethodTypeValues>, paymentMethodTypesTo?: Array<PaymentMethodTypeValues>, transactionTypes?: Array<TransactionTypeValues>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getalltransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (beginDate !== undefined) {
                localVarQueryParameter['beginDate'] = (beginDate as any instanceof Date) ?
                    (beginDate as any).toISOString() :
                    beginDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (paymentMethodTypesFrom) {
                localVarQueryParameter['paymentMethodTypesFrom'] = paymentMethodTypesFrom;
            }

            if (paymentMethodTypesTo) {
                localVarQueryParameter['paymentMethodTypesTo'] = paymentMethodTypesTo;
            }

            if (transactionTypes) {
                localVarQueryParameter['transactionTypes'] = transactionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {string} [mobileNumber] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [middleName] 
         * @param {string} [lastName] 
         * @param {string} [dateOfBirth] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (mobileNumber?: string, email?: string, firstName?: string, middleName?: string, lastName?: string, dateOfBirth?: string, page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getallusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mobileNumber !== undefined) {
                localVarQueryParameter['mobileNumber'] = mobileNumber;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (middleName !== undefined) {
                localVarQueryParameter['middleName'] = middleName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (dateOfBirth !== undefined) {
                localVarQueryParameter['dateOfBirth'] = (dateOfBirth as any instanceof Date) ?
                    (dateOfBirth as any).toISOString() :
                    dateOfBirth;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get currencies by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCurrenciesByAdmin: async (page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getavailablecurrenciesbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available regions for the admin session or for any user if provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRegionsByAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getavailableregionsbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get currency by id
         * @param {string} id currency id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCurrencyById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getcurrencybyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email otp
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailOtp: async (login: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('getEmailOtp', 'login', login)
            const localVarPath = `/api/v1/superadmin/getemailotp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (login !== undefined) {
                localVarQueryParameter['login'] = login;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary amount exchanged last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeTransactionsAmounts: async (application?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getexchangetransactionsamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all external service instance class ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceClassIds: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getexternalserviceclassids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeDefinitionById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFeeDefinitionById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getfeedefinitionbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [fromCurencyId] 
         * @param {string} [toCurrencyId] 
         * @param {PaymentMethodTypeValues} [fromPaymentMethodType] 
         * @param {PaymentMethodTypeValues} [toPaymentMethodType] 
         * @param {TransactionTypeValues} [transactionType] 
         * @param {PaymentTypeValues} [paymentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeDefinitions: async (page?: number, itemCount?: number, fromCurencyId?: string, toCurrencyId?: string, fromPaymentMethodType?: PaymentMethodTypeValues, toPaymentMethodType?: PaymentMethodTypeValues, transactionType?: TransactionTypeValues, paymentType?: PaymentTypeValues, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getfeedefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (fromCurencyId !== undefined) {
                localVarQueryParameter['fromCurencyId'] = fromCurencyId;
            }

            if (toCurrencyId !== undefined) {
                localVarQueryParameter['toCurrencyId'] = toCurrencyId;
            }

            if (fromPaymentMethodType !== undefined) {
                localVarQueryParameter['fromPaymentMethodType'] = fromPaymentMethodType;
            }

            if (toPaymentMethodType !== undefined) {
                localVarQueryParameter['toPaymentMethodType'] = toPaymentMethodType;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transactionType'] = transactionType;
            }

            if (paymentType !== undefined) {
                localVarQueryParameter['paymentType'] = paymentType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get kyc by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKycById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getkycbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [kycId] 
         * @param {KycLevelValues} [level] kyc level
         * @param {KycDocumentTypeValues} [documentType] kyc document type
         * @param {KycStatusValues} [status] kyc status
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycs: async (userId?: string, kycId?: string, level?: KycLevelValues, documentType?: KycDocumentTypeValues, status?: KycStatusValues, page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getkycs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (kycId !== undefined) {
                localVarQueryParameter['kycId'] = kycId;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get payment method by id
         * @param {string} id payment method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentMethodById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getpaymentmethodbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [userId] 
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodInstancesByUserId: async (userId?: string, wallet?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getpaymentmethodinstancesbyuserid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (wallet !== undefined) {
                localVarQueryParameter['wallet'] = wallet;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment methods by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsByAdmin: async (page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getpaymentmethodsbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPerso: async (physicalWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'physicalWalletId' is not null or undefined
            assertParamExists('getPhysicalWalletPerso', 'physicalWalletId', physicalWalletId)
            const localVarPath = `/api/v1/superadmin/getphysicalwalletperso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (physicalWalletId !== undefined) {
                localVarQueryParameter['physicalWalletId'] = physicalWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get physical wallet pland by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPlanById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhysicalWalletPlanById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getphysicalwalletplanbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all physical wallet plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPlansByAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getphysicalwalletplansbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get physical wallet tier by id
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTierById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhysicalWalletTierById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getphysicalwallettierbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all physical wallet tiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTiersByAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getphysicalwallettiersbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTypeById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhysicalWalletTypeById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getphysicalwallettypebyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all physical wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTypesByAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getphysicalwallettypesbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get physical wallets by admin
         * @param {string} [userId] user Id(option)
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletsByAdmin: async (userId?: string, page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getphysicalwalletsbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary amount received in last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiveTransactionsAmounts: async (application?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getreceivetransactionsamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get region by Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRegionById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getregionbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get regions by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: async (page?: number, itemCount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getregions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sms otp
         * @param {string} phoneNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSMSOtp: async (phoneNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneNumber' is not null or undefined
            assertParamExists('getSMSOtp', 'phoneNumber', phoneNumber)
            const localVarPath = `/api/v1/superadmin/getsmsotp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary amount sent out out last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSendOutTransactionsAmounts: async (application?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getsendouttransactionsamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the system wide settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getsettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sticker pin code
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickerPinCode: async (serial: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serial' is not null or undefined
            assertParamExists('getStickerPinCode', 'serial', serial)
            const localVarPath = `/api/v1/superadmin/getstickerpincode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryTransactionFeesAmounts: async (application?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getsummarytransactionfeesamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tipees by venue id
         * @param {string} [venueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTipeesByVenueId: async (venueId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettipeesbyvenueid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetTransactionAmountRequest} [getTransactionAmountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAmounts: async (getTransactionAmountRequest?: GetTransactionAmountRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettransactionamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTransactionAmountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionById', 'transactionId', transactionId)
            const localVarPath = `/api/v1/superadmin/gettransactionbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction fee amount by period unit : date,month, quarter, year
         * @param {GetTransactionFeesRequest} [getTransactionFeesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFeesAmounts: async (getTransactionFeesRequest?: GetTransactionFeesRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettransactionfeesamounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTransactionFeesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction fee amoun for base currency by period unit : date,month, quarter, year
         * @param {GetTransactionFeesByBaseCurrencyRequest} [getTransactionFeesByBaseCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFeesAmountsByBaseCurrency: async (getTransactionFeesByBaseCurrencyRequest?: GetTransactionFeesByBaseCurrencyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettransactionfeesamountsbybasecurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTransactionFeesByBaseCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary number of transactions last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionNumber: async (application?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettransactionnumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get treasury amount (payment method instance balance amount for currencies)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryAmount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/gettreasuryamount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileByAdmin: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserProfileByAdmin', 'userId', userId)
            const localVarPath = `/api/v1/superadmin/getuserprofilebyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get venues by merchant id
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenuesByMerchantId: async (merchantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('getVenuesByMerchantId', 'merchantId', merchantId)
            const localVarPath = `/api/v1/superadmin/getvenuesbymerchantid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (merchantId !== undefined) {
                localVarQueryParameter['merchantId'] = merchantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wallet type by id
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletTypeById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWalletTypeById', 'id', id)
            const localVarPath = `/api/v1/superadmin/getwallettypebyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletTypesByAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/getwallettypesbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginByAdmin: async (loginPasswordRequest?: LoginPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/loginbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReturnCodes} [returnCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (returnCode?: ReturnCodes, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnCode !== undefined) {
                localVarQueryParameter['returnCode'] = returnCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh exchange rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshExchangeRates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/refreshexchangerates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary regenerate transaction base rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateTransactionBaseRate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/regeneratetransactionbaserate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveUserRequest} [saveUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (saveUserRequest?: SaveUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/saveuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set balance for payment method Id
         * @param {SetBalanceRequest} [setBalanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBalance: async (setBalanceRequest?: SetBalanceRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/setbalance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setBalanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnDelete currency
         * @param {UnDeleteCurrencyRequest} [unDeleteCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeleteCurrency: async (unDeleteCurrencyRequest?: UnDeleteCurrencyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/undeletecurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unDeleteCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeletePaymentMethodRequest} [unDeletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePaymentMethod: async (unDeletePaymentMethodRequest?: UnDeletePaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/undeletepaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unDeletePaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeleteRegionRequest} [unDeleteRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeleteRegion: async (unDeleteRegionRequest?: UnDeleteRegionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/undeleteregion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unDeleteRegionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCurrencyRequest} [updateCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency: async (updateCurrencyRequest?: UpdateCurrencyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatecurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCurrencyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update FeeDefinition
         * @param {UpdateFeeDefinitionRequest} [updateFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeeDefinition: async (updateFeeDefinitionRequest?: UpdateFeeDefinitionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatefeedefinition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeeDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update Kyc status
         * @param {UpdateKycStatusRequest} [updateKycStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKycStatus: async (updateKycStatusRequest?: UpdateKycStatusRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatekycstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateKycStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update PaymentMethod
         * @param {UpdatePaymentMethodRequest} [updatePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethodByAdmin: async (updatePaymentMethodRequest?: UpdatePaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatepaymentmethodbyadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update physical wallet plan
         * @param {UpdatePhysicalWalletPlanRequest} [updatePhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletPlan: async (updatePhysicalWalletPlanRequest?: UpdatePhysicalWalletPlanRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatephysicalwalletplan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePhysicalWalletPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update physical wallet tier
         * @param {UpdatePhysicalWalletTierRequest} [updatePhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletTier: async (updatePhysicalWalletTierRequest?: UpdatePhysicalWalletTierRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatephysicalwallettier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePhysicalWalletTierRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update physical wallet type
         * @param {string} [id] 
         * @param {string} [description] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {any} [image] 
         * @param {boolean} [isDeletedImage] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletType: async (id?: string, description?: string, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, image?: any, isDeletedImage?: boolean, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatephysicalwallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('Id', new Blob([JSON.stringify(id)], { type: "application/json", }));
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('Description', description as any);
            }
    
            if (material !== undefined) { 
                localVarFormParams.append('Material', material as any);
            }
    
            if (color !== undefined) { 
                localVarFormParams.append('Color', color as any);
            }
    
            if (appColor !== undefined) { 
                localVarFormParams.append('AppColor', appColor as any);
            }
    
            if (finish !== undefined) { 
                localVarFormParams.append('Finish', finish as any);
            }
    
            if (cost !== undefined) { 
                localVarFormParams.append('Cost', cost as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('Image', image as any);
            }
    
            if (isDeletedImage !== undefined) { 
                localVarFormParams.append('IsDeletedImage', isDeletedImage as any);
            }
    
            if (preAuthAllEnabled !== undefined) { 
                localVarFormParams.append('PreAuthAllEnabled', preAuthAllEnabled as any);
            }
    
            if (preAuthMultiUseAllAllowed !== undefined) { 
                localVarFormParams.append('PreAuthMultiUseAllAllowed', preAuthMultiUseAllAllowed as any);
            }
    
            if (preAuthAllMandatory !== undefined) { 
                localVarFormParams.append('PreAuthAllMandatory', preAuthAllMandatory as any);
            }
    
            if (preAuthMagstripeEnabled !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeEnabled', preAuthMagstripeEnabled as any);
            }
    
            if (preAuthMagstripeMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeMinAmount', preAuthMagstripeMinAmount as any);
            }
    
            if (preAuthMagstripeMandatory !== undefined) { 
                localVarFormParams.append('PreAuthMagstripeMandatory', preAuthMagstripeMandatory as any);
            }
    
            if (preAuthContactlessEnabled !== undefined) { 
                localVarFormParams.append('PreAuthContactlessEnabled', preAuthContactlessEnabled as any);
            }
    
            if (preAuthContactlessMandatory !== undefined) { 
                localVarFormParams.append('PreAuthContactlessMandatory', preAuthContactlessMandatory as any);
            }
    
            if (preAuthContactlessMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthContactlessMinAmount', preAuthContactlessMinAmount as any);
            }
    
            if (preAuthChipAndSigEnabled !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigEnabled', preAuthChipAndSigEnabled as any);
            }
    
            if (preAuthChipAndSigMandatory !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigMandatory', preAuthChipAndSigMandatory as any);
            }
    
            if (preAuthChipAndSigMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthChipAndSigMinAmount', preAuthChipAndSigMinAmount as any);
            }
    
            if (preAuthChipAndPinEnabled !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinEnabled', preAuthChipAndPinEnabled as any);
            }
    
            if (preAuthChipAndPinMandatory !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinMandatory', preAuthChipAndPinMandatory as any);
            }
    
            if (preAuthChipAndPinMinAmount !== undefined) { 
                localVarFormParams.append('PreAuthChipAndPinMinAmount', preAuthChipAndPinMinAmount as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update Region
         * @param {UpdateRegionRequest} [updateRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegion: async (updateRegionRequest?: UpdateRegionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updateregion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the system wide settings
         * @param {UpdateSettingsRequest} [updateSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: async (updateSettingsRequest?: UpdateSettingsRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatesettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update wallet type
         * @param {UpdateWalletTypeRequest} [updateWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletType: async (updateWalletTypeRequest?: UpdateWalletTypeRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/superadmin/updatewallettype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWalletTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuperAdminApi - functional programming interface
 * @export
 */
export const SuperAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SuperAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary create currency
         * @param {CreateCurrencyRequest} [createCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrency(createCurrencyRequest?: CreateCurrencyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreateCurrencyResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrency(createCurrencyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create FeeDefinition
         * @param {CreateFeeDefinitionRequest} [createFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeeDefinition(createFeeDefinitionRequest?: CreateFeeDefinitionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreateFeeDefinitionResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeeDefinition(createFeeDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create PaymentMethod
         * @param {CreatePaymentMethodRequest} [createPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethodByAdmin(createPaymentMethodRequest?: CreatePaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreatePaymentMethodResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethodByAdmin(createPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create physical wallet plan
         * @param {CreatePhysicalWalletPlanRequest} [createPhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhysicalWalletPlan(createPhysicalWalletPlanRequest?: CreatePhysicalWalletPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreatePhysicalWalletPlanResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhysicalWalletPlan(createPhysicalWalletPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create physical wallet tier
         * @param {CreatePhysicalWalletTierRequest} [createPhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhysicalWalletTier(createPhysicalWalletTierRequest?: CreatePhysicalWalletTierRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreatePhysicalWalletTierResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhysicalWalletTier(createPhysicalWalletTierRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create physical wallet type
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {string} [walletTypeId] 
         * @param {PhysicalWalletSchemeValues} [scheme] 
         * @param {boolean} [hasKeyboard] 
         * @param {boolean} [hasCvvDisplay] 
         * @param {boolean} [hasPinDisplay] 
         * @param {boolean} [hasPanDisplay] 
         * @param {boolean} [hasDynamicCvv] 
         * @param {boolean} [hasDynamicPan] 
         * @param {boolean} [hasDynamicPin] 
         * @param {boolean} [physicalAuth] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {string} [costCurrencyId] 
         * @param {string} [issuerName] 
         * @param {string} [physicalWalletTierId] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhysicalWalletType(name?: string, description?: string, image?: any, walletTypeId?: string, scheme?: PhysicalWalletSchemeValues, hasKeyboard?: boolean, hasCvvDisplay?: boolean, hasPinDisplay?: boolean, hasPanDisplay?: boolean, hasDynamicCvv?: boolean, hasDynamicPan?: boolean, hasDynamicPin?: boolean, physicalAuth?: boolean, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, costCurrencyId?: string, issuerName?: string, physicalWalletTierId?: string, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreatePhysicalWalletTypeResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhysicalWalletType(name, description, image, walletTypeId, scheme, hasKeyboard, hasCvvDisplay, hasPinDisplay, hasPanDisplay, hasDynamicCvv, hasDynamicPan, hasDynamicPin, physicalAuth, material, color, appColor, finish, cost, costCurrencyId, issuerName, physicalWalletTierId, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create Region
         * @param {CreateRegionRequest} [createRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRegion(createRegionRequest?: CreateRegionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreateRegionResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRegion(createRegionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create wallet type for physcial wallet
         * @param {CreateWalletTypeRequest} [createWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletType(createWalletTypeRequest?: CreateWalletTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreateWalletTypeResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletType(createWalletTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete currency
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCurrency(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCurrency(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeeDefinition(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeeDefinition(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Merchant
         * @param {DeleteMerchantRequest} [deleteMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMerchant(deleteMerchantRequest?: DeleteMerchantRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeleteMerchantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMerchant(deleteMerchantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethodByAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethodByAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete physical wallet plan
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhysicalWalletPlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhysicalWalletPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete physical wallet tier
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhysicalWalletTier(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhysicalWalletTier(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhysicalWalletType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhysicalWalletType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Region
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRegion(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRegion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary use to delete user by login (mobileNumber or email)
         * @param {DeleteUserByAdminRequest} [deleteUserByAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserByAdmin(deleteUserByAdminRequest?: DeleteUserByAdminRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAdminDeleteUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserByAdmin(deleteUserByAdminRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Venue
         * @param {DeleteVenueRequest} [deleteVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVenue(deleteVenueRequest?: DeleteVenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeleteVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVenue(deleteVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete wallet type
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWalletType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWalletType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary use to delete wallets by login (mobileNumber or email)
         * @param {DeleteWalletsRequest} [deleteWalletsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWallets(deleteWalletsRequest?: DeleteWalletsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeleteWalletsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWallets(deleteWalletsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary generate perso batch
         * @param {GeneratePersoBatchRequest} [generatePersoBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePersoBatch(generatePersoBatchRequest?: GeneratePersoBatchRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePersoBatch(generatePersoBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateReturnCodes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListReturnCodesDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateReturnCodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all countries in the world
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListCountryDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all breau Issuer names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIssuers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetAllIssuersResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIssuers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all stickers
         * @param {string} [serial] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStickers(serial?: string, page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetAllStickersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStickers(serial, page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all transactions for all users as admin user
         * @param {string} [application] 
         * @param {string} [userId] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesFrom] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesTo] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<TransactionTypeValues>} [transactionTypes] An array of allowed transaction Types (Exchange,InternalTransfer,ExteralTransferIn,ExternalTransferOut)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(application?: string, userId?: string, page?: number, count?: number, beginDate?: string, endDate?: string, paymentMethodTypesFrom?: Array<PaymentMethodTypeValues>, paymentMethodTypesTo?: Array<PaymentMethodTypeValues>, transactionTypes?: Array<TransactionTypeValues>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetAllTransactionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(application, userId, page, count, beginDate, endDate, paymentMethodTypesFrom, paymentMethodTypesTo, transactionTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users
         * @param {string} [mobileNumber] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [middleName] 
         * @param {string} [lastName] 
         * @param {string} [dateOfBirth] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(mobileNumber?: string, email?: string, firstName?: string, middleName?: string, lastName?: string, dateOfBirth?: string, page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListGetAllUsersDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(mobileNumber, email, firstName, middleName, lastName, dateOfBirth, page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get currencies by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableCurrenciesByAdmin(page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListCurrencyDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableCurrenciesByAdmin(page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available regions for the admin session or for any user if provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableRegionsByAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailableRegionsSuccessDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableRegionsByAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get currency by id
         * @param {string} id currency id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCurrencyDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get email otp
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmailOtp(login: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetEmailOtpDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmailOtp(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary amount exchanged last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeTransactionsAmounts(application?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetExchangeTransactionsAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeTransactionsAmounts(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all external service instance class ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalServiceClassIds(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListGetServiceClassIdResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalServiceClassIds(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeDefinitionById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessFeeDefinitionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeDefinitionById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [fromCurencyId] 
         * @param {string} [toCurrencyId] 
         * @param {PaymentMethodTypeValues} [fromPaymentMethodType] 
         * @param {PaymentMethodTypeValues} [toPaymentMethodType] 
         * @param {TransactionTypeValues} [transactionType] 
         * @param {PaymentTypeValues} [paymentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeDefinitions(page?: number, itemCount?: number, fromCurencyId?: string, toCurrencyId?: string, fromPaymentMethodType?: PaymentMethodTypeValues, toPaymentMethodType?: PaymentMethodTypeValues, transactionType?: TransactionTypeValues, paymentType?: PaymentTypeValues, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListFeeDefinitionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeDefinitions(page, itemCount, fromCurencyId, toCurrencyId, fromPaymentMethodType, toPaymentMethodType, transactionType, paymentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get kyc by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepKycDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [kycId] 
         * @param {KycLevelValues} [level] kyc level
         * @param {KycDocumentTypeValues} [documentType] kyc document type
         * @param {KycStatusValues} [status] kyc status
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycs(userId?: string, kycId?: string, level?: KycLevelValues, documentType?: KycDocumentTypeValues, status?: KycStatusValues, page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepKycDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycs(userId, kycId, level, documentType, status, page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get payment method by id
         * @param {string} id payment method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPaymentMethodDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [userId] 
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodInstancesByUserId(userId?: string, wallet?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetDashboardDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodInstancesByUserId(userId, wallet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payment methods by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsByAdmin(page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepPaymentMethodDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodsByAdmin(page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPerso(physicalWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessPhysicalWalletPersoDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPerso(physicalWalletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get physical wallet pland by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPlanById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletPlanDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPlanById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all physical wallet plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletPlansByAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepPhysicalWalletPlanDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletPlansByAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get physical wallet tier by id
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletTierById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletTierDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletTierById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all physical wallet tiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletTiersByAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepPhysicalWalletTierDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletTiersByAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletTypeById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletTypeById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all physical wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletTypesByAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListDeepPhysicalWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletTypesByAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get physical wallets by admin
         * @param {string} [userId] user Id(option)
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalWalletsByAdmin(userId?: string, page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListPhysicalWalletDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhysicalWalletsByAdmin(userId, page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary amount received in last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiveTransactionsAmounts(application?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetReceiveTransactionsAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiveTransactionsAmounts(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get region by Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegionById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRegionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get regions by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegions(page?: number, itemCount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListRegionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(page, itemCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sms otp
         * @param {string} phoneNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSMSOtp(phoneNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetSMSOtpDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSMSOtp(phoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary amount sent out out last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSendOutTransactionsAmounts(application?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetSendOutTransactionsAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSendOutTransactionsAmounts(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the system wide settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSystemSettingsDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sticker pin code
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStickerPinCode(serial: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetStickerPinCodeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStickerPinCode(serial, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummaryTransactionFeesAmounts(application?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetSummaryTransactionFeeAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummaryTransactionFeesAmounts(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tipees by venue id
         * @param {string} [venueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTipeesByVenueId(venueId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTipeesByVenueIdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTipeesByVenueId(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetTransactionAmountRequest} [getTransactionAmountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionAmounts(getTransactionAmountRequest?: GetTransactionAmountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTransactionAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionAmounts(getTransactionAmountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessTransactionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionById(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction fee amount by period unit : date,month, quarter, year
         * @param {GetTransactionFeesRequest} [getTransactionFeesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionFeesAmounts(getTransactionFeesRequest?: GetTransactionFeesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTransactionFeeAmountsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionFeesAmounts(getTransactionFeesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction fee amoun for base currency by period unit : date,month, quarter, year
         * @param {GetTransactionFeesByBaseCurrencyRequest} [getTransactionFeesByBaseCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest?: GetTransactionFeesByBaseCurrencyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTransactionFeeAmountsByBaseCurrencyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary number of transactions last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionNumber(application?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTransactionNumberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionNumber(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get treasury amount (payment method instance balance amount for currencies)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTreasuryAmount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTreasuryAmount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfileByAdmin(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetUserProfileByAdminDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfileByAdmin(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get venues by merchant id
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesByMerchantId(merchantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetVenuesByMerchantIdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVenuesByMerchantId(merchantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get wallet type by id
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletTypeById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletTypeById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletTypesByAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletTypesByAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginByAdmin(loginPasswordRequest?: LoginPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessUserSanatizeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginByAdmin(loginPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReturnCodes} [returnCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(returnCode?: ReturnCodes, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(returnCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary refresh exchange rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshExchangeRates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRefreshExchangeRatesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshExchangeRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary regenerate transaction base rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateTransactionBaseRate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateTransactionBaseRate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveUserRequest} [saveUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(saveUserRequest?: SaveUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSaveUserResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(saveUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set balance for payment method Id
         * @param {SetBalanceRequest} [setBalanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBalance(setBalanceRequest?: SetBalanceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetBalanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBalance(setBalanceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnDelete currency
         * @param {UnDeleteCurrencyRequest} [unDeleteCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDeleteCurrency(unDeleteCurrencyRequest?: UnDeleteCurrencyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCurrencyDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unDeleteCurrency(unDeleteCurrencyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeletePaymentMethodRequest} [unDeletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDeletePaymentMethod(unDeletePaymentMethodRequest?: UnDeletePaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unDeletePaymentMethod(unDeletePaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeleteRegionRequest} [unDeleteRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDeleteRegion(unDeleteRegionRequest?: UnDeleteRegionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unDeleteRegion(unDeleteRegionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateCurrencyRequest} [updateCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrency(updateCurrencyRequest?: UpdateCurrencyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCurrencyDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrency(updateCurrencyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update FeeDefinition
         * @param {UpdateFeeDefinitionRequest} [updateFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeeDefinition(updateFeeDefinitionRequest?: UpdateFeeDefinitionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessFeeDefinitionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeeDefinition(updateFeeDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update Kyc status
         * @param {UpdateKycStatusRequest} [updateKycStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKycStatus(updateKycStatusRequest?: UpdateKycStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessKycDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKycStatus(updateKycStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update PaymentMethod
         * @param {UpdatePaymentMethodRequest} [updatePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentMethodByAdmin(updatePaymentMethodRequest?: UpdatePaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPaymentMethodDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentMethodByAdmin(updatePaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update physical wallet plan
         * @param {UpdatePhysicalWalletPlanRequest} [updatePhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest?: UpdatePhysicalWalletPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletPlanDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update physical wallet tier
         * @param {UpdatePhysicalWalletTierRequest} [updatePhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhysicalWalletTier(updatePhysicalWalletTierRequest?: UpdatePhysicalWalletTierRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletTierDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhysicalWalletTier(updatePhysicalWalletTierRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update physical wallet type
         * @param {string} [id] 
         * @param {string} [description] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {any} [image] 
         * @param {boolean} [isDeletedImage] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhysicalWalletType(id?: string, description?: string, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, image?: any, isDeletedImage?: boolean, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeepPhysicalWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhysicalWalletType(id, description, material, color, appColor, finish, cost, image, isDeletedImage, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update Region
         * @param {UpdateRegionRequest} [updateRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRegion(updateRegionRequest?: UpdateRegionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRegionDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRegion(updateRegionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the system wide settings
         * @param {UpdateSettingsRequest} [updateSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettings(updateSettingsRequest?: UpdateSettingsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSystemSettingsDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettings(updateSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update wallet type
         * @param {UpdateWalletTypeRequest} [updateWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWalletType(updateWalletTypeRequest?: UpdateWalletTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessWalletTypeDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWalletType(updateWalletTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SuperAdminApi - factory interface
 * @export
 */
export const SuperAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SuperAdminApiFp(configuration)
    return {
        /**
         * 
         * @summary create currency
         * @param {CreateCurrencyRequest} [createCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(createCurrencyRequest?: CreateCurrencyRequest, options?: any): AxiosPromise<SuccessCreateCurrencyResultDtoResponse> {
            return localVarFp.createCurrency(createCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create FeeDefinition
         * @param {CreateFeeDefinitionRequest} [createFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeeDefinition(createFeeDefinitionRequest?: CreateFeeDefinitionRequest, options?: any): AxiosPromise<SuccessCreateFeeDefinitionResultDtoResponse> {
            return localVarFp.createFeeDefinition(createFeeDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create PaymentMethod
         * @param {CreatePaymentMethodRequest} [createPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodByAdmin(createPaymentMethodRequest?: CreatePaymentMethodRequest, options?: any): AxiosPromise<SuccessCreatePaymentMethodResultDtoResponse> {
            return localVarFp.createPaymentMethodByAdmin(createPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create physical wallet plan
         * @param {CreatePhysicalWalletPlanRequest} [createPhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletPlan(createPhysicalWalletPlanRequest?: CreatePhysicalWalletPlanRequest, options?: any): AxiosPromise<SuccessCreatePhysicalWalletPlanResultDtoResponse> {
            return localVarFp.createPhysicalWalletPlan(createPhysicalWalletPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create physical wallet tier
         * @param {CreatePhysicalWalletTierRequest} [createPhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletTier(createPhysicalWalletTierRequest?: CreatePhysicalWalletTierRequest, options?: any): AxiosPromise<SuccessCreatePhysicalWalletTierResultDtoResponse> {
            return localVarFp.createPhysicalWalletTier(createPhysicalWalletTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create physical wallet type
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {string} [walletTypeId] 
         * @param {PhysicalWalletSchemeValues} [scheme] 
         * @param {boolean} [hasKeyboard] 
         * @param {boolean} [hasCvvDisplay] 
         * @param {boolean} [hasPinDisplay] 
         * @param {boolean} [hasPanDisplay] 
         * @param {boolean} [hasDynamicCvv] 
         * @param {boolean} [hasDynamicPan] 
         * @param {boolean} [hasDynamicPin] 
         * @param {boolean} [physicalAuth] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {string} [costCurrencyId] 
         * @param {string} [issuerName] 
         * @param {string} [physicalWalletTierId] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhysicalWalletType(name?: string, description?: string, image?: any, walletTypeId?: string, scheme?: PhysicalWalletSchemeValues, hasKeyboard?: boolean, hasCvvDisplay?: boolean, hasPinDisplay?: boolean, hasPanDisplay?: boolean, hasDynamicCvv?: boolean, hasDynamicPan?: boolean, hasDynamicPin?: boolean, physicalAuth?: boolean, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, costCurrencyId?: string, issuerName?: string, physicalWalletTierId?: string, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any): AxiosPromise<SuccessCreatePhysicalWalletTypeResultDtoResponse> {
            return localVarFp.createPhysicalWalletType(name, description, image, walletTypeId, scheme, hasKeyboard, hasCvvDisplay, hasPinDisplay, hasPanDisplay, hasDynamicCvv, hasDynamicPan, hasDynamicPin, physicalAuth, material, color, appColor, finish, cost, costCurrencyId, issuerName, physicalWalletTierId, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create Region
         * @param {CreateRegionRequest} [createRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegion(createRegionRequest?: CreateRegionRequest, options?: any): AxiosPromise<SuccessCreateRegionResultDtoResponse> {
            return localVarFp.createRegion(createRegionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create wallet type for physcial wallet
         * @param {CreateWalletTypeRequest} [createWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletType(createWalletTypeRequest?: CreateWalletTypeRequest, options?: any): AxiosPromise<SuccessCreateWalletTypeResultDtoResponse> {
            return localVarFp.createWalletType(createWalletTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete currency
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteCurrency(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeeDefinition(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteFeeDefinition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Merchant
         * @param {DeleteMerchantRequest} [deleteMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(deleteMerchantRequest?: DeleteMerchantRequest, options?: any): AxiosPromise<SuccessDeleteMerchantDto> {
            return localVarFp.deleteMerchant(deleteMerchantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodByAdmin(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deletePaymentMethodByAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete physical wallet plan
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletPlan(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deletePhysicalWalletPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete physical wallet tier
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletTier(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deletePhysicalWalletTier(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhysicalWalletType(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deletePhysicalWalletType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Region
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary use to delete user by login (mobileNumber or email)
         * @param {DeleteUserByAdminRequest} [deleteUserByAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByAdmin(deleteUserByAdminRequest?: DeleteUserByAdminRequest, options?: any): AxiosPromise<SuccessAdminDeleteUserDto> {
            return localVarFp.deleteUserByAdmin(deleteUserByAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Venue
         * @param {DeleteVenueRequest} [deleteVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVenue(deleteVenueRequest?: DeleteVenueRequest, options?: any): AxiosPromise<SuccessDeleteVenueDto> {
            return localVarFp.deleteVenue(deleteVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete wallet type
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWalletType(id: string, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.deleteWalletType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary use to delete wallets by login (mobileNumber or email)
         * @param {DeleteWalletsRequest} [deleteWalletsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWallets(deleteWalletsRequest?: DeleteWalletsRequest, options?: any): AxiosPromise<SuccessDeleteWalletsDto> {
            return localVarFp.deleteWallets(deleteWalletsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary generate perso batch
         * @param {GeneratePersoBatchRequest} [generatePersoBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePersoBatch(generatePersoBatchRequest?: GeneratePersoBatchRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.generatePersoBatch(generatePersoBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReturnCodes(options?: any): AxiosPromise<SuccessListReturnCodesDtoResponse> {
            return localVarFp.generateReturnCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all countries in the world
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options?: any): AxiosPromise<SuccessListCountryDtoResponse> {
            return localVarFp.getAllCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all breau Issuer names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIssuers(options?: any): AxiosPromise<SuccessGetAllIssuersResultDtoResponse> {
            return localVarFp.getAllIssuers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all stickers
         * @param {string} [serial] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStickers(serial?: string, page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessGetAllStickersDto> {
            return localVarFp.getAllStickers(serial, page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all transactions for all users as admin user
         * @param {string} [application] 
         * @param {string} [userId] 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesFrom] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesTo] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
         * @param {Array<TransactionTypeValues>} [transactionTypes] An array of allowed transaction Types (Exchange,InternalTransfer,ExteralTransferIn,ExternalTransferOut)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(application?: string, userId?: string, page?: number, count?: number, beginDate?: string, endDate?: string, paymentMethodTypesFrom?: Array<PaymentMethodTypeValues>, paymentMethodTypesTo?: Array<PaymentMethodTypeValues>, transactionTypes?: Array<TransactionTypeValues>, options?: any): AxiosPromise<SuccessGetAllTransactionsDto> {
            return localVarFp.getAllTransactions(application, userId, page, count, beginDate, endDate, paymentMethodTypesFrom, paymentMethodTypesTo, transactionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {string} [mobileNumber] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [middleName] 
         * @param {string} [lastName] 
         * @param {string} [dateOfBirth] 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(mobileNumber?: string, email?: string, firstName?: string, middleName?: string, lastName?: string, dateOfBirth?: string, page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListGetAllUsersDtoResponse> {
            return localVarFp.getAllUsers(mobileNumber, email, firstName, middleName, lastName, dateOfBirth, page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get currencies by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCurrenciesByAdmin(page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListCurrencyDtoResponse> {
            return localVarFp.getAvailableCurrenciesByAdmin(page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available regions for the admin session or for any user if provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRegionsByAdmin(options?: any): AxiosPromise<GetAvailableRegionsSuccessDto> {
            return localVarFp.getAvailableRegionsByAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get currency by id
         * @param {string} id currency id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyById(id: string, options?: any): AxiosPromise<SuccessCurrencyDtoResponse> {
            return localVarFp.getCurrencyById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get email otp
         * @param {string} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailOtp(login: string, options?: any): AxiosPromise<SuccessGetEmailOtpDto> {
            return localVarFp.getEmailOtp(login, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary amount exchanged last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeTransactionsAmounts(application?: string, options?: any): AxiosPromise<SuccessGetExchangeTransactionsAmountsDto> {
            return localVarFp.getExchangeTransactionsAmounts(application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all external service instance class ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceClassIds(options?: any): AxiosPromise<SuccessListGetServiceClassIdResultDtoResponse> {
            return localVarFp.getExternalServiceClassIds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeDefinitionById(id: string, options?: any): AxiosPromise<SuccessFeeDefinitionDtoResponse> {
            return localVarFp.getFeeDefinitionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [fromCurencyId] 
         * @param {string} [toCurrencyId] 
         * @param {PaymentMethodTypeValues} [fromPaymentMethodType] 
         * @param {PaymentMethodTypeValues} [toPaymentMethodType] 
         * @param {TransactionTypeValues} [transactionType] 
         * @param {PaymentTypeValues} [paymentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeDefinitions(page?: number, itemCount?: number, fromCurencyId?: string, toCurrencyId?: string, fromPaymentMethodType?: PaymentMethodTypeValues, toPaymentMethodType?: PaymentMethodTypeValues, transactionType?: TransactionTypeValues, paymentType?: PaymentTypeValues, options?: any): AxiosPromise<SuccessListFeeDefinitionDtoResponse> {
            return localVarFp.getFeeDefinitions(page, itemCount, fromCurencyId, toCurrencyId, fromPaymentMethodType, toPaymentMethodType, transactionType, paymentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get kyc by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycById(id: string, options?: any): AxiosPromise<SuccessDeepKycDtoResponse> {
            return localVarFp.getKycById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [kycId] 
         * @param {KycLevelValues} [level] kyc level
         * @param {KycDocumentTypeValues} [documentType] kyc document type
         * @param {KycStatusValues} [status] kyc status
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycs(userId?: string, kycId?: string, level?: KycLevelValues, documentType?: KycDocumentTypeValues, status?: KycStatusValues, page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListDeepKycDtoResponse> {
            return localVarFp.getKycs(userId, kycId, level, documentType, status, page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get payment method by id
         * @param {string} id payment method id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodById(id: string, options?: any): AxiosPromise<SuccessDeepPaymentMethodDtoResponse> {
            return localVarFp.getPaymentMethodById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [userId] 
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodInstancesByUserId(userId?: string, wallet?: string, options?: any): AxiosPromise<SuccessGetDashboardDto> {
            return localVarFp.getPaymentMethodInstancesByUserId(userId, wallet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payment methods by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsByAdmin(page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListDeepPaymentMethodDtoResponse> {
            return localVarFp.getPaymentMethodsByAdmin(page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} physicalWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPerso(physicalWalletId: string, options?: any): AxiosPromise<SuccessPhysicalWalletPersoDtoResponse> {
            return localVarFp.getPhysicalWalletPerso(physicalWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get physical wallet pland by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPlanById(id: string, options?: any): AxiosPromise<SuccessDeepPhysicalWalletPlanDtoResponse> {
            return localVarFp.getPhysicalWalletPlanById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all physical wallet plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletPlansByAdmin(options?: any): AxiosPromise<SuccessListDeepPhysicalWalletPlanDtoResponse> {
            return localVarFp.getPhysicalWalletPlansByAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get physical wallet tier by id
         * @param {string} id physical wallet tier id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTierById(id: string, options?: any): AxiosPromise<SuccessDeepPhysicalWalletTierDtoResponse> {
            return localVarFp.getPhysicalWalletTierById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all physical wallet tiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTiersByAdmin(options?: any): AxiosPromise<SuccessListDeepPhysicalWalletTierDtoResponse> {
            return localVarFp.getPhysicalWalletTiersByAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get physical wallet type by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTypeById(id: string, options?: any): AxiosPromise<SuccessDeepPhysicalWalletTypeDtoResponse> {
            return localVarFp.getPhysicalWalletTypeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all physical wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletTypesByAdmin(options?: any): AxiosPromise<SuccessListDeepPhysicalWalletTypeDtoResponse> {
            return localVarFp.getPhysicalWalletTypesByAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get physical wallets by admin
         * @param {string} [userId] user Id(option)
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalWalletsByAdmin(userId?: string, page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListPhysicalWalletDtoResponse> {
            return localVarFp.getPhysicalWalletsByAdmin(userId, page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary amount received in last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiveTransactionsAmounts(application?: string, options?: any): AxiosPromise<SuccessGetReceiveTransactionsAmountsDto> {
            return localVarFp.getReceiveTransactionsAmounts(application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get region by Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionById(id: string, options?: any): AxiosPromise<SuccessRegionDtoResponse> {
            return localVarFp.getRegionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get regions by paging
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(page?: number, itemCount?: number, options?: any): AxiosPromise<SuccessListRegionDtoResponse> {
            return localVarFp.getRegions(page, itemCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sms otp
         * @param {string} phoneNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSMSOtp(phoneNumber: string, options?: any): AxiosPromise<SuccessGetSMSOtpDto> {
            return localVarFp.getSMSOtp(phoneNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary amount sent out out last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSendOutTransactionsAmounts(application?: string, options?: any): AxiosPromise<SuccessGetSendOutTransactionsAmountsDto> {
            return localVarFp.getSendOutTransactionsAmounts(application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the system wide settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: any): AxiosPromise<SuccessSystemSettingsDtoResponse> {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sticker pin code
         * @param {string} serial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickerPinCode(serial: string, options?: any): AxiosPromise<SuccessGetStickerPinCodeDto> {
            return localVarFp.getStickerPinCode(serial, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryTransactionFeesAmounts(application?: string, options?: any): AxiosPromise<SuccessGetSummaryTransactionFeeAmountsDto> {
            return localVarFp.getSummaryTransactionFeesAmounts(application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tipees by venue id
         * @param {string} [venueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTipeesByVenueId(venueId?: string, options?: any): AxiosPromise<SuccessGetTipeesByVenueIdDto> {
            return localVarFp.getTipeesByVenueId(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetTransactionAmountRequest} [getTransactionAmountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAmounts(getTransactionAmountRequest?: GetTransactionAmountRequest, options?: any): AxiosPromise<SuccessGetTransactionAmountsDto> {
            return localVarFp.getTransactionAmounts(getTransactionAmountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(transactionId: string, options?: any): AxiosPromise<SuccessTransactionDtoResponse> {
            return localVarFp.getTransactionById(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction fee amount by period unit : date,month, quarter, year
         * @param {GetTransactionFeesRequest} [getTransactionFeesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFeesAmounts(getTransactionFeesRequest?: GetTransactionFeesRequest, options?: any): AxiosPromise<SuccessGetTransactionFeeAmountsDto> {
            return localVarFp.getTransactionFeesAmounts(getTransactionFeesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction fee amoun for base currency by period unit : date,month, quarter, year
         * @param {GetTransactionFeesByBaseCurrencyRequest} [getTransactionFeesByBaseCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest?: GetTransactionFeesByBaseCurrencyRequest, options?: any): AxiosPromise<SuccessGetTransactionFeeAmountsByBaseCurrencyDto> {
            return localVarFp.getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary number of transactions last 7 days, last 30 days, last 3 months (90 days), last year
         * @param {string} [application] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionNumber(application?: string, options?: any): AxiosPromise<SuccessGetTransactionNumberDto> {
            return localVarFp.getTransactionNumber(application, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get treasury amount (payment method instance balance amount for currencies)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryAmount(options?: any): AxiosPromise<SuccessListGetPaymentMethodInstanceBalanceAmountsDtoResponse> {
            return localVarFp.getTreasuryAmount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileByAdmin(userId: string, options?: any): AxiosPromise<SuccessGetUserProfileByAdminDtoResponse> {
            return localVarFp.getUserProfileByAdmin(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get venues by merchant id
         * @param {string} merchantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenuesByMerchantId(merchantId: string, options?: any): AxiosPromise<SuccessGetVenuesByMerchantIdDto> {
            return localVarFp.getVenuesByMerchantId(merchantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wallet type by id
         * @param {string} id wallet type id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletTypeById(id: string, options?: any): AxiosPromise<SuccessWalletTypeDtoResponse> {
            return localVarFp.getWalletTypeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wallet types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletTypesByAdmin(options?: any): AxiosPromise<SuccessListWalletTypeDtoResponse> {
            return localVarFp.getWalletTypesByAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginByAdmin(loginPasswordRequest?: LoginPasswordRequest, options?: any): AxiosPromise<SuccessUserSanatizeDtoResponse> {
            return localVarFp.loginByAdmin(loginPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReturnCodes} [returnCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(returnCode?: ReturnCodes, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.ping(returnCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh exchange rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshExchangeRates(options?: any): AxiosPromise<SuccessRefreshExchangeRatesDto> {
            return localVarFp.refreshExchangeRates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary regenerate transaction base rate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateTransactionBaseRate(options?: any): AxiosPromise<void> {
            return localVarFp.regenerateTransactionBaseRate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveUserRequest} [saveUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(saveUserRequest?: SaveUserRequest, options?: any): AxiosPromise<SuccessSaveUserResultDtoResponse> {
            return localVarFp.saveUser(saveUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set balance for payment method Id
         * @param {SetBalanceRequest} [setBalanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBalance(setBalanceRequest?: SetBalanceRequest, options?: any): AxiosPromise<SuccessSetBalanceDto> {
            return localVarFp.setBalance(setBalanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnDelete currency
         * @param {UnDeleteCurrencyRequest} [unDeleteCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeleteCurrency(unDeleteCurrencyRequest?: UnDeleteCurrencyRequest, options?: any): AxiosPromise<SuccessCurrencyDtoResponse> {
            return localVarFp.unDeleteCurrency(unDeleteCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeletePaymentMethodRequest} [unDeletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePaymentMethod(unDeletePaymentMethodRequest?: UnDeletePaymentMethodRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.unDeletePaymentMethod(unDeletePaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnDelete Region
         * @param {UnDeleteRegionRequest} [unDeleteRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeleteRegion(unDeleteRegionRequest?: UnDeleteRegionRequest, options?: any): AxiosPromise<BaseSuccessResponse> {
            return localVarFp.unDeleteRegion(unDeleteRegionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCurrencyRequest} [updateCurrencyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(updateCurrencyRequest?: UpdateCurrencyRequest, options?: any): AxiosPromise<SuccessCurrencyDtoResponse> {
            return localVarFp.updateCurrency(updateCurrencyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update FeeDefinition
         * @param {UpdateFeeDefinitionRequest} [updateFeeDefinitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeeDefinition(updateFeeDefinitionRequest?: UpdateFeeDefinitionRequest, options?: any): AxiosPromise<SuccessFeeDefinitionDtoResponse> {
            return localVarFp.updateFeeDefinition(updateFeeDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update Kyc status
         * @param {UpdateKycStatusRequest} [updateKycStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKycStatus(updateKycStatusRequest?: UpdateKycStatusRequest, options?: any): AxiosPromise<SuccessKycDtoResponse> {
            return localVarFp.updateKycStatus(updateKycStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update PaymentMethod
         * @param {UpdatePaymentMethodRequest} [updatePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethodByAdmin(updatePaymentMethodRequest?: UpdatePaymentMethodRequest, options?: any): AxiosPromise<SuccessDeepPaymentMethodDtoResponse> {
            return localVarFp.updatePaymentMethodByAdmin(updatePaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update physical wallet plan
         * @param {UpdatePhysicalWalletPlanRequest} [updatePhysicalWalletPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest?: UpdatePhysicalWalletPlanRequest, options?: any): AxiosPromise<SuccessDeepPhysicalWalletPlanDtoResponse> {
            return localVarFp.updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update physical wallet tier
         * @param {UpdatePhysicalWalletTierRequest} [updatePhysicalWalletTierRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletTier(updatePhysicalWalletTierRequest?: UpdatePhysicalWalletTierRequest, options?: any): AxiosPromise<SuccessDeepPhysicalWalletTierDtoResponse> {
            return localVarFp.updatePhysicalWalletTier(updatePhysicalWalletTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update physical wallet type
         * @param {string} [id] 
         * @param {string} [description] 
         * @param {string} [material] 
         * @param {string} [color] 
         * @param {string} [appColor] 
         * @param {string} [finish] 
         * @param {number} [cost] 
         * @param {any} [image] 
         * @param {boolean} [isDeletedImage] 
         * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
         * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
         * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
         * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
         * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
         * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
         * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
         * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndSigEnabled] 
         * @param {boolean} [preAuthChipAndSigMandatory] 
         * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {boolean} [preAuthChipAndPinEnabled] 
         * @param {boolean} [preAuthChipAndPinMandatory] 
         * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhysicalWalletType(id?: string, description?: string, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, image?: any, isDeletedImage?: boolean, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any): AxiosPromise<SuccessDeepPhysicalWalletTypeDtoResponse> {
            return localVarFp.updatePhysicalWalletType(id, description, material, color, appColor, finish, cost, image, isDeletedImage, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update Region
         * @param {UpdateRegionRequest} [updateRegionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegion(updateRegionRequest?: UpdateRegionRequest, options?: any): AxiosPromise<SuccessRegionDtoResponse> {
            return localVarFp.updateRegion(updateRegionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the system wide settings
         * @param {UpdateSettingsRequest} [updateSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(updateSettingsRequest?: UpdateSettingsRequest, options?: any): AxiosPromise<SuccessSystemSettingsDtoResponse> {
            return localVarFp.updateSettings(updateSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update wallet type
         * @param {UpdateWalletTypeRequest} [updateWalletTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletType(updateWalletTypeRequest?: UpdateWalletTypeRequest, options?: any): AxiosPromise<SuccessWalletTypeDtoResponse> {
            return localVarFp.updateWalletType(updateWalletTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SuperAdminApi - object-oriented interface
 * @export
 * @class SuperAdminApi
 * @extends {BaseAPI}
 */
export class SuperAdminApi extends BaseAPI {
    /**
     * 
     * @summary create currency
     * @param {CreateCurrencyRequest} [createCurrencyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createCurrency(createCurrencyRequest?: CreateCurrencyRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createCurrency(createCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create FeeDefinition
     * @param {CreateFeeDefinitionRequest} [createFeeDefinitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createFeeDefinition(createFeeDefinitionRequest?: CreateFeeDefinitionRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createFeeDefinition(createFeeDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create PaymentMethod
     * @param {CreatePaymentMethodRequest} [createPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createPaymentMethodByAdmin(createPaymentMethodRequest?: CreatePaymentMethodRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createPaymentMethodByAdmin(createPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create physical wallet plan
     * @param {CreatePhysicalWalletPlanRequest} [createPhysicalWalletPlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createPhysicalWalletPlan(createPhysicalWalletPlanRequest?: CreatePhysicalWalletPlanRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createPhysicalWalletPlan(createPhysicalWalletPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create physical wallet tier
     * @param {CreatePhysicalWalletTierRequest} [createPhysicalWalletTierRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createPhysicalWalletTier(createPhysicalWalletTierRequest?: CreatePhysicalWalletTierRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createPhysicalWalletTier(createPhysicalWalletTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create physical wallet type
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {any} [image] 
     * @param {string} [walletTypeId] 
     * @param {PhysicalWalletSchemeValues} [scheme] 
     * @param {boolean} [hasKeyboard] 
     * @param {boolean} [hasCvvDisplay] 
     * @param {boolean} [hasPinDisplay] 
     * @param {boolean} [hasPanDisplay] 
     * @param {boolean} [hasDynamicCvv] 
     * @param {boolean} [hasDynamicPan] 
     * @param {boolean} [hasDynamicPin] 
     * @param {boolean} [physicalAuth] 
     * @param {string} [material] 
     * @param {string} [color] 
     * @param {string} [appColor] 
     * @param {string} [finish] 
     * @param {number} [cost] 
     * @param {string} [costCurrencyId] 
     * @param {string} [issuerName] 
     * @param {string} [physicalWalletTierId] 
     * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
     * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
     * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
     * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
     * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
     * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
     * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
     * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthChipAndSigEnabled] 
     * @param {boolean} [preAuthChipAndSigMandatory] 
     * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthChipAndPinEnabled] 
     * @param {boolean} [preAuthChipAndPinMandatory] 
     * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createPhysicalWalletType(name?: string, description?: string, image?: any, walletTypeId?: string, scheme?: PhysicalWalletSchemeValues, hasKeyboard?: boolean, hasCvvDisplay?: boolean, hasPinDisplay?: boolean, hasPanDisplay?: boolean, hasDynamicCvv?: boolean, hasDynamicPan?: boolean, hasDynamicPin?: boolean, physicalAuth?: boolean, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, costCurrencyId?: string, issuerName?: string, physicalWalletTierId?: string, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).createPhysicalWalletType(name, description, image, walletTypeId, scheme, hasKeyboard, hasCvvDisplay, hasPinDisplay, hasPanDisplay, hasDynamicCvv, hasDynamicPan, hasDynamicPin, physicalAuth, material, color, appColor, finish, cost, costCurrencyId, issuerName, physicalWalletTierId, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create Region
     * @param {CreateRegionRequest} [createRegionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createRegion(createRegionRequest?: CreateRegionRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createRegion(createRegionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create wallet type for physcial wallet
     * @param {CreateWalletTypeRequest} [createWalletTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public createWalletType(createWalletTypeRequest?: CreateWalletTypeRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).createWalletType(createWalletTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete currency
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteCurrency(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteCurrency(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteFeeDefinition(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteFeeDefinition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Merchant
     * @param {DeleteMerchantRequest} [deleteMerchantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteMerchant(deleteMerchantRequest?: DeleteMerchantRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteMerchant(deleteMerchantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deletePaymentMethodByAdmin(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deletePaymentMethodByAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete physical wallet plan
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deletePhysicalWalletPlan(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deletePhysicalWalletPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete physical wallet tier
     * @param {string} id physical wallet tier id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deletePhysicalWalletTier(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deletePhysicalWalletTier(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete physical wallet type by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deletePhysicalWalletType(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deletePhysicalWalletType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Region
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteRegion(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary use to delete user by login (mobileNumber or email)
     * @param {DeleteUserByAdminRequest} [deleteUserByAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteUserByAdmin(deleteUserByAdminRequest?: DeleteUserByAdminRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteUserByAdmin(deleteUserByAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Venue
     * @param {DeleteVenueRequest} [deleteVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteVenue(deleteVenueRequest?: DeleteVenueRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteVenue(deleteVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete wallet type
     * @param {string} id wallet type id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteWalletType(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteWalletType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary use to delete wallets by login (mobileNumber or email)
     * @param {DeleteWalletsRequest} [deleteWalletsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public deleteWallets(deleteWalletsRequest?: DeleteWalletsRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).deleteWallets(deleteWalletsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary generate perso batch
     * @param {GeneratePersoBatchRequest} [generatePersoBatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public generatePersoBatch(generatePersoBatchRequest?: GeneratePersoBatchRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).generatePersoBatch(generatePersoBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public generateReturnCodes(options?: any) {
        return SuperAdminApiFp(this.configuration).generateReturnCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all countries in the world
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAllCountries(options?: any) {
        return SuperAdminApiFp(this.configuration).getAllCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all breau Issuer names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAllIssuers(options?: any) {
        return SuperAdminApiFp(this.configuration).getAllIssuers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all stickers
     * @param {string} [serial] 
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAllStickers(serial?: string, page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getAllStickers(serial, page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all transactions for all users as admin user
     * @param {string} [application] 
     * @param {string} [userId] 
     * @param {number} [page] 
     * @param {number} [count] 
     * @param {string} [beginDate] 
     * @param {string} [endDate] 
     * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesFrom] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
     * @param {Array<PaymentMethodTypeValues>} [paymentMethodTypesTo] An array of allowed PaymentMethodTypes (Card, Bank,CustCrypto,Ativos,Prepaid,LocalCrypto,Crypto,ThirdPartyLoyalty,InternalLoyalty)
     * @param {Array<TransactionTypeValues>} [transactionTypes] An array of allowed transaction Types (Exchange,InternalTransfer,ExteralTransferIn,ExternalTransferOut)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAllTransactions(application?: string, userId?: string, page?: number, count?: number, beginDate?: string, endDate?: string, paymentMethodTypesFrom?: Array<PaymentMethodTypeValues>, paymentMethodTypesTo?: Array<PaymentMethodTypeValues>, transactionTypes?: Array<TransactionTypeValues>, options?: any) {
        return SuperAdminApiFp(this.configuration).getAllTransactions(application, userId, page, count, beginDate, endDate, paymentMethodTypesFrom, paymentMethodTypesTo, transactionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {string} [mobileNumber] 
     * @param {string} [email] 
     * @param {string} [firstName] 
     * @param {string} [middleName] 
     * @param {string} [lastName] 
     * @param {string} [dateOfBirth] 
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAllUsers(mobileNumber?: string, email?: string, firstName?: string, middleName?: string, lastName?: string, dateOfBirth?: string, page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getAllUsers(mobileNumber, email, firstName, middleName, lastName, dateOfBirth, page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get currencies by paging
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAvailableCurrenciesByAdmin(page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getAvailableCurrenciesByAdmin(page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available regions for the admin session or for any user if provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getAvailableRegionsByAdmin(options?: any) {
        return SuperAdminApiFp(this.configuration).getAvailableRegionsByAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get currency by id
     * @param {string} id currency id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getCurrencyById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getCurrencyById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get email otp
     * @param {string} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getEmailOtp(login: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getEmailOtp(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary amount exchanged last 7 days, last 30 days, last 3 months (90 days), last year
     * @param {string} [application] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getExchangeTransactionsAmounts(application?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getExchangeTransactionsAmounts(application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all external service instance class ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getExternalServiceClassIds(options?: any) {
        return SuperAdminApiFp(this.configuration).getExternalServiceClassIds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getFeeDefinitionById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getFeeDefinitionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {string} [fromCurencyId] 
     * @param {string} [toCurrencyId] 
     * @param {PaymentMethodTypeValues} [fromPaymentMethodType] 
     * @param {PaymentMethodTypeValues} [toPaymentMethodType] 
     * @param {TransactionTypeValues} [transactionType] 
     * @param {PaymentTypeValues} [paymentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getFeeDefinitions(page?: number, itemCount?: number, fromCurencyId?: string, toCurrencyId?: string, fromPaymentMethodType?: PaymentMethodTypeValues, toPaymentMethodType?: PaymentMethodTypeValues, transactionType?: TransactionTypeValues, paymentType?: PaymentTypeValues, options?: any) {
        return SuperAdminApiFp(this.configuration).getFeeDefinitions(page, itemCount, fromCurencyId, toCurrencyId, fromPaymentMethodType, toPaymentMethodType, transactionType, paymentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get kyc by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getKycById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getKycById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [kycId] 
     * @param {KycLevelValues} [level] kyc level
     * @param {KycDocumentTypeValues} [documentType] kyc document type
     * @param {KycStatusValues} [status] kyc status
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getKycs(userId?: string, kycId?: string, level?: KycLevelValues, documentType?: KycDocumentTypeValues, status?: KycStatusValues, page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getKycs(userId, kycId, level, documentType, status, page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get payment method by id
     * @param {string} id payment method id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPaymentMethodById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPaymentMethodById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard
     * @param {string} [userId] 
     * @param {string} [wallet] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPaymentMethodInstancesByUserId(userId?: string, wallet?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPaymentMethodInstancesByUserId(userId, wallet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payment methods by paging
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPaymentMethodsByAdmin(page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getPaymentMethodsByAdmin(page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} physicalWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletPerso(physicalWalletId: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletPerso(physicalWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get physical wallet pland by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletPlanById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletPlanById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all physical wallet plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletPlansByAdmin(options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletPlansByAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get physical wallet tier by id
     * @param {string} id physical wallet tier id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletTierById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletTierById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all physical wallet tiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletTiersByAdmin(options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletTiersByAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get physical wallet type by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletTypeById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletTypeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all physical wallet types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletTypesByAdmin(options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletTypesByAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get physical wallets by admin
     * @param {string} [userId] user Id(option)
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getPhysicalWalletsByAdmin(userId?: string, page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getPhysicalWalletsByAdmin(userId, page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary amount received in last 7 days, last 30 days, last 3 months (90 days), last year
     * @param {string} [application] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getReceiveTransactionsAmounts(application?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getReceiveTransactionsAmounts(application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get region by Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getRegionById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getRegionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get regions by paging
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getRegions(page?: number, itemCount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).getRegions(page, itemCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sms otp
     * @param {string} phoneNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getSMSOtp(phoneNumber: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getSMSOtp(phoneNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary amount sent out out last 7 days, last 30 days, last 3 months (90 days), last year
     * @param {string} [application] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getSendOutTransactionsAmounts(application?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getSendOutTransactionsAmounts(application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the system wide settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getSettings(options?: any) {
        return SuperAdminApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sticker pin code
     * @param {string} serial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getStickerPinCode(serial: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getStickerPinCode(serial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [application] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getSummaryTransactionFeesAmounts(application?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getSummaryTransactionFeesAmounts(application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tipees by venue id
     * @param {string} [venueId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTipeesByVenueId(venueId?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getTipeesByVenueId(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetTransactionAmountRequest} [getTransactionAmountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTransactionAmounts(getTransactionAmountRequest?: GetTransactionAmountRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).getTransactionAmounts(getTransactionAmountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTransactionById(transactionId: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getTransactionById(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction fee amount by period unit : date,month, quarter, year
     * @param {GetTransactionFeesRequest} [getTransactionFeesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTransactionFeesAmounts(getTransactionFeesRequest?: GetTransactionFeesRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).getTransactionFeesAmounts(getTransactionFeesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction fee amoun for base currency by period unit : date,month, quarter, year
     * @param {GetTransactionFeesByBaseCurrencyRequest} [getTransactionFeesByBaseCurrencyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest?: GetTransactionFeesByBaseCurrencyRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).getTransactionFeesAmountsByBaseCurrency(getTransactionFeesByBaseCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary number of transactions last 7 days, last 30 days, last 3 months (90 days), last year
     * @param {string} [application] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTransactionNumber(application?: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getTransactionNumber(application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get treasury amount (payment method instance balance amount for currencies)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getTreasuryAmount(options?: any) {
        return SuperAdminApiFp(this.configuration).getTreasuryAmount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getUserProfileByAdmin(userId: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getUserProfileByAdmin(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get venues by merchant id
     * @param {string} merchantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getVenuesByMerchantId(merchantId: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getVenuesByMerchantId(merchantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wallet type by id
     * @param {string} id wallet type id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getWalletTypeById(id: string, options?: any) {
        return SuperAdminApiFp(this.configuration).getWalletTypeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wallet types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public getWalletTypesByAdmin(options?: any) {
        return SuperAdminApiFp(this.configuration).getWalletTypesByAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginPasswordRequest} [loginPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public loginByAdmin(loginPasswordRequest?: LoginPasswordRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).loginByAdmin(loginPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReturnCodes} [returnCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public ping(returnCode?: ReturnCodes, options?: any) {
        return SuperAdminApiFp(this.configuration).ping(returnCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh exchange rate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public refreshExchangeRates(options?: any) {
        return SuperAdminApiFp(this.configuration).refreshExchangeRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary regenerate transaction base rate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public regenerateTransactionBaseRate(options?: any) {
        return SuperAdminApiFp(this.configuration).regenerateTransactionBaseRate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveUserRequest} [saveUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public saveUser(saveUserRequest?: SaveUserRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).saveUser(saveUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set balance for payment method Id
     * @param {SetBalanceRequest} [setBalanceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public setBalance(setBalanceRequest?: SetBalanceRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).setBalance(setBalanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnDelete currency
     * @param {UnDeleteCurrencyRequest} [unDeleteCurrencyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public unDeleteCurrency(unDeleteCurrencyRequest?: UnDeleteCurrencyRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).unDeleteCurrency(unDeleteCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnDelete Region
     * @param {UnDeletePaymentMethodRequest} [unDeletePaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public unDeletePaymentMethod(unDeletePaymentMethodRequest?: UnDeletePaymentMethodRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).unDeletePaymentMethod(unDeletePaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnDelete Region
     * @param {UnDeleteRegionRequest} [unDeleteRegionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public unDeleteRegion(unDeleteRegionRequest?: UnDeleteRegionRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).unDeleteRegion(unDeleteRegionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCurrencyRequest} [updateCurrencyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateCurrency(updateCurrencyRequest?: UpdateCurrencyRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateCurrency(updateCurrencyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update FeeDefinition
     * @param {UpdateFeeDefinitionRequest} [updateFeeDefinitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateFeeDefinition(updateFeeDefinitionRequest?: UpdateFeeDefinitionRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateFeeDefinition(updateFeeDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update Kyc status
     * @param {UpdateKycStatusRequest} [updateKycStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateKycStatus(updateKycStatusRequest?: UpdateKycStatusRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateKycStatus(updateKycStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update PaymentMethod
     * @param {UpdatePaymentMethodRequest} [updatePaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updatePaymentMethodByAdmin(updatePaymentMethodRequest?: UpdatePaymentMethodRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updatePaymentMethodByAdmin(updatePaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update physical wallet plan
     * @param {UpdatePhysicalWalletPlanRequest} [updatePhysicalWalletPlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest?: UpdatePhysicalWalletPlanRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updatePhysicalWalletPlan(updatePhysicalWalletPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update physical wallet tier
     * @param {UpdatePhysicalWalletTierRequest} [updatePhysicalWalletTierRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updatePhysicalWalletTier(updatePhysicalWalletTierRequest?: UpdatePhysicalWalletTierRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updatePhysicalWalletTier(updatePhysicalWalletTierRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update physical wallet type
     * @param {string} [id] 
     * @param {string} [description] 
     * @param {string} [material] 
     * @param {string} [color] 
     * @param {string} [appColor] 
     * @param {string} [finish] 
     * @param {number} [cost] 
     * @param {any} [image] 
     * @param {boolean} [isDeletedImage] 
     * @param {boolean} [preAuthAllEnabled] Is pre-auth enabled for all methods?
     * @param {boolean} [preAuthMultiUseAllAllowed] Is pre-auth multi-use allowed for all methods?
     * @param {boolean} [preAuthAllMandatory] Is the user allowed to disable Preauth on all methods
     * @param {boolean} [preAuthMagstripeEnabled] Is PreAuth on magstripe enabled
     * @param {number} [preAuthMagstripeMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthMagstripeMandatory] Is PreAuth on magstripe mandatory (user can disable?)
     * @param {boolean} [preAuthContactlessEnabled] Is PreAuth on contactless enabled
     * @param {boolean} [preAuthContactlessMandatory] Is PreAuth on contactless mandatory (user can disable?)
     * @param {number} [preAuthContactlessMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthChipAndSigEnabled] 
     * @param {boolean} [preAuthChipAndSigMandatory] 
     * @param {number} [preAuthChipAndSigMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {boolean} [preAuthChipAndPinEnabled] 
     * @param {boolean} [preAuthChipAndPinMandatory] 
     * @param {number} [preAuthChipAndPinMinAmount] From what amount is PreAuth mandatory (even if the user can disable lower amounts)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updatePhysicalWalletType(id?: string, description?: string, material?: string, color?: string, appColor?: string, finish?: string, cost?: number, image?: any, isDeletedImage?: boolean, preAuthAllEnabled?: boolean, preAuthMultiUseAllAllowed?: boolean, preAuthAllMandatory?: boolean, preAuthMagstripeEnabled?: boolean, preAuthMagstripeMinAmount?: number, preAuthMagstripeMandatory?: boolean, preAuthContactlessEnabled?: boolean, preAuthContactlessMandatory?: boolean, preAuthContactlessMinAmount?: number, preAuthChipAndSigEnabled?: boolean, preAuthChipAndSigMandatory?: boolean, preAuthChipAndSigMinAmount?: number, preAuthChipAndPinEnabled?: boolean, preAuthChipAndPinMandatory?: boolean, preAuthChipAndPinMinAmount?: number, options?: any) {
        return SuperAdminApiFp(this.configuration).updatePhysicalWalletType(id, description, material, color, appColor, finish, cost, image, isDeletedImage, preAuthAllEnabled, preAuthMultiUseAllAllowed, preAuthAllMandatory, preAuthMagstripeEnabled, preAuthMagstripeMinAmount, preAuthMagstripeMandatory, preAuthContactlessEnabled, preAuthContactlessMandatory, preAuthContactlessMinAmount, preAuthChipAndSigEnabled, preAuthChipAndSigMandatory, preAuthChipAndSigMinAmount, preAuthChipAndPinEnabled, preAuthChipAndPinMandatory, preAuthChipAndPinMinAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update Region
     * @param {UpdateRegionRequest} [updateRegionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateRegion(updateRegionRequest?: UpdateRegionRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateRegion(updateRegionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the system wide settings
     * @param {UpdateSettingsRequest} [updateSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateSettings(updateSettingsRequest?: UpdateSettingsRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateSettings(updateSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update wallet type
     * @param {UpdateWalletTypeRequest} [updateWalletTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuperAdminApi
     */
    public updateWalletType(updateWalletTypeRequest?: UpdateWalletTypeRequest, options?: any) {
        return SuperAdminApiFp(this.configuration).updateWalletType(updateWalletTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TipseeApi - axios parameter creator
 * @export
 */
export const TipseeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Charge the user card (in the provided currency) and put the charged amount into the prepaid account of the same currency for the same user.
         * @param {ChargeCardRequest} [chargeCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargeCard: async (chargeCardRequest?: ChargeCardRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/chargecard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chargeCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Claim pending tips for tipee
         * @param {ClaimPendingTipsRequest} [claimPendingTipsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPendingTips: async (claimPendingTipsRequest?: ClaimPendingTipsRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/claimpendingtips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimPendingTipsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pending tips of tipee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTips: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/getpendingtips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Roaming users
         * @param {GetRoamingUsersRequest} [getRoamingUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoamingUsers: async (getRoamingUsersRequest?: GetRoamingUsersRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/getroamingusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getRoamingUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tipee working time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/getworking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send tip to tipee
         * @param {SendTipRequest} [sendTipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTip: async (sendTipRequest?: SendTipRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/sendtip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set geographical location for user
         * @param {SetLocationRequest} [setLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLocation: async (setLocationRequest?: SetLocationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/setlocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set start working for tipee
         * @param {StartWorkingRequest} [startWorkingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWorking: async (startWorkingRequest?: StartWorkingRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/startworking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startWorkingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tipee stop working
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWorking: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tipsee/stopworking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipseeApi - functional programming interface
 * @export
 */
export const TipseeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TipseeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Charge the user card (in the provided currency) and put the charged amount into the prepaid account of the same currency for the same user.
         * @param {ChargeCardRequest} [chargeCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargeCard(chargeCardRequest?: ChargeCardRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessChargeCardDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargeCard(chargeCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Claim pending tips for tipee
         * @param {ClaimPendingTipsRequest} [claimPendingTipsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimPendingTips(claimPendingTipsRequest?: ClaimPendingTipsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessClaimPendingTipsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimPendingTips(claimPendingTipsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get pending tips of tipee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingTips(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPendingTipsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingTips(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Roaming users
         * @param {GetRoamingUsersRequest} [getRoamingUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoamingUsers(getRoamingUsersRequest?: GetRoamingUsersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRoamingUsersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoamingUsers(getRoamingUsersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tipee working time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorking(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetWorkingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorking(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send tip to tipee
         * @param {SendTipRequest} [sendTipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTip(sendTipRequest?: SendTipRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendTipDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTip(sendTipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set geographical location for user
         * @param {SetLocationRequest} [setLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLocation(setLocationRequest?: SetLocationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetLocationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLocation(setLocationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set start working for tipee
         * @param {StartWorkingRequest} [startWorkingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startWorking(startWorkingRequest?: StartWorkingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessStartWorkingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startWorking(startWorkingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Tipee stop working
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopWorking(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessStopWorkingDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopWorking(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TipseeApi - factory interface
 * @export
 */
export const TipseeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TipseeApiFp(configuration)
    return {
        /**
         * 
         * @summary Charge the user card (in the provided currency) and put the charged amount into the prepaid account of the same currency for the same user.
         * @param {ChargeCardRequest} [chargeCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargeCard(chargeCardRequest?: ChargeCardRequest, options?: any): AxiosPromise<SuccessChargeCardDto> {
            return localVarFp.chargeCard(chargeCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Claim pending tips for tipee
         * @param {ClaimPendingTipsRequest} [claimPendingTipsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPendingTips(claimPendingTipsRequest?: ClaimPendingTipsRequest, options?: any): AxiosPromise<SuccessClaimPendingTipsDto> {
            return localVarFp.claimPendingTips(claimPendingTipsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pending tips of tipee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingTips(options?: any): AxiosPromise<SuccessGetPendingTipsDto> {
            return localVarFp.getPendingTips(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Roaming users
         * @param {GetRoamingUsersRequest} [getRoamingUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoamingUsers(getRoamingUsersRequest?: GetRoamingUsersRequest, options?: any): AxiosPromise<SuccessGetRoamingUsersDto> {
            return localVarFp.getRoamingUsers(getRoamingUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tipee working time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorking(options?: any): AxiosPromise<SuccessGetWorkingDto> {
            return localVarFp.getWorking(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send tip to tipee
         * @param {SendTipRequest} [sendTipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTip(sendTipRequest?: SendTipRequest, options?: any): AxiosPromise<SuccessSendTipDto> {
            return localVarFp.sendTip(sendTipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set geographical location for user
         * @param {SetLocationRequest} [setLocationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLocation(setLocationRequest?: SetLocationRequest, options?: any): AxiosPromise<SuccessSetLocationDto> {
            return localVarFp.setLocation(setLocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set start working for tipee
         * @param {StartWorkingRequest} [startWorkingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWorking(startWorkingRequest?: StartWorkingRequest, options?: any): AxiosPromise<SuccessStartWorkingDto> {
            return localVarFp.startWorking(startWorkingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tipee stop working
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWorking(body?: object, options?: any): AxiosPromise<SuccessStopWorkingDto> {
            return localVarFp.stopWorking(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TipseeApi - object-oriented interface
 * @export
 * @class TipseeApi
 * @extends {BaseAPI}
 */
export class TipseeApi extends BaseAPI {
    /**
     * 
     * @summary Charge the user card (in the provided currency) and put the charged amount into the prepaid account of the same currency for the same user.
     * @param {ChargeCardRequest} [chargeCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public chargeCard(chargeCardRequest?: ChargeCardRequest, options?: any) {
        return TipseeApiFp(this.configuration).chargeCard(chargeCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Claim pending tips for tipee
     * @param {ClaimPendingTipsRequest} [claimPendingTipsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public claimPendingTips(claimPendingTipsRequest?: ClaimPendingTipsRequest, options?: any) {
        return TipseeApiFp(this.configuration).claimPendingTips(claimPendingTipsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pending tips of tipee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public getPendingTips(options?: any) {
        return TipseeApiFp(this.configuration).getPendingTips(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Roaming users
     * @param {GetRoamingUsersRequest} [getRoamingUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public getRoamingUsers(getRoamingUsersRequest?: GetRoamingUsersRequest, options?: any) {
        return TipseeApiFp(this.configuration).getRoamingUsers(getRoamingUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tipee working time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public getWorking(options?: any) {
        return TipseeApiFp(this.configuration).getWorking(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send tip to tipee
     * @param {SendTipRequest} [sendTipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public sendTip(sendTipRequest?: SendTipRequest, options?: any) {
        return TipseeApiFp(this.configuration).sendTip(sendTipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set geographical location for user
     * @param {SetLocationRequest} [setLocationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public setLocation(setLocationRequest?: SetLocationRequest, options?: any) {
        return TipseeApiFp(this.configuration).setLocation(setLocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set start working for tipee
     * @param {StartWorkingRequest} [startWorkingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public startWorking(startWorkingRequest?: StartWorkingRequest, options?: any) {
        return TipseeApiFp(this.configuration).startWorking(startWorkingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tipee stop working
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipseeApi
     */
    public stopWorking(body?: object, options?: any) {
        return TipseeApiFp(this.configuration).stopWorking(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add contact
         * @param {AddContactRequest} [addContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContact: async (addContactRequest?: AddContactRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/addcontact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adding mobile devices for a particular user.
         * @param {AddDeviceRequest} [addDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDevice: async (addDeviceRequest?: AddDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/adddevice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Should this be distinct from a version where we use password?
         * @param {string} [reference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canLogin: async (reference?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/canlogin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create session
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequest?: CreateSessionRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/createsession`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit contact
         * @param {EditContactRequest} [editContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContact: async (editContactRequest?: EditContactRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/editcontact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchDevices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/fetchdevices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find User by email
         * @param {FindUserByMobileEmailRequest} [findUserByMobileEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByMobileEmail: async (findUserByMobileEmailRequest?: FindUserByMobileEmailRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/finduserbymobileemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findUserByMobileEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find user by mobile numer
         * @param {FindUserByMobileNumberRequest} [findUserByMobileNumberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByMobileNumber: async (findUserByMobileNumberRequest?: FindUserByMobileNumberRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/finduserbymobilenumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findUserByMobileNumberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPin: async (forgotPinRequest?: ForgotPinRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/forgetpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forgot pin
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPin: async (forgotPinRequest?: ForgotPinRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/forgotpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRegions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/getavailableregions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/getcontacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get kyc for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/getkyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the user profile; does the user has to be logged on ?
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/getprofile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Can only be called on *self* or by admin. This is PII information and hence it is heavy to retrieve from the db in production situations.                Note: this method does not have consistent return values; must fix!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/getuserinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSessionActive: async (sessionToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionToken' is not null or undefined
            assertParamExists('isSessionActive', 'sessionToken', sessionToken)
            const localVarPath = `/api/v1/user/issessionactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionToken !== undefined) {
                localVarQueryParameter['sessionToken'] = sessionToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies the biometric message from the client for this user;  if it verifies, the user is allowed to continue, otherwise, not
         * @param {LoginBiometricsRequest} [loginBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginBiometrics: async (loginBiometricsRequest?: LoginBiometricsRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/loginbiometrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginBiometricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login by pin
         * @param {LoginPINRequest} [loginPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPIN: async (loginPINRequest?: LoginPINRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/loginpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPINRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simple login with a password.
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPassword: async (loginPasswordRequest?: LoginPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/loginpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove contact
         * @param {RemoveContactRequest} [removeContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContact: async (removeContactRequest?: RemoveContactRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/removecontact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend email
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail: async (resendEmailRequest?: ResendEmailRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resendemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ResendSMS
         * @param {ResendSMSRequest} [resendSMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendSMS: async (resendSMSRequest?: ResendSMSRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/resendsms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendSMSRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This function stores the PIN the user picks, generate a keypair and store the frontend (app) generated  public key.
         * @param {SetAuthRequest} [setAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuth: async (setAuthRequest?: SetAuthRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Should this be used for setting at a later time as welL?  We assume so
         * @param {SetBiometricsRequest} [setBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBiometrics: async (setBiometricsRequest?: SetBiometricsRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setbiometrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setBiometricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set pin
         * @param {SetPINRequest} [setPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPIN: async (setPINRequest?: SetPINRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPINRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Does the user has to be logged ON?
         * @param {string} [nickName] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {boolean} [showNickName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfile: async (nickName?: string, description?: string, image?: any, showNickName?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setprofile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (nickName !== undefined) { 
                localVarFormParams.append('NickName', nickName as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('Description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('Image', image as any);
            }
    
            if (showNickName !== undefined) { 
                localVarFormParams.append('ShowNickName', showNickName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary use for test session expire
         * @param {SetSessionExpireRequest} [setSessionExpireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionExpire: async (setSessionExpireRequest?: SetSessionExpireRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setsessionexpire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSessionExpireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserInfoRequest} [setUserInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserInfo: async (setUserInfoRequest?: SetUserInfoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/setuserinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Device info
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (updateDeviceRequest?: UpdateDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/updatedevice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send the verification email with an OTP in it the user has to reproduce.                This can be sent to anyone with a session; no need to have an account yet.
         * @param {VerifyEmailRequest} [verifyEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (verifyEmailRequest?: VerifyEmailRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/verifyemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This is the API call to verify the code.
         * @param {VerifyEmailCodeRequest} [verifyEmailCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailCode: async (verifyEmailCodeRequest?: VerifyEmailCodeRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/verifyemailcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This is the verify for the the web; this is needed when you don\'t have an in-app functionality for settling the verification.
         * @param {string} uid 
         * @param {string} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailCodeByUID: async (uid: string, pin: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('verifyEmailCodeByUID', 'uid', uid)
            // verify required parameter 'pin' is not null or undefined
            assertParamExists('verifyEmailCodeByUID', 'pin', pin)
            const localVarPath = `/api/v1/user/verifyemailcodebyuid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (pin !== undefined) {
                localVarQueryParameter['pin'] = pin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create Kyc
         * @param {KycLevelValues} [level] 
         * @param {KycDocumentTypeValues} [documentType] 
         * @param {any} [frontSideImage] 
         * @param {any} [backSideImage] 
         * @param {any} [frontFaceImage] 
         * @param {any} [proofOfAddressImage] 
         * @param {any} [proofOfIncomeImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyKycDocument: async (level?: KycLevelValues, documentType?: KycDocumentTypeValues, frontSideImage?: any, backSideImage?: any, frontFaceImage?: any, proofOfAddressImage?: any, proofOfIncomeImage?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/verifykycdocument`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (level !== undefined) { 
                localVarFormParams.append('Level', new Blob([JSON.stringify(level)], { type: "application/json", }));
            }
    
            if (documentType !== undefined) { 
                localVarFormParams.append('DocumentType', new Blob([JSON.stringify(documentType)], { type: "application/json", }));
            }
    
            if (frontSideImage !== undefined) { 
                localVarFormParams.append('FrontSideImage', frontSideImage as any);
            }
    
            if (backSideImage !== undefined) { 
                localVarFormParams.append('BackSideImage', backSideImage as any);
            }
    
            if (frontFaceImage !== undefined) { 
                localVarFormParams.append('FrontFaceImage', frontFaceImage as any);
            }
    
            if (proofOfAddressImage !== undefined) { 
                localVarFormParams.append('ProofOfAddressImage', proofOfAddressImage as any);
            }
    
            if (proofOfIncomeImage !== undefined) { 
                localVarFormParams.append('ProofOfIncomeImage', proofOfIncomeImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request verify mobile sms
         * @param {VerifyMobileRequest} [verifyMobileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMobile: async (verifyMobileRequest?: VerifyMobileRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/verifymobile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyMobileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify sms
         * @param {VerifySMSRequest} [verifySMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifySMS: async (verifySMSRequest?: VerifySMSRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/verifysms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifySMSRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add contact
         * @param {AddContactRequest} [addContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addContact(addContactRequest?: AddContactRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddContactDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addContact(addContactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adding mobile devices for a particular user.
         * @param {AddDeviceRequest} [addDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDevice(addDeviceRequest?: AddDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddDeviceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDevice(addDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Should this be distinct from a version where we use password?
         * @param {string} [reference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canLogin(reference?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCanLoginDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canLogin(reference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create session
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequest?: CreateSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCreateSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit contact
         * @param {EditContactRequest} [editContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContact(editContactRequest?: EditContactRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessEditContactDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContact(editContactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchDevices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessFetchDevicesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find User by email
         * @param {FindUserByMobileEmailRequest} [findUserByMobileEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByMobileEmail(findUserByMobileEmailRequest?: FindUserByMobileEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessFindUserByMobileEmailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByMobileEmail(findUserByMobileEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find user by mobile numer
         * @param {FindUserByMobileNumberRequest} [findUserByMobileNumberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByMobileNumber(findUserByMobileNumberRequest?: FindUserByMobileNumberRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessFindUserByMobileNumberDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByMobileNumber(findUserByMobileNumberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgetPin(forgotPinRequest?: ForgotPinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessForgotPinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPin(forgotPinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Forgot pin
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPin(forgotPinRequest?: ForgotPinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessForgotPinDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPin(forgotPinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableRegions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailableRegionsSuccessDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetContactsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get kyc for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyc(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessKycDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyc(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the user profile; does the user has to be logged on ?
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Can only be called on *self* or by admin. This is PII information and hence it is heavy to retrieve from the db in production situations.                Note: this method does not have consistent return values; must fix!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetUserInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isSessionActive(sessionToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessIsSessionActiveDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isSessionActive(sessionToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verifies the biometric message from the client for this user;  if it verifies, the user is allowed to continue, otherwise, not
         * @param {LoginBiometricsRequest} [loginBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginBiometrics(loginBiometricsRequest?: LoginBiometricsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLoginBiometricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginBiometrics(loginBiometricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login by pin
         * @param {LoginPINRequest} [loginPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPIN(loginPINRequest?: LoginPINRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLoginPINDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPIN(loginPINRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Simple login with a password.
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPassword(loginPasswordRequest?: LoginPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLoginPINDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPassword(loginPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLogoutDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove contact
         * @param {RemoveContactRequest} [removeContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeContact(removeContactRequest?: RemoveContactRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRemoveContactDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeContact(removeContactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend email
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResendEmailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendEmail(resendEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ResendSMS
         * @param {ResendSMSRequest} [resendSMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendSMS(resendSMSRequest?: ResendSMSRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResendSMSDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendSMS(resendSMSRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This function stores the PIN the user picks, generate a keypair and store the frontend (app) generated  public key.
         * @param {SetAuthRequest} [setAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAuth(setAuthRequest?: SetAuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetAuthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAuth(setAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Should this be used for setting at a later time as welL?  We assume so
         * @param {SetBiometricsRequest} [setBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBiometrics(setBiometricsRequest?: SetBiometricsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetBiometricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBiometrics(setBiometricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set pin
         * @param {SetPINRequest} [setPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPIN(setPINRequest?: SetPINRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetPINDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPIN(setPINRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Does the user has to be logged ON?
         * @param {string} [nickName] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {boolean} [showNickName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProfile(nickName?: string, description?: string, image?: any, showNickName?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProfile(nickName, description, image, showNickName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary use for test session expire
         * @param {SetSessionExpireRequest} [setSessionExpireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSessionExpire(setSessionExpireRequest?: SetSessionExpireRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetSessionExpireDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSessionExpire(setSessionExpireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SetUserInfoRequest} [setUserInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserInfo(setUserInfoRequest?: SetUserInfoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetUserInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserInfo(setUserInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Device info
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(updateDeviceRequest?: UpdateDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessUpdateDeviceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(updateDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send the verification email with an OTP in it the user has to reproduce.                This can be sent to anyone with a session; no need to have an account yet.
         * @param {VerifyEmailRequest} [verifyEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessVerifyEmailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(verifyEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This is the API call to verify the code.
         * @param {VerifyEmailCodeRequest} [verifyEmailCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailCode(verifyEmailCodeRequest?: VerifyEmailCodeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessVerifyEmailCodeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailCode(verifyEmailCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This is the verify for the the web; this is needed when you don\'t have an in-app functionality for settling the verification.
         * @param {string} uid 
         * @param {string} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailCodeByUID(uid: string, pin: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailCodeByUID(uid, pin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create Kyc
         * @param {KycLevelValues} [level] 
         * @param {KycDocumentTypeValues} [documentType] 
         * @param {any} [frontSideImage] 
         * @param {any} [backSideImage] 
         * @param {any} [frontFaceImage] 
         * @param {any} [proofOfAddressImage] 
         * @param {any} [proofOfIncomeImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyKycDocument(level?: KycLevelValues, documentType?: KycDocumentTypeValues, frontSideImage?: any, backSideImage?: any, frontFaceImage?: any, proofOfAddressImage?: any, proofOfIncomeImage?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessVerifyKycDocumentResultDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyKycDocument(level, documentType, frontSideImage, backSideImage, frontFaceImage, proofOfAddressImage, proofOfIncomeImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request verify mobile sms
         * @param {VerifyMobileRequest} [verifyMobileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMobile(verifyMobileRequest?: VerifyMobileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessVerifyMobileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMobile(verifyMobileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify sms
         * @param {VerifySMSRequest} [verifySMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifySMS(verifySMSRequest?: VerifySMSRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessVerifySMSDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifySMS(verifySMSRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Add contact
         * @param {AddContactRequest} [addContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContact(addContactRequest?: AddContactRequest, options?: any): AxiosPromise<SuccessAddContactDto> {
            return localVarFp.addContact(addContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adding mobile devices for a particular user.
         * @param {AddDeviceRequest} [addDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDevice(addDeviceRequest?: AddDeviceRequest, options?: any): AxiosPromise<SuccessAddDeviceDto> {
            return localVarFp.addDevice(addDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Should this be distinct from a version where we use password?
         * @param {string} [reference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canLogin(reference?: string, options?: any): AxiosPromise<SuccessCanLoginDto> {
            return localVarFp.canLogin(reference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create session
         * @param {CreateSessionRequest} [createSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequest?: CreateSessionRequest, options?: any): AxiosPromise<SuccessCreateSessionDto> {
            return localVarFp.createSession(createSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit contact
         * @param {EditContactRequest} [editContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContact(editContactRequest?: EditContactRequest, options?: any): AxiosPromise<SuccessEditContactDto> {
            return localVarFp.editContact(editContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchDevices(options?: any): AxiosPromise<SuccessFetchDevicesDto> {
            return localVarFp.fetchDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find User by email
         * @param {FindUserByMobileEmailRequest} [findUserByMobileEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByMobileEmail(findUserByMobileEmailRequest?: FindUserByMobileEmailRequest, options?: any): AxiosPromise<SuccessFindUserByMobileEmailDto> {
            return localVarFp.findUserByMobileEmail(findUserByMobileEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find user by mobile numer
         * @param {FindUserByMobileNumberRequest} [findUserByMobileNumberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByMobileNumber(findUserByMobileNumberRequest?: FindUserByMobileNumberRequest, options?: any): AxiosPromise<SuccessFindUserByMobileNumberDto> {
            return localVarFp.findUserByMobileNumber(findUserByMobileNumberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPin(forgotPinRequest?: ForgotPinRequest, options?: any): AxiosPromise<SuccessForgotPinDto> {
            return localVarFp.forgetPin(forgotPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forgot pin
         * @param {ForgotPinRequest} [forgotPinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPin(forgotPinRequest?: ForgotPinRequest, options?: any): AxiosPromise<SuccessForgotPinDto> {
            return localVarFp.forgotPin(forgotPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRegions(options?: any): AxiosPromise<GetAvailableRegionsSuccessDto> {
            return localVarFp.getAvailableRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(options?: any): AxiosPromise<SuccessGetContactsDto> {
            return localVarFp.getContacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get kyc for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc(options?: any): AxiosPromise<SuccessKycDtoResponse> {
            return localVarFp.getKyc(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the user profile; does the user has to be logged on ?
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(userId?: string, options?: any): AxiosPromise<SuccessGetProfileDto> {
            return localVarFp.getProfile(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Can only be called on *self* or by admin. This is PII information and hence it is heavy to retrieve from the db in production situations.                Note: this method does not have consistent return values; must fix!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<SuccessGetUserInfoDto> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSessionActive(sessionToken: string, options?: any): AxiosPromise<SuccessIsSessionActiveDto> {
            return localVarFp.isSessionActive(sessionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verifies the biometric message from the client for this user;  if it verifies, the user is allowed to continue, otherwise, not
         * @param {LoginBiometricsRequest} [loginBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginBiometrics(loginBiometricsRequest?: LoginBiometricsRequest, options?: any): AxiosPromise<SuccessLoginBiometricsDto> {
            return localVarFp.loginBiometrics(loginBiometricsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login by pin
         * @param {LoginPINRequest} [loginPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPIN(loginPINRequest?: LoginPINRequest, options?: any): AxiosPromise<SuccessLoginPINDto> {
            return localVarFp.loginPIN(loginPINRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simple login with a password.
         * @param {LoginPasswordRequest} [loginPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPassword(loginPasswordRequest?: LoginPasswordRequest, options?: any): AxiosPromise<SuccessLoginPINDto> {
            return localVarFp.loginPassword(loginPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(body?: object, options?: any): AxiosPromise<SuccessLogoutDto> {
            return localVarFp.logout(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove contact
         * @param {RemoveContactRequest} [removeContactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContact(removeContactRequest?: RemoveContactRequest, options?: any): AxiosPromise<SuccessRemoveContactDto> {
            return localVarFp.removeContact(removeContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend email
         * @param {ResendEmailRequest} [resendEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any): AxiosPromise<SuccessResendEmailDto> {
            return localVarFp.resendEmail(resendEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ResendSMS
         * @param {ResendSMSRequest} [resendSMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendSMS(resendSMSRequest?: ResendSMSRequest, options?: any): AxiosPromise<SuccessResendSMSDto> {
            return localVarFp.resendSMS(resendSMSRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This function stores the PIN the user picks, generate a keypair and store the frontend (app) generated  public key.
         * @param {SetAuthRequest} [setAuthRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAuth(setAuthRequest?: SetAuthRequest, options?: any): AxiosPromise<SuccessSetAuthDto> {
            return localVarFp.setAuth(setAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Should this be used for setting at a later time as welL?  We assume so
         * @param {SetBiometricsRequest} [setBiometricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBiometrics(setBiometricsRequest?: SetBiometricsRequest, options?: any): AxiosPromise<SuccessSetBiometricsDto> {
            return localVarFp.setBiometrics(setBiometricsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set pin
         * @param {SetPINRequest} [setPINRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPIN(setPINRequest?: SetPINRequest, options?: any): AxiosPromise<SuccessSetPINDto> {
            return localVarFp.setPIN(setPINRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Does the user has to be logged ON?
         * @param {string} [nickName] 
         * @param {string} [description] 
         * @param {any} [image] 
         * @param {boolean} [showNickName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfile(nickName?: string, description?: string, image?: any, showNickName?: boolean, options?: any): AxiosPromise<SuccessSetProfileDto> {
            return localVarFp.setProfile(nickName, description, image, showNickName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary use for test session expire
         * @param {SetSessionExpireRequest} [setSessionExpireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSessionExpire(setSessionExpireRequest?: SetSessionExpireRequest, options?: any): AxiosPromise<SuccessSetSessionExpireDto> {
            return localVarFp.setSessionExpire(setSessionExpireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserInfoRequest} [setUserInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserInfo(setUserInfoRequest?: SetUserInfoRequest, options?: any): AxiosPromise<SuccessSetUserInfoDto> {
            return localVarFp.setUserInfo(setUserInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Device info
         * @param {UpdateDeviceRequest} [updateDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(updateDeviceRequest?: UpdateDeviceRequest, options?: any): AxiosPromise<SuccessUpdateDeviceDto> {
            return localVarFp.updateDevice(updateDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send the verification email with an OTP in it the user has to reproduce.                This can be sent to anyone with a session; no need to have an account yet.
         * @param {VerifyEmailRequest} [verifyEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: any): AxiosPromise<SuccessVerifyEmailDto> {
            return localVarFp.verifyEmail(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This is the API call to verify the code.
         * @param {VerifyEmailCodeRequest} [verifyEmailCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailCode(verifyEmailCodeRequest?: VerifyEmailCodeRequest, options?: any): AxiosPromise<SuccessVerifyEmailCodeDto> {
            return localVarFp.verifyEmailCode(verifyEmailCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This is the verify for the the web; this is needed when you don\'t have an in-app functionality for settling the verification.
         * @param {string} uid 
         * @param {string} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailCodeByUID(uid: string, pin: string, options?: any): AxiosPromise<ContentResult> {
            return localVarFp.verifyEmailCodeByUID(uid, pin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create Kyc
         * @param {KycLevelValues} [level] 
         * @param {KycDocumentTypeValues} [documentType] 
         * @param {any} [frontSideImage] 
         * @param {any} [backSideImage] 
         * @param {any} [frontFaceImage] 
         * @param {any} [proofOfAddressImage] 
         * @param {any} [proofOfIncomeImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyKycDocument(level?: KycLevelValues, documentType?: KycDocumentTypeValues, frontSideImage?: any, backSideImage?: any, frontFaceImage?: any, proofOfAddressImage?: any, proofOfIncomeImage?: any, options?: any): AxiosPromise<SuccessVerifyKycDocumentResultDtoResponse> {
            return localVarFp.verifyKycDocument(level, documentType, frontSideImage, backSideImage, frontFaceImage, proofOfAddressImage, proofOfIncomeImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request verify mobile sms
         * @param {VerifyMobileRequest} [verifyMobileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMobile(verifyMobileRequest?: VerifyMobileRequest, options?: any): AxiosPromise<SuccessVerifyMobileDto> {
            return localVarFp.verifyMobile(verifyMobileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify sms
         * @param {VerifySMSRequest} [verifySMSRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifySMS(verifySMSRequest?: VerifySMSRequest, options?: any): AxiosPromise<SuccessVerifySMSDto> {
            return localVarFp.verifySMS(verifySMSRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Add contact
     * @param {AddContactRequest} [addContactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addContact(addContactRequest?: AddContactRequest, options?: any) {
        return UserApiFp(this.configuration).addContact(addContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adding mobile devices for a particular user.
     * @param {AddDeviceRequest} [addDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addDevice(addDeviceRequest?: AddDeviceRequest, options?: any) {
        return UserApiFp(this.configuration).addDevice(addDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Should this be distinct from a version where we use password?
     * @param {string} [reference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public canLogin(reference?: string, options?: any) {
        return UserApiFp(this.configuration).canLogin(reference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create session
     * @param {CreateSessionRequest} [createSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createSession(createSessionRequest?: CreateSessionRequest, options?: any) {
        return UserApiFp(this.configuration).createSession(createSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit contact
     * @param {EditContactRequest} [editContactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editContact(editContactRequest?: EditContactRequest, options?: any) {
        return UserApiFp(this.configuration).editContact(editContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public fetchDevices(options?: any) {
        return UserApiFp(this.configuration).fetchDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find User by email
     * @param {FindUserByMobileEmailRequest} [findUserByMobileEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public findUserByMobileEmail(findUserByMobileEmailRequest?: FindUserByMobileEmailRequest, options?: any) {
        return UserApiFp(this.configuration).findUserByMobileEmail(findUserByMobileEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find user by mobile numer
     * @param {FindUserByMobileNumberRequest} [findUserByMobileNumberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public findUserByMobileNumber(findUserByMobileNumberRequest?: FindUserByMobileNumberRequest, options?: any) {
        return UserApiFp(this.configuration).findUserByMobileNumber(findUserByMobileNumberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPinRequest} [forgotPinRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgetPin(forgotPinRequest?: ForgotPinRequest, options?: any) {
        return UserApiFp(this.configuration).forgetPin(forgotPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forgot pin
     * @param {ForgotPinRequest} [forgotPinRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPin(forgotPinRequest?: ForgotPinRequest, options?: any) {
        return UserApiFp(this.configuration).forgotPin(forgotPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAvailableRegions(options?: any) {
        return UserApiFp(this.configuration).getAvailableRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getContacts(options?: any) {
        return UserApiFp(this.configuration).getContacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get kyc for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getKyc(options?: any) {
        return UserApiFp(this.configuration).getKyc(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the user profile; does the user has to be logged on ?
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfile(userId?: string, options?: any) {
        return UserApiFp(this.configuration).getProfile(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Can only be called on *self* or by admin. This is PII information and hence it is heavy to retrieve from the db in production situations.                Note: this method does not have consistent return values; must fix!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public isSessionActive(sessionToken: string, options?: any) {
        return UserApiFp(this.configuration).isSessionActive(sessionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verifies the biometric message from the client for this user;  if it verifies, the user is allowed to continue, otherwise, not
     * @param {LoginBiometricsRequest} [loginBiometricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginBiometrics(loginBiometricsRequest?: LoginBiometricsRequest, options?: any) {
        return UserApiFp(this.configuration).loginBiometrics(loginBiometricsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login by pin
     * @param {LoginPINRequest} [loginPINRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginPIN(loginPINRequest?: LoginPINRequest, options?: any) {
        return UserApiFp(this.configuration).loginPIN(loginPINRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simple login with a password.
     * @param {LoginPasswordRequest} [loginPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginPassword(loginPasswordRequest?: LoginPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).loginPassword(loginPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logout(body?: object, options?: any) {
        return UserApiFp(this.configuration).logout(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove contact
     * @param {RemoveContactRequest} [removeContactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeContact(removeContactRequest?: RemoveContactRequest, options?: any) {
        return UserApiFp(this.configuration).removeContact(removeContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend email
     * @param {ResendEmailRequest} [resendEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resendEmail(resendEmailRequest?: ResendEmailRequest, options?: any) {
        return UserApiFp(this.configuration).resendEmail(resendEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ResendSMS
     * @param {ResendSMSRequest} [resendSMSRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resendSMS(resendSMSRequest?: ResendSMSRequest, options?: any) {
        return UserApiFp(this.configuration).resendSMS(resendSMSRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This function stores the PIN the user picks, generate a keypair and store the frontend (app) generated  public key.
     * @param {SetAuthRequest} [setAuthRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setAuth(setAuthRequest?: SetAuthRequest, options?: any) {
        return UserApiFp(this.configuration).setAuth(setAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Should this be used for setting at a later time as welL?  We assume so
     * @param {SetBiometricsRequest} [setBiometricsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setBiometrics(setBiometricsRequest?: SetBiometricsRequest, options?: any) {
        return UserApiFp(this.configuration).setBiometrics(setBiometricsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set pin
     * @param {SetPINRequest} [setPINRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setPIN(setPINRequest?: SetPINRequest, options?: any) {
        return UserApiFp(this.configuration).setPIN(setPINRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Does the user has to be logged ON?
     * @param {string} [nickName] 
     * @param {string} [description] 
     * @param {any} [image] 
     * @param {boolean} [showNickName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setProfile(nickName?: string, description?: string, image?: any, showNickName?: boolean, options?: any) {
        return UserApiFp(this.configuration).setProfile(nickName, description, image, showNickName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary use for test session expire
     * @param {SetSessionExpireRequest} [setSessionExpireRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setSessionExpire(setSessionExpireRequest?: SetSessionExpireRequest, options?: any) {
        return UserApiFp(this.configuration).setSessionExpire(setSessionExpireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserInfoRequest} [setUserInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setUserInfo(setUserInfoRequest?: SetUserInfoRequest, options?: any) {
        return UserApiFp(this.configuration).setUserInfo(setUserInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Device info
     * @param {UpdateDeviceRequest} [updateDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateDevice(updateDeviceRequest?: UpdateDeviceRequest, options?: any) {
        return UserApiFp(this.configuration).updateDevice(updateDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send the verification email with an OTP in it the user has to reproduce.                This can be sent to anyone with a session; no need to have an account yet.
     * @param {VerifyEmailRequest} [verifyEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: any) {
        return UserApiFp(this.configuration).verifyEmail(verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This is the API call to verify the code.
     * @param {VerifyEmailCodeRequest} [verifyEmailCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyEmailCode(verifyEmailCodeRequest?: VerifyEmailCodeRequest, options?: any) {
        return UserApiFp(this.configuration).verifyEmailCode(verifyEmailCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This is the verify for the the web; this is needed when you don\'t have an in-app functionality for settling the verification.
     * @param {string} uid 
     * @param {string} pin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyEmailCodeByUID(uid: string, pin: string, options?: any) {
        return UserApiFp(this.configuration).verifyEmailCodeByUID(uid, pin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create Kyc
     * @param {KycLevelValues} [level] 
     * @param {KycDocumentTypeValues} [documentType] 
     * @param {any} [frontSideImage] 
     * @param {any} [backSideImage] 
     * @param {any} [frontFaceImage] 
     * @param {any} [proofOfAddressImage] 
     * @param {any} [proofOfIncomeImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyKycDocument(level?: KycLevelValues, documentType?: KycDocumentTypeValues, frontSideImage?: any, backSideImage?: any, frontFaceImage?: any, proofOfAddressImage?: any, proofOfIncomeImage?: any, options?: any) {
        return UserApiFp(this.configuration).verifyKycDocument(level, documentType, frontSideImage, backSideImage, frontFaceImage, proofOfAddressImage, proofOfIncomeImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request verify mobile sms
     * @param {VerifyMobileRequest} [verifyMobileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifyMobile(verifyMobileRequest?: VerifyMobileRequest, options?: any) {
        return UserApiFp(this.configuration).verifyMobile(verifyMobileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify sms
     * @param {VerifySMSRequest} [verifySMSRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public verifySMS(verifySMSRequest?: VerifySMSRequest, options?: any) {
        return UserApiFp(this.configuration).verifySMS(verifySMSRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VenueApi - axios parameter creator
 * @export
 */
export const VenueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add merchant
         * @param {AddMerchantRequest} [addMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMerchant: async (addMerchantRequest?: AddMerchantRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/addmerchant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMerchantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add venue to merchant
         * @param {AddVenueRequest} [addVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenue: async (addVenueRequest?: AddVenueRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/addvenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit venue
         * @param {EditVenueRequest} [editVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVenue: async (editVenueRequest?: EditVenueRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/editvenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreeVenues: async (lat: number, lng: number, distanceKm?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('getFreeVenues', 'lat', lat)
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('getFreeVenues', 'lng', lng)
            const localVarPath = `/api/v1/venue/getfreevenues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (distanceKm !== undefined) {
                localVarQueryParameter['distanceKm'] = distanceKm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get venue lock status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockStatus: async (venueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('getLockStatus', 'venueId', venueId)
            const localVarPath = `/api/v1/venue/getlockstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get merchants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchants: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/getmerchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get venue policy
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (venueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('getPolicy', 'venueId', venueId)
            const localVarPath = `/api/v1/venue/getpolicy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info which in venue
         * @param {string} venueId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (venueId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('getUser', 'venueId', venueId)
            const localVarPath = `/api/v1/venue/getuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users in venue
         * @param {string} venueId 
         * @param {boolean} [validated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (venueId: string, validated?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('getUsers', 'venueId', venueId)
            const localVarPath = `/api/v1/venue/getusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get venue info
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenue: async (venueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'venueId' is not null or undefined
            assertParamExists('getVenue', 'venueId', venueId)
            const localVarPath = `/api/v1/venue/getvenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenues: async (lat: number, lng: number, distanceKm?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('getVenues', 'lat', lat)
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('getVenues', 'lng', lng)
            const localVarPath = `/api/v1/venue/getvenues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (distanceKm !== undefined) {
                localVarQueryParameter['distanceKm'] = distanceKm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join user to venue
         * @param {JoinVenueRequest} [joinVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinVenue: async (joinVenueRequest?: JoinVenueRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/joinvenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave user out venue
         * @param {LeaveVenueRequest} [leaveVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveVenue: async (leaveVenueRequest?: LeaveVenueRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/leavevenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveVenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary lock venue activity
         * @param {LockActivityRequest} [lockActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockActivity: async (lockActivityRequest?: LockActivityRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/lockactivity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user out venue
         * @param {RemoveUserRequest} [removeUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (removeUserRequest?: RemoveUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/removeuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set venue policy
         * @param {SetPolicyRequest} [setPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPolicy: async (setPolicyRequest?: SetPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/setpolicy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set active status or not for user in venue
         * @param {SetUserStatusRequest} [setUserStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserStatus: async (setUserStatusRequest?: SetUserStatusRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/venue/setuserstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VenueApi - functional programming interface
 * @export
 */
export const VenueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VenueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add merchant
         * @param {AddMerchantRequest} [addMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMerchant(addMerchantRequest?: AddMerchantRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddMerchantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMerchant(addMerchantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add venue to merchant
         * @param {AddVenueRequest} [addVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVenue(addVenueRequest?: AddVenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVenue(addVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit venue
         * @param {EditVenueRequest} [editVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editVenue(editVenueRequest?: EditVenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessEditVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editVenue(editVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreeVenues(lat: number, lng: number, distanceKm?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetFreeVenuesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreeVenues(lat, lng, distanceKm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get venue lock status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLockStatus(venueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetLockStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLockStatus(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get merchants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchants(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetMerchantsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get venue policy
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(venueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user info which in venue
         * @param {string} venueId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(venueId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(venueId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get users in venue
         * @param {string} venueId 
         * @param {boolean} [validated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(venueId: string, validated?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetUsersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(venueId, validated, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get venue info
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenue(venueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVenue(venueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenues(lat: number, lng: number, distanceKm?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetVenuesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVenues(lat, lng, distanceKm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join user to venue
         * @param {JoinVenueRequest} [joinVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinVenue(joinVenueRequest?: JoinVenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessJoinVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinVenue(joinVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave user out venue
         * @param {LeaveVenueRequest} [leaveVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveVenue(leaveVenueRequest?: LeaveVenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLeaveVenueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveVenue(leaveVenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary lock venue activity
         * @param {LockActivityRequest} [lockActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockActivity(lockActivityRequest?: LockActivityRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLockActivityDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockActivity(lockActivityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove user out venue
         * @param {RemoveUserRequest} [removeUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(removeUserRequest?: RemoveUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRemoveUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUser(removeUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set venue policy
         * @param {SetPolicyRequest} [setPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPolicy(setPolicyRequest?: SetPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPolicy(setPolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set active status or not for user in venue
         * @param {SetUserStatusRequest} [setUserStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserStatus(setUserStatusRequest?: SetUserStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetUserStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserStatus(setUserStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VenueApi - factory interface
 * @export
 */
export const VenueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VenueApiFp(configuration)
    return {
        /**
         * 
         * @summary Add merchant
         * @param {AddMerchantRequest} [addMerchantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMerchant(addMerchantRequest?: AddMerchantRequest, options?: any): AxiosPromise<SuccessAddMerchantDto> {
            return localVarFp.addMerchant(addMerchantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add venue to merchant
         * @param {AddVenueRequest} [addVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenue(addVenueRequest?: AddVenueRequest, options?: any): AxiosPromise<SuccessAddVenueDto> {
            return localVarFp.addVenue(addVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit venue
         * @param {EditVenueRequest} [editVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVenue(editVenueRequest?: EditVenueRequest, options?: any): AxiosPromise<SuccessEditVenueDto> {
            return localVarFp.editVenue(editVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreeVenues(lat: number, lng: number, distanceKm?: number, options?: any): AxiosPromise<SuccessGetFreeVenuesDto> {
            return localVarFp.getFreeVenues(lat, lng, distanceKm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get venue lock status
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockStatus(venueId: string, options?: any): AxiosPromise<SuccessGetLockStatusDto> {
            return localVarFp.getLockStatus(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get merchants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchants(options?: any): AxiosPromise<SuccessGetMerchantsDto> {
            return localVarFp.getMerchants(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get venue policy
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(venueId: string, options?: any): AxiosPromise<SuccessGetPolicyDto> {
            return localVarFp.getPolicy(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info which in venue
         * @param {string} venueId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(venueId: string, userId?: string, options?: any): AxiosPromise<SuccessGetUserDto> {
            return localVarFp.getUser(venueId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users in venue
         * @param {string} venueId 
         * @param {boolean} [validated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(venueId: string, validated?: boolean, options?: any): AxiosPromise<SuccessGetUsersDto> {
            return localVarFp.getUsers(venueId, validated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get venue info
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenue(venueId: string, options?: any): AxiosPromise<SuccessGetVenueDto> {
            return localVarFp.getVenue(venueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all active venues around some lat/lng
         * @param {number} lat latitude
         * @param {number} lng longitude
         * @param {number} [distanceKm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVenues(lat: number, lng: number, distanceKm?: number, options?: any): AxiosPromise<SuccessGetVenuesDto> {
            return localVarFp.getVenues(lat, lng, distanceKm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join user to venue
         * @param {JoinVenueRequest} [joinVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinVenue(joinVenueRequest?: JoinVenueRequest, options?: any): AxiosPromise<SuccessJoinVenueDto> {
            return localVarFp.joinVenue(joinVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave user out venue
         * @param {LeaveVenueRequest} [leaveVenueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveVenue(leaveVenueRequest?: LeaveVenueRequest, options?: any): AxiosPromise<SuccessLeaveVenueDto> {
            return localVarFp.leaveVenue(leaveVenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary lock venue activity
         * @param {LockActivityRequest} [lockActivityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockActivity(lockActivityRequest?: LockActivityRequest, options?: any): AxiosPromise<SuccessLockActivityDto> {
            return localVarFp.lockActivity(lockActivityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user out venue
         * @param {RemoveUserRequest} [removeUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(removeUserRequest?: RemoveUserRequest, options?: any): AxiosPromise<SuccessRemoveUserDto> {
            return localVarFp.removeUser(removeUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set venue policy
         * @param {SetPolicyRequest} [setPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPolicy(setPolicyRequest?: SetPolicyRequest, options?: any): AxiosPromise<SuccessSetPolicyDto> {
            return localVarFp.setPolicy(setPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set active status or not for user in venue
         * @param {SetUserStatusRequest} [setUserStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserStatus(setUserStatusRequest?: SetUserStatusRequest, options?: any): AxiosPromise<SuccessSetUserStatusDto> {
            return localVarFp.setUserStatus(setUserStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VenueApi - object-oriented interface
 * @export
 * @class VenueApi
 * @extends {BaseAPI}
 */
export class VenueApi extends BaseAPI {
    /**
     * 
     * @summary Add merchant
     * @param {AddMerchantRequest} [addMerchantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public addMerchant(addMerchantRequest?: AddMerchantRequest, options?: any) {
        return VenueApiFp(this.configuration).addMerchant(addMerchantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add venue to merchant
     * @param {AddVenueRequest} [addVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public addVenue(addVenueRequest?: AddVenueRequest, options?: any) {
        return VenueApiFp(this.configuration).addVenue(addVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit venue
     * @param {EditVenueRequest} [editVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public editVenue(editVenueRequest?: EditVenueRequest, options?: any) {
        return VenueApiFp(this.configuration).editVenue(editVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all active venues around some lat/lng
     * @param {number} lat latitude
     * @param {number} lng longitude
     * @param {number} [distanceKm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getFreeVenues(lat: number, lng: number, distanceKm?: number, options?: any) {
        return VenueApiFp(this.configuration).getFreeVenues(lat, lng, distanceKm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get venue lock status
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getLockStatus(venueId: string, options?: any) {
        return VenueApiFp(this.configuration).getLockStatus(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get merchants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getMerchants(options?: any) {
        return VenueApiFp(this.configuration).getMerchants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get venue policy
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getPolicy(venueId: string, options?: any) {
        return VenueApiFp(this.configuration).getPolicy(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info which in venue
     * @param {string} venueId 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getUser(venueId: string, userId?: string, options?: any) {
        return VenueApiFp(this.configuration).getUser(venueId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users in venue
     * @param {string} venueId 
     * @param {boolean} [validated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getUsers(venueId: string, validated?: boolean, options?: any) {
        return VenueApiFp(this.configuration).getUsers(venueId, validated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get venue info
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getVenue(venueId: string, options?: any) {
        return VenueApiFp(this.configuration).getVenue(venueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all active venues around some lat/lng
     * @param {number} lat latitude
     * @param {number} lng longitude
     * @param {number} [distanceKm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public getVenues(lat: number, lng: number, distanceKm?: number, options?: any) {
        return VenueApiFp(this.configuration).getVenues(lat, lng, distanceKm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join user to venue
     * @param {JoinVenueRequest} [joinVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public joinVenue(joinVenueRequest?: JoinVenueRequest, options?: any) {
        return VenueApiFp(this.configuration).joinVenue(joinVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave user out venue
     * @param {LeaveVenueRequest} [leaveVenueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public leaveVenue(leaveVenueRequest?: LeaveVenueRequest, options?: any) {
        return VenueApiFp(this.configuration).leaveVenue(leaveVenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary lock venue activity
     * @param {LockActivityRequest} [lockActivityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public lockActivity(lockActivityRequest?: LockActivityRequest, options?: any) {
        return VenueApiFp(this.configuration).lockActivity(lockActivityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user out venue
     * @param {RemoveUserRequest} [removeUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public removeUser(removeUserRequest?: RemoveUserRequest, options?: any) {
        return VenueApiFp(this.configuration).removeUser(removeUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set venue policy
     * @param {SetPolicyRequest} [setPolicyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public setPolicy(setPolicyRequest?: SetPolicyRequest, options?: any) {
        return VenueApiFp(this.configuration).setPolicy(setPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set active status or not for user in venue
     * @param {SetUserStatusRequest} [setUserStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenueApi
     */
    public setUserStatus(setUserStatusRequest?: SetUserStatusRequest, options?: any) {
        return VenueApiFp(this.configuration).setUserStatus(setUserStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an existing bank account to the PMIs of the user.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {AddBankAccountRequest} [addBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBankAccount: async (addBankAccountRequest?: AddBankAccountRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/addbankaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBankAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddCardRequest} [addCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCard: async (addCardRequest?: AddCardRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/addcard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an internal custodian account; this acccount is held with a 3rd party provider (including SimSecSecure) for storing user crypto currency  amounts. The user does not have the private key for this account which allows security for TFX over the funds.
         * @param {AddCustodianCryptoRequest} [addCustodianCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustodianCrypto: async (addCustodianCryptoRequest?: AddCustodianCryptoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/addcustodiancrypto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCustodianCryptoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add prepaid account
         * @param {AddPrepaidAccountRequest} [addPrepaidAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrepaidAccount: async (addPrepaidAccountRequest?: AddPrepaidAccountRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/addprepaidaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addPrepaidAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary current user decline fund request
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineUserFundRequest: async (declineUserFundRequest?: DeclineUserFundRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/declineuserfundrequest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineUserFundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineUserFundRequestByChat: async (declineUserFundRequest?: DeclineUserFundRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/declineuserfundrequestbychat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineUserFundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Use to delete payment Method
         * @param {DeletePaymentMethodRequest} [deletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod: async (deletePaymentMethodRequest?: DeletePaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/deletepaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete current user
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/deleteuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit payment method
         * @param {EditPaymentMethodRequest} [editPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentMethod: async (editPaymentMethodRequest?: EditPaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/editpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an exchange, in your own account, from PMI to PMI. The conversion from currency to currency will be automatic and fees will be added automatically.
         * @param {ExchangePaymentRequest} [exchangePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangePayment: async (exchangePaymentRequest?: ExchangePaymentRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/exchangepayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available cryptocurrency/blockchain methods that are available to this user. The response contains all information needed to   add payment methods to the wallet of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCrypto: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getavailablecrypto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the available methods for the user in the region of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaymentMethods: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getavailablepaymentmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment method instance balance
         * @param {string} paymentMethodId payment method instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (paymentMethodId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getBalance', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/v1/wallet/getbalance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get conversion rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversionRates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getconversionrates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the avialable types for currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyTypeValues: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getcurrencytypevalues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (wallet?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getdashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wallet !== undefined) {
                localVarQueryParameter['wallet'] = wallet;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the exchange rate for the provided currency conversion, including the amount calculation.
         * @param {string} fromCurrencyId 
         * @param {string} toCurrencyId 
         * @param {number} amount 
         * @param {string} [method] Can be internal, exchange, bank, card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate: async (fromCurrencyId: string, toCurrencyId: string, amount: number, method?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromCurrencyId' is not null or undefined
            assertParamExists('getExchangeRate', 'fromCurrencyId', fromCurrencyId)
            // verify required parameter 'toCurrencyId' is not null or undefined
            assertParamExists('getExchangeRate', 'toCurrencyId', toCurrencyId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('getExchangeRate', 'amount', amount)
            const localVarPath = `/api/v1/wallet/getexchangerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromCurrencyId !== undefined) {
                localVarQueryParameter['fromCurrencyId'] = fromCurrencyId;
            }

            if (toCurrencyId !== undefined) {
                localVarQueryParameter['toCurrencyId'] = toCurrencyId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the payment method for this user
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (paymentMethodId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getPaymentMethod', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/v1/wallet/getpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment methods
         * @param {string} [baseType] 
         * @param {string} [walletName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods: async (baseType?: string, walletName?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getpaymentmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (baseType !== undefined) {
                localVarQueryParameter['baseType'] = baseType;
            }

            if (walletName !== undefined) {
                localVarQueryParameter['walletName'] = walletName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment method instance settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreferences: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getpreferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get request fund send to current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundById: async (requestFundId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestFundId' is not null or undefined
            assertParamExists('getRequestFundById', 'requestFundId', requestFundId)
            const localVarPath = `/api/v1/wallet/getrequestfundbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestFundId !== undefined) {
                localVarQueryParameter['requestFundId'] = requestFundId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get request fund send from current user by request fund id
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundToUserById: async (requestFundId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestFundId' is not null or undefined
            assertParamExists('getRequestFundToUserById', 'requestFundId', requestFundId)
            const localVarPath = `/api/v1/wallet/getrequestfundtouserbyid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestFundId !== undefined) {
                localVarQueryParameter['requestFundId'] = requestFundId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsFromUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getrequestfundsfromusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all requested funds from current user to other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsToUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getrequestfundstousers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsViaLink: async (requestFundId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestFundId' is not null or undefined
            assertParamExists('getRequestFundsViaLink', 'requestFundId', requestFundId)
            const localVarPath = `/api/v1/wallet/getrequestfundsvialink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestFundId !== undefined) {
                localVarQueryParameter['requestFundId'] = requestFundId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction for payment method instance
         * @param {string} paymentMethodId 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (paymentMethodId: string, page?: number, itemCount?: number, beginDate?: string, endDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getTransactions', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/v1/wallet/gettransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (beginDate !== undefined) {
                localVarQueryParameter['beginDate'] = (beginDate as any instanceof Date) ?
                    (beginDate as any).toISOString() :
                    beginDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get app version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wallet info for a specific user and wallet
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getwallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wallets for a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/getwallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock payment method instance
         * @param {LockPaymentMethodRequest} [lockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPaymentMethod: async (lockPaymentMethodRequest?: LockPaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/lockpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pay request fund via link
         * @param {PayRequestFundViaLinkRequest} [payRequestFundViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payRequestFundViaLink: async (payRequestFundViaLinkRequest?: PayRequestFundViaLinkRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/payrequestfundvialink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payRequestFundViaLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary current user pay for user fund request
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payUserFundRequest: async (payUserFundRequest?: PayUserFundRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/payuserfundrequest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payUserFundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payUserFundRequestByChat: async (payUserFundRequest?: PayUserFundRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/payuserfundrequestbychat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payUserFundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request fund from user
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundToUser: async (requestFundToUserRequest?: RequestFundToUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/requestfundtouser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestFundToUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundToUserByChat: async (requestFundToUserRequest?: RequestFundToUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/requestfundtouserbychat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestFundToUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request funds via link``
         * @param {RequestFundsViaLinkRequest} [requestFundsViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundsViaLink: async (requestFundsViaLinkRequest?: RequestFundsViaLinkRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/requestfundsvialink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestFundsViaLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send funds from a payment method to an external bank account. This external account can be SWIFT or local account.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {SendToBankRequest} [sendToBankRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToBank: async (sendToBankRequest?: SendToBankRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/sendtobank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendToBankRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send funds to an external crypto address. The user must ensure the address is correct or funds will be lost.
         * @param {SendToCryptoRequest} [sendToCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToCrypto: async (sendToCryptoRequest?: SendToCryptoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/sendtocrypto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendToCryptoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToUser: async (sendToUserRequest?: SendToUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/sendtouser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendToUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send To User in chat page
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToUserByChat: async (sendToUserRequest?: SendToUserRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/sendtouserbychat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendToUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the main bank account for this user to use for incoming(!) payments.
         * @param {SetMainBankAccountRequest} [setMainBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMainBankAccount: async (setMainBankAccountRequest?: SetMainBankAccountRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/setmainbankaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setMainBankAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set payment method instance setting
         * @param {SetPreferenceRequest} [setPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPreference: async (setPreferenceRequest?: SetPreferenceRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/setpreference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPreferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlock payment method instance
         * @param {UnlockPaymentMethodRequest} [unlockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPaymentMethod: async (unlockPaymentMethodRequest?: UnlockPaymentMethodRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/unlockpaymentmethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unlockPaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an existing bank account to the PMIs of the user.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {AddBankAccountRequest} [addBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBankAccount(addBankAccountRequest?: AddBankAccountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddBankAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBankAccount(addBankAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AddCardRequest} [addCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCard(addCardRequest?: AddCardRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddCardDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCard(addCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds an internal custodian account; this acccount is held with a 3rd party provider (including SimSecSecure) for storing user crypto currency  amounts. The user does not have the private key for this account which allows security for TFX over the funds.
         * @param {AddCustodianCryptoRequest} [addCustodianCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustodianCrypto(addCustodianCryptoRequest?: AddCustodianCryptoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddCustodianCryptoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCustodianCrypto(addCustodianCryptoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add prepaid account
         * @param {AddPrepaidAccountRequest} [addPrepaidAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPrepaidAccount(addPrepaidAccountRequest?: AddPrepaidAccountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessAddPrepaidAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPrepaidAccount(addPrepaidAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary current user decline fund request
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineUserFundRequest(declineUserFundRequest?: DeclineUserFundRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeclineUserFundRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineUserFundRequest(declineUserFundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineUserFundRequestByChat(declineUserFundRequest?: DeclineUserFundRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeclineUserFundRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineUserFundRequestByChat(declineUserFundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Use to delete payment Method
         * @param {DeletePaymentMethodRequest} [deletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethod(deletePaymentMethodRequest?: DeletePaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeletePaymentMethodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethod(deletePaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete current user
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDeleteUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit payment method
         * @param {EditPaymentMethodRequest} [editPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPaymentMethod(editPaymentMethodRequest?: EditPaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessEditPaymentMethodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPaymentMethod(editPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an exchange, in your own account, from PMI to PMI. The conversion from currency to currency will be automatic and fees will be added automatically.
         * @param {ExchangePaymentRequest} [exchangePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangePayment(exchangePaymentRequest?: ExchangePaymentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessExchangePaymentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangePayment(exchangePaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available cryptocurrency/blockchain methods that are available to this user. The response contains all information needed to   add payment methods to the wallet of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableCrypto(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetAvailableCryptoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableCrypto(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the available methods for the user in the region of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailablePaymentMethods(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetAvailablePaymentMethodsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailablePaymentMethods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payment method instance balance
         * @param {string} paymentMethodId payment method instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(paymentMethodId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetBalanceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(paymentMethodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get conversion rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversionRates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetConversionRatesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversionRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the avialable types for currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyTypeValues(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessCurrencyTypeValuesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyTypeValues(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(wallet?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetDashboardDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(wallet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the exchange rate for the provided currency conversion, including the amount calculation.
         * @param {string} fromCurrencyId 
         * @param {string} toCurrencyId 
         * @param {number} amount 
         * @param {string} [method] Can be internal, exchange, bank, card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeRate(fromCurrencyId: string, toCurrencyId: string, amount: number, method?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetExchangeRateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeRate(fromCurrencyId, toCurrencyId, amount, method, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the payment method for this user
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(paymentMethodId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPaymentMethodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(paymentMethodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payment methods
         * @param {string} [baseType] 
         * @param {string} [walletName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethods(baseType?: string, walletName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPaymentMethodsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethods(baseType, walletName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payment method instance settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreferences(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetPaymentMethodInstanceSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get request fund send to current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestFundById(requestFundId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRequestFundByIdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestFundById(requestFundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get request fund send from current user by request fund id
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestFundToUserById(requestFundId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRequestFundToUserByIdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestFundToUserById(requestFundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestFundsFromUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRequestFundsFromUsersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestFundsFromUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all requested funds from current user to other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestFundsToUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRequestFundsToUsersDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestFundsToUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestFundsViaLink(requestFundId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetRequestFundsViaLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestFundsViaLink(requestFundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction for payment method instance
         * @param {string} paymentMethodId 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(paymentMethodId: string, page?: number, itemCount?: number, beginDate?: string, endDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetTransactionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(paymentMethodId, page, itemCount, beginDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get app version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetVersionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get wallet info for a specific user and wallet
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessGetWalletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all wallets for a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessListWalletDtoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lock payment method instance
         * @param {LockPaymentMethodRequest} [lockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockPaymentMethod(lockPaymentMethodRequest?: LockPaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessLockPaymentMethodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockPaymentMethod(lockPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pay request fund via link
         * @param {PayRequestFundViaLinkRequest} [payRequestFundViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payRequestFundViaLink(payRequestFundViaLinkRequest?: PayRequestFundViaLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessPayRequestFundViaLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payRequestFundViaLink(payRequestFundViaLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary current user pay for user fund request
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payUserFundRequest(payUserFundRequest?: PayUserFundRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessPayUserFundRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payUserFundRequest(payUserFundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payUserFundRequestByChat(payUserFundRequest?: PayUserFundRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessPayUserFundRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payUserFundRequestByChat(payUserFundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request fund from user
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestFundToUser(requestFundToUserRequest?: RequestFundToUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRequestFundToUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFundToUser(requestFundToUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestFundToUserByChat(requestFundToUserRequest?: RequestFundToUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRequestFundToUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFundToUserByChat(requestFundToUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request funds via link``
         * @param {RequestFundsViaLinkRequest} [requestFundsViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestFundsViaLink(requestFundsViaLinkRequest?: RequestFundsViaLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessRequestFundsViaLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFundsViaLink(requestFundsViaLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send funds from a payment method to an external bank account. This external account can be SWIFT or local account.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {SendToBankRequest} [sendToBankRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendToBank(sendToBankRequest?: SendToBankRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendToBankDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendToBank(sendToBankRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send funds to an external crypto address. The user must ensure the address is correct or funds will be lost.
         * @param {SendToCryptoRequest} [sendToCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendToCrypto(sendToCryptoRequest?: SendToCryptoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendToCryptoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendToCrypto(sendToCryptoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendToUser(sendToUserRequest?: SendToUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendToUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendToUser(sendToUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send To User in chat page
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendToUserByChat(sendToUserRequest?: SendToUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSendToUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendToUserByChat(sendToUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set the main bank account for this user to use for incoming(!) payments.
         * @param {SetMainBankAccountRequest} [setMainBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMainBankAccount(setMainBankAccountRequest?: SetMainBankAccountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetMainBankAccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMainBankAccount(setMainBankAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set payment method instance setting
         * @param {SetPreferenceRequest} [setPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPreference(setPreferenceRequest?: SetPreferenceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessSetPaymentMethodInstanceSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPreference(setPreferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlock payment method instance
         * @param {UnlockPaymentMethodRequest} [unlockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockPaymentMethod(unlockPaymentMethodRequest?: UnlockPaymentMethodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessUnlockPaymentMethodDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockPaymentMethod(unlockPaymentMethodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an existing bank account to the PMIs of the user.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {AddBankAccountRequest} [addBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBankAccount(addBankAccountRequest?: AddBankAccountRequest, options?: any): AxiosPromise<SuccessAddBankAccountDto> {
            return localVarFp.addBankAccount(addBankAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddCardRequest} [addCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCard(addCardRequest?: AddCardRequest, options?: any): AxiosPromise<SuccessAddCardDto> {
            return localVarFp.addCard(addCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an internal custodian account; this acccount is held with a 3rd party provider (including SimSecSecure) for storing user crypto currency  amounts. The user does not have the private key for this account which allows security for TFX over the funds.
         * @param {AddCustodianCryptoRequest} [addCustodianCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustodianCrypto(addCustodianCryptoRequest?: AddCustodianCryptoRequest, options?: any): AxiosPromise<SuccessAddCustodianCryptoDto> {
            return localVarFp.addCustodianCrypto(addCustodianCryptoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add prepaid account
         * @param {AddPrepaidAccountRequest} [addPrepaidAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrepaidAccount(addPrepaidAccountRequest?: AddPrepaidAccountRequest, options?: any): AxiosPromise<SuccessAddPrepaidAccountDto> {
            return localVarFp.addPrepaidAccount(addPrepaidAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary current user decline fund request
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineUserFundRequest(declineUserFundRequest?: DeclineUserFundRequest, options?: any): AxiosPromise<SuccessDeclineUserFundRequestDto> {
            return localVarFp.declineUserFundRequest(declineUserFundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeclineUserFundRequest} [declineUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineUserFundRequestByChat(declineUserFundRequest?: DeclineUserFundRequest, options?: any): AxiosPromise<SuccessDeclineUserFundRequestDto> {
            return localVarFp.declineUserFundRequestByChat(declineUserFundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Use to delete payment Method
         * @param {DeletePaymentMethodRequest} [deletePaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(deletePaymentMethodRequest?: DeletePaymentMethodRequest, options?: any): AxiosPromise<SuccessDeletePaymentMethodDto> {
            return localVarFp.deletePaymentMethod(deletePaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete current user
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(body?: object, options?: any): AxiosPromise<SuccessDeleteUserDto> {
            return localVarFp.deleteUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit payment method
         * @param {EditPaymentMethodRequest} [editPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPaymentMethod(editPaymentMethodRequest?: EditPaymentMethodRequest, options?: any): AxiosPromise<SuccessEditPaymentMethodDto> {
            return localVarFp.editPaymentMethod(editPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an exchange, in your own account, from PMI to PMI. The conversion from currency to currency will be automatic and fees will be added automatically.
         * @param {ExchangePaymentRequest} [exchangePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangePayment(exchangePaymentRequest?: ExchangePaymentRequest, options?: any): AxiosPromise<SuccessExchangePaymentDto> {
            return localVarFp.exchangePayment(exchangePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available cryptocurrency/blockchain methods that are available to this user. The response contains all information needed to   add payment methods to the wallet of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCrypto(options?: any): AxiosPromise<SuccessGetAvailableCryptoDto> {
            return localVarFp.getAvailableCrypto(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the available methods for the user in the region of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailablePaymentMethods(options?: any): AxiosPromise<SuccessGetAvailablePaymentMethodsDto> {
            return localVarFp.getAvailablePaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payment method instance balance
         * @param {string} paymentMethodId payment method instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(paymentMethodId: string, options?: any): AxiosPromise<SuccessGetBalanceDto> {
            return localVarFp.getBalance(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get conversion rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversionRates(options?: any): AxiosPromise<SuccessGetConversionRatesDto> {
            return localVarFp.getConversionRates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the avialable types for currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyTypeValues(options?: any): AxiosPromise<SuccessCurrencyTypeValuesDto> {
            return localVarFp.getCurrencyTypeValues(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} [wallet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(wallet?: string, options?: any): AxiosPromise<SuccessGetDashboardDto> {
            return localVarFp.getDashboard(wallet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the exchange rate for the provided currency conversion, including the amount calculation.
         * @param {string} fromCurrencyId 
         * @param {string} toCurrencyId 
         * @param {number} amount 
         * @param {string} [method] Can be internal, exchange, bank, card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(fromCurrencyId: string, toCurrencyId: string, amount: number, method?: string, options?: any): AxiosPromise<SuccessGetExchangeRateDto> {
            return localVarFp.getExchangeRate(fromCurrencyId, toCurrencyId, amount, method, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the payment method for this user
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId: string, options?: any): AxiosPromise<SuccessGetPaymentMethodDto> {
            return localVarFp.getPaymentMethod(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payment methods
         * @param {string} [baseType] 
         * @param {string} [walletName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(baseType?: string, walletName?: string, options?: any): AxiosPromise<SuccessGetPaymentMethodsDto> {
            return localVarFp.getPaymentMethods(baseType, walletName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payment method instance settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreferences(options?: any): AxiosPromise<SuccessGetPaymentMethodInstanceSettingResponse> {
            return localVarFp.getPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get request fund send to current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundById(requestFundId: string, options?: any): AxiosPromise<SuccessGetRequestFundByIdDto> {
            return localVarFp.getRequestFundById(requestFundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get request fund send from current user by request fund id
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundToUserById(requestFundId: string, options?: any): AxiosPromise<SuccessGetRequestFundToUserByIdDto> {
            return localVarFp.getRequestFundToUserById(requestFundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsFromUsers(options?: any): AxiosPromise<SuccessGetRequestFundsFromUsersDto> {
            return localVarFp.getRequestFundsFromUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all requested funds from current user to other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsToUsers(options?: any): AxiosPromise<SuccessGetRequestFundsToUsersDto> {
            return localVarFp.getRequestFundsToUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all requested funds for current user
         * @param {string} requestFundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestFundsViaLink(requestFundId: string, options?: any): AxiosPromise<SuccessGetRequestFundsViaLinkDto> {
            return localVarFp.getRequestFundsViaLink(requestFundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction for payment method instance
         * @param {string} paymentMethodId 
         * @param {number} [page] 
         * @param {number} [itemCount] 
         * @param {string} [beginDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(paymentMethodId: string, page?: number, itemCount?: number, beginDate?: string, endDate?: string, options?: any): AxiosPromise<SuccessGetTransactionsDto> {
            return localVarFp.getTransactions(paymentMethodId, page, itemCount, beginDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get app version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<SuccessGetVersionDto> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wallet info for a specific user and wallet
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(name?: string, options?: any): AxiosPromise<SuccessGetWalletDto> {
            return localVarFp.getWallet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wallets for a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets(options?: any): AxiosPromise<SuccessListWalletDtoResponse> {
            return localVarFp.getWallets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock payment method instance
         * @param {LockPaymentMethodRequest} [lockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPaymentMethod(lockPaymentMethodRequest?: LockPaymentMethodRequest, options?: any): AxiosPromise<SuccessLockPaymentMethodDto> {
            return localVarFp.lockPaymentMethod(lockPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pay request fund via link
         * @param {PayRequestFundViaLinkRequest} [payRequestFundViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payRequestFundViaLink(payRequestFundViaLinkRequest?: PayRequestFundViaLinkRequest, options?: any): AxiosPromise<SuccessPayRequestFundViaLinkDto> {
            return localVarFp.payRequestFundViaLink(payRequestFundViaLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary current user pay for user fund request
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payUserFundRequest(payUserFundRequest?: PayUserFundRequest, options?: any): AxiosPromise<SuccessPayUserFundRequestDto> {
            return localVarFp.payUserFundRequest(payUserFundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PayUserFundRequest} [payUserFundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payUserFundRequestByChat(payUserFundRequest?: PayUserFundRequest, options?: any): AxiosPromise<SuccessPayUserFundRequestDto> {
            return localVarFp.payUserFundRequestByChat(payUserFundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request fund from user
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundToUser(requestFundToUserRequest?: RequestFundToUserRequest, options?: any): AxiosPromise<SuccessRequestFundToUserDto> {
            return localVarFp.requestFundToUser(requestFundToUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundToUserByChat(requestFundToUserRequest?: RequestFundToUserRequest, options?: any): AxiosPromise<SuccessRequestFundToUserDto> {
            return localVarFp.requestFundToUserByChat(requestFundToUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request funds via link``
         * @param {RequestFundsViaLinkRequest} [requestFundsViaLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestFundsViaLink(requestFundsViaLinkRequest?: RequestFundsViaLinkRequest, options?: any): AxiosPromise<SuccessRequestFundsViaLinkDto> {
            return localVarFp.requestFundsViaLink(requestFundsViaLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send funds from a payment method to an external bank account. This external account can be SWIFT or local account.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
         * @param {SendToBankRequest} [sendToBankRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToBank(sendToBankRequest?: SendToBankRequest, options?: any): AxiosPromise<SuccessSendToBankDto> {
            return localVarFp.sendToBank(sendToBankRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send funds to an external crypto address. The user must ensure the address is correct or funds will be lost.
         * @param {SendToCryptoRequest} [sendToCryptoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToCrypto(sendToCryptoRequest?: SendToCryptoRequest, options?: any): AxiosPromise<SuccessSendToCryptoDto> {
            return localVarFp.sendToCrypto(sendToCryptoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToUser(sendToUserRequest?: SendToUserRequest, options?: any): AxiosPromise<SuccessSendToUserDto> {
            return localVarFp.sendToUser(sendToUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send To User in chat page
         * @param {SendToUserRequest} [sendToUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToUserByChat(sendToUserRequest?: SendToUserRequest, options?: any): AxiosPromise<SuccessSendToUserDto> {
            return localVarFp.sendToUserByChat(sendToUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the main bank account for this user to use for incoming(!) payments.
         * @param {SetMainBankAccountRequest} [setMainBankAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMainBankAccount(setMainBankAccountRequest?: SetMainBankAccountRequest, options?: any): AxiosPromise<SuccessSetMainBankAccountDto> {
            return localVarFp.setMainBankAccount(setMainBankAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set payment method instance setting
         * @param {SetPreferenceRequest} [setPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPreference(setPreferenceRequest?: SetPreferenceRequest, options?: any): AxiosPromise<SuccessSetPaymentMethodInstanceSettingResponse> {
            return localVarFp.setPreference(setPreferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlock payment method instance
         * @param {UnlockPaymentMethodRequest} [unlockPaymentMethodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockPaymentMethod(unlockPaymentMethodRequest?: UnlockPaymentMethodRequest, options?: any): AxiosPromise<SuccessUnlockPaymentMethodDto> {
            return localVarFp.unlockPaymentMethod(unlockPaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Add an existing bank account to the PMIs of the user.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
     * @param {AddBankAccountRequest} [addBankAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public addBankAccount(addBankAccountRequest?: AddBankAccountRequest, options?: any) {
        return WalletApiFp(this.configuration).addBankAccount(addBankAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddCardRequest} [addCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public addCard(addCardRequest?: AddCardRequest, options?: any) {
        return WalletApiFp(this.configuration).addCard(addCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an internal custodian account; this acccount is held with a 3rd party provider (including SimSecSecure) for storing user crypto currency  amounts. The user does not have the private key for this account which allows security for TFX over the funds.
     * @param {AddCustodianCryptoRequest} [addCustodianCryptoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public addCustodianCrypto(addCustodianCryptoRequest?: AddCustodianCryptoRequest, options?: any) {
        return WalletApiFp(this.configuration).addCustodianCrypto(addCustodianCryptoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add prepaid account
     * @param {AddPrepaidAccountRequest} [addPrepaidAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public addPrepaidAccount(addPrepaidAccountRequest?: AddPrepaidAccountRequest, options?: any) {
        return WalletApiFp(this.configuration).addPrepaidAccount(addPrepaidAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary current user decline fund request
     * @param {DeclineUserFundRequest} [declineUserFundRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public declineUserFundRequest(declineUserFundRequest?: DeclineUserFundRequest, options?: any) {
        return WalletApiFp(this.configuration).declineUserFundRequest(declineUserFundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeclineUserFundRequest} [declineUserFundRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public declineUserFundRequestByChat(declineUserFundRequest?: DeclineUserFundRequest, options?: any) {
        return WalletApiFp(this.configuration).declineUserFundRequestByChat(declineUserFundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Use to delete payment Method
     * @param {DeletePaymentMethodRequest} [deletePaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public deletePaymentMethod(deletePaymentMethodRequest?: DeletePaymentMethodRequest, options?: any) {
        return WalletApiFp(this.configuration).deletePaymentMethod(deletePaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete current user
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public deleteUser(body?: object, options?: any) {
        return WalletApiFp(this.configuration).deleteUser(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit payment method
     * @param {EditPaymentMethodRequest} [editPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public editPaymentMethod(editPaymentMethodRequest?: EditPaymentMethodRequest, options?: any) {
        return WalletApiFp(this.configuration).editPaymentMethod(editPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an exchange, in your own account, from PMI to PMI. The conversion from currency to currency will be automatic and fees will be added automatically.
     * @param {ExchangePaymentRequest} [exchangePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public exchangePayment(exchangePaymentRequest?: ExchangePaymentRequest, options?: any) {
        return WalletApiFp(this.configuration).exchangePayment(exchangePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available cryptocurrency/blockchain methods that are available to this user. The response contains all information needed to   add payment methods to the wallet of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getAvailableCrypto(options?: any) {
        return WalletApiFp(this.configuration).getAvailableCrypto(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the available methods for the user in the region of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getAvailablePaymentMethods(options?: any) {
        return WalletApiFp(this.configuration).getAvailablePaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payment method instance balance
     * @param {string} paymentMethodId payment method instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getBalance(paymentMethodId: string, options?: any) {
        return WalletApiFp(this.configuration).getBalance(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get conversion rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getConversionRates(options?: any) {
        return WalletApiFp(this.configuration).getConversionRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the avialable types for currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCurrencyTypeValues(options?: any) {
        return WalletApiFp(this.configuration).getCurrencyTypeValues(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard
     * @param {string} [wallet] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getDashboard(wallet?: string, options?: any) {
        return WalletApiFp(this.configuration).getDashboard(wallet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the exchange rate for the provided currency conversion, including the amount calculation.
     * @param {string} fromCurrencyId 
     * @param {string} toCurrencyId 
     * @param {number} amount 
     * @param {string} [method] Can be internal, exchange, bank, card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getExchangeRate(fromCurrencyId: string, toCurrencyId: string, amount: number, method?: string, options?: any) {
        return WalletApiFp(this.configuration).getExchangeRate(fromCurrencyId, toCurrencyId, amount, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the payment method for this user
     * @param {string} paymentMethodId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getPaymentMethod(paymentMethodId: string, options?: any) {
        return WalletApiFp(this.configuration).getPaymentMethod(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payment methods
     * @param {string} [baseType] 
     * @param {string} [walletName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getPaymentMethods(baseType?: string, walletName?: string, options?: any) {
        return WalletApiFp(this.configuration).getPaymentMethods(baseType, walletName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payment method instance settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getPreferences(options?: any) {
        return WalletApiFp(this.configuration).getPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get request fund send to current user
     * @param {string} requestFundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getRequestFundById(requestFundId: string, options?: any) {
        return WalletApiFp(this.configuration).getRequestFundById(requestFundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get request fund send from current user by request fund id
     * @param {string} requestFundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getRequestFundToUserById(requestFundId: string, options?: any) {
        return WalletApiFp(this.configuration).getRequestFundToUserById(requestFundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all requested funds for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getRequestFundsFromUsers(options?: any) {
        return WalletApiFp(this.configuration).getRequestFundsFromUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all requested funds from current user to other users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getRequestFundsToUsers(options?: any) {
        return WalletApiFp(this.configuration).getRequestFundsToUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all requested funds for current user
     * @param {string} requestFundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getRequestFundsViaLink(requestFundId: string, options?: any) {
        return WalletApiFp(this.configuration).getRequestFundsViaLink(requestFundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction for payment method instance
     * @param {string} paymentMethodId 
     * @param {number} [page] 
     * @param {number} [itemCount] 
     * @param {string} [beginDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getTransactions(paymentMethodId: string, page?: number, itemCount?: number, beginDate?: string, endDate?: string, options?: any) {
        return WalletApiFp(this.configuration).getTransactions(paymentMethodId, page, itemCount, beginDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getVersion(options?: any) {
        return WalletApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wallet info for a specific user and wallet
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getWallet(name?: string, options?: any) {
        return WalletApiFp(this.configuration).getWallet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wallets for a specific user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getWallets(options?: any) {
        return WalletApiFp(this.configuration).getWallets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock payment method instance
     * @param {LockPaymentMethodRequest} [lockPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public lockPaymentMethod(lockPaymentMethodRequest?: LockPaymentMethodRequest, options?: any) {
        return WalletApiFp(this.configuration).lockPaymentMethod(lockPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pay request fund via link
     * @param {PayRequestFundViaLinkRequest} [payRequestFundViaLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public payRequestFundViaLink(payRequestFundViaLinkRequest?: PayRequestFundViaLinkRequest, options?: any) {
        return WalletApiFp(this.configuration).payRequestFundViaLink(payRequestFundViaLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary current user pay for user fund request
     * @param {PayUserFundRequest} [payUserFundRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public payUserFundRequest(payUserFundRequest?: PayUserFundRequest, options?: any) {
        return WalletApiFp(this.configuration).payUserFundRequest(payUserFundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PayUserFundRequest} [payUserFundRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public payUserFundRequestByChat(payUserFundRequest?: PayUserFundRequest, options?: any) {
        return WalletApiFp(this.configuration).payUserFundRequestByChat(payUserFundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request fund from user
     * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public requestFundToUser(requestFundToUserRequest?: RequestFundToUserRequest, options?: any) {
        return WalletApiFp(this.configuration).requestFundToUser(requestFundToUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestFundToUserRequest} [requestFundToUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public requestFundToUserByChat(requestFundToUserRequest?: RequestFundToUserRequest, options?: any) {
        return WalletApiFp(this.configuration).requestFundToUserByChat(requestFundToUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request funds via link``
     * @param {RequestFundsViaLinkRequest} [requestFundsViaLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public requestFundsViaLink(requestFundsViaLinkRequest?: RequestFundsViaLinkRequest, options?: any) {
        return WalletApiFp(this.configuration).requestFundsViaLink(requestFundsViaLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send funds from a payment method to an external bank account. This external account can be SWIFT or local account.   The required parameters depend on the type of bank account of the receiving party. Address is required in the case  of SWIFT accounts, but not if the account is local.
     * @param {SendToBankRequest} [sendToBankRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public sendToBank(sendToBankRequest?: SendToBankRequest, options?: any) {
        return WalletApiFp(this.configuration).sendToBank(sendToBankRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send funds to an external crypto address. The user must ensure the address is correct or funds will be lost.
     * @param {SendToCryptoRequest} [sendToCryptoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public sendToCrypto(sendToCryptoRequest?: SendToCryptoRequest, options?: any) {
        return WalletApiFp(this.configuration).sendToCrypto(sendToCryptoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendToUserRequest} [sendToUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public sendToUser(sendToUserRequest?: SendToUserRequest, options?: any) {
        return WalletApiFp(this.configuration).sendToUser(sendToUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send To User in chat page
     * @param {SendToUserRequest} [sendToUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public sendToUserByChat(sendToUserRequest?: SendToUserRequest, options?: any) {
        return WalletApiFp(this.configuration).sendToUserByChat(sendToUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the main bank account for this user to use for incoming(!) payments.
     * @param {SetMainBankAccountRequest} [setMainBankAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public setMainBankAccount(setMainBankAccountRequest?: SetMainBankAccountRequest, options?: any) {
        return WalletApiFp(this.configuration).setMainBankAccount(setMainBankAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set payment method instance setting
     * @param {SetPreferenceRequest} [setPreferenceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public setPreference(setPreferenceRequest?: SetPreferenceRequest, options?: any) {
        return WalletApiFp(this.configuration).setPreference(setPreferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlock payment method instance
     * @param {UnlockPaymentMethodRequest} [unlockPaymentMethodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public unlockPaymentMethod(unlockPaymentMethodRequest?: UnlockPaymentMethodRequest, options?: any) {
        return WalletApiFp(this.configuration).unlockPaymentMethod(unlockPaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


